/*_ mbbtombc.c						*/
/* Copyright (C) 1995 by Digital Mars		*/
/* All Rights Reserved					*/

#ifdef _MBCS

#include <mbctype.h>
#include <mbstring.h>
#include <setmbcp.h>

static unsigned short mbbtombc[] = {
  0x8140, 0x8149, 0x8168, 0x8194, 0x8190, 0x8193, 0x8195, 0x8166, /* 0x20 */
  0x8169, 0x816A, 0x8196, 0x817B, 0x8143, 0x817C, 0x8144, 0x815E,
  0x824F, 0x8250, 0x8251, 0x8252, 0x8253, 0x8254, 0x8255, 0x8256, /* 0x30 */
  0x8257, 0x8258, 0x8146, 0x8147, 0x8183, 0x8181, 0x8184, 0x8148,
  0x8197, 0x8260, 0x8261, 0x8262, 0x8263, 0x8264, 0x8265, 0x8266, /* 0x40 */
  0x8267, 0x8268, 0x8269, 0x826A, 0x826B, 0x826C, 0x826D, 0x826E,
  0x826F, 0x8270, 0x8271, 0x8272, 0x8273, 0x8274, 0x8275, 0x8276, /* 0x50 */
  0x8277, 0x8278, 0x8279, 0x816D, 0x818F, 0x816E, 0x814F, 0x8151,
  0x8165, 0x8281, 0x8282, 0x8283, 0x8284, 0x8285, 0x8286, 0x8287, /* 0x60 */
  0x8288, 0x8289, 0x828A, 0x828B, 0x828C, 0x828D, 0x828E, 0x828F,
  0x8290, 0x8291, 0x8292, 0x8293, 0x8294, 0x8295, 0x8296, 0x8297, /* 0x70 */
  0x8298, 0x8299, 0x829A, 0x816F, 0x8162, 0x8170, 0x8150, 0x0000,

  0x8140, 0x8142, 0x8175, 0x8176, 0x8141, 0x8145, 0x8392, 0x8340, /* 0xA0 */
  0x8342, 0x8344, 0x8346, 0x8348, 0x8383, 0x8385, 0x8387, 0x8362,
  0x815B, 0x8341, 0x8343, 0x8345, 0x8347, 0x8349, 0x834A, 0x834C, /* 0xB0 */
  0x834E, 0x8350, 0x8352, 0x8354, 0x8356, 0x8358, 0x835A, 0x835C,
  0x835E, 0x8360, 0x8363, 0x8365, 0x8367, 0x8369, 0x836A, 0x836B, /* 0xC0 */
  0x836C, 0x836D, 0x836E, 0x8371, 0x8374, 0x8377, 0x837A, 0x837D,
  0x837E, 0x8380, 0x8381, 0x8382, 0x8384, 0x8386, 0x8388, 0x8389, /* 0xD0 */
  0x838A, 0x838B, 0x838C, 0x838D, 0x838F, 0x8393, 0x814A, 0x814B
};

unsigned int __cdecl _mbbtombc (unsigned int ch) {
  if (__mbcodepage == _KANJI_CP) {
    if (ch >= 0x20 && ch < 0x7F) {		/* Ascii */
      ch = mbbtombc[ch - 0x20];
    } else if (ch >= 0xA1 && ch < 0xE0) {	/* Katakana */
      ch = mbbtombc[ch - 0xA0 + (0x80 - 0x20)];
    }
  }
  return ch;
}

static unsigned char mbctombb[] = {
  0xA7, 0xB1, 0xA8, 0xB2, 0xA9, 0xB3, 0xAA, 0xB4,
  0xAB, 0xB5, 0xB6, 0xB6, 0xB7, 0xB7, 0xB8, 0xB8,
  0xB9, 0xB9, 0xBA, 0xBA, 0xBB, 0xBB, 0xBC, 0xBC,
  0xBD, 0xBD, 0xBE, 0xBE, 0xBF, 0xBF, 0xC0, 0xC0,
  0xC1, 0xC1, 0xAF, 0xC2, 0xC2, 0xC3, 0xC3, 0xC4,
  0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCA,
  0xCA, 0xCB, 0xCB, 0xCB, 0xCC, 0xCC, 0xCC, 0xCD,
  0xCD, 0xCD, 0xCE, 0xCE, 0xCE, 0xCF, 0xD0, 0x00,	/* 0x837F is Hole */
  0xD1, 0xD2, 0xD3, 0xAC, 0xD4, 0xAD, 0xD5, 0xAE,
  0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDC,
  0xB2, 0xB4, 0xA6, 0xDD, 0xB3, 0xB6, 0xB9, 0x00
};

unsigned int __cdecl _mbctombb (unsigned int ch) {
  if (__mbcodepage == _KANJI_CP) {
    if (ch >= 0x829F && ch <= 0x82F1) {		/* Hiragana */
      ch += 0xA1;
      if (ch >= 0x837F) {
        ch++;
      }
      ch = mbctombb[ch - 0x8340];
    } else if (ch >= 0x8340 && ch <= 0x8396) {	/* Katakana */
      if (ch != 0x837F) {
        ch = mbctombb[ch - 0x8340];
      }
    } else if (ch >= 0x8140 && ch < 0x8397) {	/* Ascii and etc. */
     int	i;
      for (i = 0; i < sizeof(mbbtombc) / sizeof(unsigned short); i++) {
        if (mbbtombc[i] == ch) {
          ch = i + 0x20;
          if (ch >= 0x80) {
            ch += 0x20;
          }
          break;
        }
      }
    }
  }
  return ch;
}

#endif

