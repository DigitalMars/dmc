
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - Compiling Code
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:25:45 2006
</div>
</div>

<!-- Generated by Ddoc from ctgCompilingCode.d -->



<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ctg">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>
</center>

    <a href="ctg.html"><b>Compiler & Tools Guide</b></a><br>

<hr><b>Compiling</b><br>

    &#149; <a href="ctgCompilingCode.html">Compiling Code</a><br>
    &#149; <a href="C-Language-Implementation.html">C Implementation</a><br>
    &#149; <a href="CPP-Language-Implementation.html">C++ Implementation</a><br>
    &#149; <a href="ctgLanguageImplementation.html">Language Extensions</a><br>
    &#149; <a href="ctgMixingLanguages.html">Mixing Languages</a><br>
    &#149; <a href="ctgAsm.html">Assembly Language</a><br>
    &#149; <a href="ctgInlineAsm.html">Inline Assembler</a><br>
    &#149; <a href="ctgOptimizer.html">Optimizing Code</a><br>
    &#149; <a href="ctgNumerics.html">Numerics Programming</a><br>
    &#149; <a href="regular.html">Regular Expressions</a><br>
    &#149; <a href="acrtused.html">Acrtused</a><br>
    &#149; <a href="pragmas.html">Pragmas</a><br>
    &#149; <a href="precompiled.html">Precompiled Headers</a><br>
    &#149; <a href="predefined.html">Predefined Macros</a><br>
    &#149; <a href="warnings.html">Warning Messages</a><br>
    &#149; <a href="ctgCompilerErrors.html">Error Messages</a><br>
    &#149; <a href="warnings.html#runtime">Runtime Messages</a><br>
    <br>

<hr><b>Linking</b><br>

    &#149; <a href="optlink.html">Optlink</a><br>
    &#149; <a href="ctgLinkSwitches.html">Switches</a><br>
    &#149; <a href="ctgDefFiles.html">Module Definition Files</a><br>
    &#149; <a href="ctgLinkOps.html">Operation and Design</a><br>
    &#149; <a href="OptlinkErrorMessages.html">Error Messages</a><br>
    <br>

<hr><b>Win32 Programming</b><br>

    &#149; <a href="win32programming.html#win32">Win32 Programming</a><br>
    <br>

<hr><b>DOS and Win16<br>Programming</b><br>

    &#149; <a href="ctgMemoryModel.html">Memory Models</a><br>
    &#149; <a href="pointers16.html">16 Bit Pointer Types<br> and Type Modifiers</a><br>
    &#149; <a href="win32programming.html#handle">Handle Pointers</a><br>
    &#149; <a href="win32programming.html#dos">DOS</a><br>
    &#149; <a href="dos32.html">DOS 32 (DOSX)</a><br>
    &#149; <a href="win32programming.html#win16">Win16</a><br>
    &#149; <a href="win32programming.html#win16dll">Win16 DLLs</a><br>
    &#149; <a href="windowspe.html">Win16 Prolog/Epilog</a><br>
    <br>

<hr><b>C/C++ Extensions</b><br>

    &#149; <a href="contract.html">Contract Programming</a><br>
    &#149; <a href="debugstatement.html">__debug statement</a><br>
    &#149; <a href="debugstatement.html#debugdeclaration">__debug declaration</a><br>
    &#149; <a href="trace.html">Dynamic Profiling</a><br>
    &#149; <a href="html.html">Embedding C in HTML</a><br>
    <br>

<hr><b>Tools</b><br>

    &#149; <a href="bcc.html" title="Convert Borland compiler commands">BCC</a><br>
    &#149; <a href="chmod.html" title="Examine and change file attributes">CHMOD</a><br>
    &#149; <a href="cl.html" title="Convert Microsoft compiler commands">CL</a><br>
    &#149; <a href="coff2omf.html" title="Convert COFF .obj and .lib to OMF">COFF2OMF</a><br>
    &#149; <a href="coffimplib.html" title="Convert COFF import library OMF">COFFIMPLIB</a><br>
    &#149; <a href="sc.html" title="Compiler command">DMC</a><br>
    &#149; <a href="diff.html" title="Compare files">DIFF</a><br>
    &#149; <a href="diffdir.html" title="Compare directories">DIFFDIR</a><br>
    &#149; <a href="dump.html" title="Dump files in hex">DUMP</a><br>
    &#149; <a href="dumpobj.html" title="Dump object files in hex">DUMPOBJ</a><br>
    &#149; <a href="dumpexe.html" title="Dump exe files">DUMPEXE</a><br>
    &#149; <a href="exe2bin.html" title="Create .com files">EXE2BIN</a><br>
    &#149; <a href="flpyimg.html" title="Read/Write Floppy Image">FLPYIMG</a><br>
    &#149; <a href="grep.html" title="Search files for string">GREP</a><br>
    &#149; <a href="ctgHelp.html" title="Creating Help Tools">HC</a><br>
    &#149; <a href="implib.html" title="Build import libraries">IMPLIB</a><br>
    &#149; <a href="lib.html" title="Object file librarian">LIB</a><br>
    &#149; <a href="libunres.html" title="Analyze library and object files">LIBUNRES</a><br>
    &#149; <a href="make.html" title="Simple make utility">MAKE</a><br>
    &#149; <a href="makedep.html" title="Update makefile dependencies">MAKEDEP</a><br>
    &#149; <a href="me.html" title="MicroEmacs Text Editor">ME</a><br>
    &#149; <a href="obj2asm.html" title="Object file disassembler">OBJ2ASM</a><br>
    &#149; <a href="patchobj.html" title="Patch object files">PATCHOBJ</a><br>
    &#149; <a href="ctgRC.html" title="Microsoft Resource compiler">RC</a><br>
    &#149; <a href="rcc.html" title="Digital Mars Resource compiler">RCC</a><br>
    &#149; <a href="sc.html" title="Compiler command">SC</a><br>
    &#149; <a href="shell.html" title="Shell scripts">SHELL</a><br>
    &#149; <a href="smake.html" title="Manage complex projects">SMAKE</a><br>
    &#149; <a href="touch.html" title="Set file timestamps">TOUCH</a><br>
    &#149; <a href="unmangle.html" title="Format C++ mangled names">UNMANGLE</a><br>
    &#149; <a href="whereis.html" title="Search for files">WHEREIS</a><br>
    <br>

<hr><b>Porting to DMC++</b><br>

    &#149; <a href="switchtodigitalmars.html">Switching to DMC++</a><br>
    &#149; <a href="switchtodigitalmars.html#microsoft">from Microsoft</a><br>
    &#149; <a href="switchtodigitalmars.html#borland">from Borland</a><br>
    &#149; <a href="ctgPorting.html">Porting Guide</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>Compiling Code</h1>

This chapter describes how the compiler works by default and how
to customize the compiler's output. It covers both 16-bit and 32-bit
compilations.


<ul>
	<li> <a href="#console">The Command Line</a>
	<li> <a href="#example">A Simple Example</a>
	<li> <a href="#process">Compilation Process</a> 
	<li> <a href="#options">Compiler Options</a>
	<li> <a href="#memorymodels">Choosing a memory model</a>
	<li> <a href="#debugging">Compiling for debugging</a>
	<li> <a href="#internationalization">Internationalization Options</a>
	<li> <a href="ctgNumerics.html#floatingpoint">Compiling for floating-point emulation and math coprocessors</a>
</ul>

<a name="console"><h2>The Command Line</h2></a>

The compiler comes in two forms, the command line tools and the
<a href="../ugr/ugr.html" title="IDDE Reference" target="_top">IDDE</a>.
The free downloadable version is run from the command line.
The IDDE version comes on the
<a href="http://www.digitalmars.com/shop.html" title="DMC++ CD" target="_top">CD</a>.
To run the command line tools, open a console window. Under Windows XP,
click on [Start] then [Command Prompt].


<a name="example">
<h2>A Simple Example</h2>
</a>

To illustrate compiling the classic <b>hello world!</b> program using the console
compiler, create a text file <tt>hello.c</tt> with the contents:

<pre class="ccode">#include &lt;stdio.h&gt;

void main()
{
    printf("hello world!\n");
}
</pre>

Compile and link it with the following command:

<pre class="console"><a href="sc.html"><b>dmc</b></a> hello
</pre>

which will compile <tt>hello.c</tt> to create the object file
<tt>hello.obj</tt> which is linked to generate the executable
<tt>hello.exe</tt>. To run the executable type:

<pre class="console">hello
</pre>

which will print:

<pre class="console">hello world!
</pre>

<a name="process">
<h2>Compilation Process</h2>
</a>

Digital Mars C++ is an extremely fast one-pass compilation system with 
highly effective register utilization. An optional global optimization 
facility provides tight and efficient object code. Run the compiler 
from within the IDDE or more traditionally using <a href="sc.html"><b>dmc</b></a> from the console
command line.
<p>

The compiler executables can compile either C or C++ files. The preprocessor
is integrated in; but for specialized applications a separate standalone
preprocessor is also included.
<p>

As it runs, the compiler reads the source files, executes all 
preprocessor functions, checks for any syntax errors, optimizes the
program, generates machine code, and outputs an object (.obj) file
suitable for input to the linker.

<h3>Startup code</h3>

Programs compiled with Digital Mars C++ call one of several startup 
functions before passing control to a program's main() routine. 
(The startup function called depends on what kind of application is 
being built, as described in <a href="acrtused.html">__acrtused</a>.) 
This startup function performs any required initializations
such as initializing data and running the static constructors.
<p>

There are several files that contain startup functions (all with 
different names) in several subdirectories of the Digital Mars 
\dm\src directory. 

<a name="options">
<h2>Compiler Options</h2>
</a>

Compiler options customizes the way Digital Mars C and C++ 
compile programs. Specify compiler options via the Build 
page in the IDDE's Project Settings dialog box or by passing 
options as command line arguments to the
<a href="sc.html"><b>dmc</b></a> (or sc) 
control program. All compiler options are optional; the
default settings are oriented towards generating a complete compiled
program.


<h3>Specifying compiler output</h3>

By default, Digital Mars C++ compiles and links the source files
given on the command line
and generates an executable file whose name is the same as 
the name of the first source file with the extension replaced with .exe. 
To generate different files or additional 
files use the <a href="sc.html"><b>dmc</b></a> options described below or via corresponding 
options in the Compiler Output subpage on the Build page of the 
IDDE's Project Settings dialog box. 

<ul>
	<b>-cod</b>  Generate assembly language output file<p>

	<b>-e</b>   Show preprocessor output <p>

	<b>-EC</b>  Leave comments in preprocessed output <p>

	<b>-EL</b>  Do not emit #line directives <p>

	<b>-l</b>[<i>listfile</i>]  Generate source listing file <p>

	<b>-o</b><i>filename</i>  Specify output .obj or .exe <i>filename</i> <p>

	<b>-v[0|1|2]</b> verbose compile<p>
</ul>

<h3>Support for C language features</h3>

<ul>
	<b>-A</b> Enforce strict compliance with ANSI C <p>

	<b>-J</b> Treat chars as unsigned <p>

	<b>-Jm</b> Relax type-checking <p>

	<b>-Ju</b> char and unsigned char are the same type (unsigned char) <p>

	<b>-p</b> Turn off function auto-prototyping <p>

	<b>-r</b> Require strict function prototyping <p>

	<b>-u</b> Suppress non-ANSI predefined macros <p>

</ul>

<h3>Support for C++ language features</h3>

Digital Mars C++ supports run time type identification, exception 
handling. These C++ 
language features are not enabled by default; to enable them, 
specify compiler options as described below. 

<ul>
	<b>-A</b> Enforce strict compliance with ANSI C++ <p>

	<b>-Ar</b> Enable run time type identification <p>

	<b>-Ae</b> Enable exception handling <p>

	<b>-cpp</b> Compile all source files as C++ <p>

	<b>-J</b> Treat chars as unsigned <p>

	<b>-u</b> Suppress non-ANSI predefined macros <p>

</ul>

<h3>Suppressing warnings and errors</h3>

By default, the compiler generates
warnings about certain constructs that, while legal, are likely
mistakes. Warnings can be disabled individually or as a group.
Warnings can also be treated as errors.
In the IDDE, these are set via the Compiler Output 
subpage on the Build page of the IDDE's Project Settings dialog 
box. 
See <a href="warnings.html">"Warnings and associated warning numbers"</a> for messages.

<ul>
	<b>-w</b> Suppress all warning messages <p>

	<b>-w</b>[<i>number</i>] Suppressing warning message <i>number</i> <p>

	<b>-w-</b> Show all compiler warnings <p>

	<b>-wx</b> Treat warnings as errors <p>

	<b>-x</b> Turn off compilation error limit <p>
</ul>


<h3>Dynamic profiling</h3>

<ul>
	<b>-gt</b> and <b>-Nc</b>	Turn on dynamic profiling. <p>
</ul>

	See <a href="trace.html">Trace Dynamic Profiling</a>.

<a name="memorymodels">
<h2>Choosing a memory model</h2>
</a>

When programming for Win32, it is not necessary to choose a memory model.
The compiler defaults to compiling for Win32. Compiling 16 bit code or
DOS extender code will require choosing a memory model.
<p>

Memory model choices trade off between meeting 
minimum system requirements, maximizing code efficiency, 
and accessing as much available memory as possible. 
<p>

For more information, see Chapter 7, "Choosing a Memory Model." 
To specify the memory model, use the <a href="sc.html"><b>dmc</b></a> options 
described below or use the Memory Models subpage on the Build 
page of the IDDE's Project Settings dialog box. 
<p>

For more information on memory allocation, see Chapter 5, "Using 
Assembly Language Functions." 
<p>

<ul>
	<b>-m[tsmclvfnrpxz][do][w][u]</b> Select memory model</a>
</ul>

Specifies the memory model to compile for.
The default for <a href="sc.html"><b>dmc</b></a> is the 
Win32 model (-mn).

	<table border=1 cellpadding=4 cellspacing=0>
	<th>switch
	<th>Code size
	<th>Data size
	<th>Model
	<tr>
	<td><b>t</b>	<td>64Kb <td>64Kb	<td>Tiny (.COM program, code+data &lt; 64Kb)
	<tr>
	<td><b>s</b>	<td>64Kb <td>64Kb	<td>Small (default) 64KB 64KB 
	<tr>
	<td><b>m</b>	<td>1MB	<td>64KB	<td>Medium  
	<tr>
	<td><b>c</b>	<td>64KB <td>1MB	<td>Compact  
	<tr>
	<td><b>l</b>	<td>1MB	<td>1MB		<td>Large 
	<tr>
	<td><b>x</b>	<td>4GB	<td>4GB		<td>DOSX 32-Bit Extended:
				requires DOSX DOS Extender
	<tr>
	<td><b>p</b>	<td>4GB	<td>4GB		<td>Phar Lap 32-Bit Extended:
				requires Phar Lap 386|DOS Extender SDK 
				(5.0 or newer). 
	<tr>
	<td><b>n</b>	<td>4GB	<td>4GB		<td>Win32 (Win32s, Windows 95, 98, NT, 2000, ME, XP), default
	<tr>
	<td><b>f</b>	<td>4GB	<td>4GB		<td>OS/2 2.0 (Flat) (obsolete)
	<tr>
	<td><b>v</b>	<td>1MB	<td>1MB		<td>VCM (obsolete) 
	<tr>
	<td><b>r</b>	<td>16MB <td>16MB	<td>Rational 286 DOS Extender (obsolete)
	</table>
<p>

<b>Note:</b> 
For Win32, it is imperative that SS==DS==ES 
at all times. Otherwise the Win32 API functions will 
crash. (CS need not be equal to SS, FS is reserved 
for thread-related information, and GS is available 
for general use.) Thus, SS==DS==ES for the Win32 
(-mn) memory model. 
<p>

Here are some example combinations of memory model specifiers: 


<pre>
-ms		Small model with SS == DS 
-msw		Small model SS != DS 
-mc		Compact model 
-mt		.com file 
-mluw		Large model, SS != DS, Reload DS 
</pre>

<h3>The program stack</h3>

Win32 programs generally do not need to worry about stack overflows,
but other memory model options require some attention to it.
<p>

In all memory models, the stack grows downward toward statically 
allocated data. If the stack grows larger than its allocated size, 
statically allocated data are destroyed, and the program performs 
unpredictably. To check if the stack grows past the allocated limit, 
use the special function called _chkstack. 
<p>

Call _chkstack from functions that potentially use large amounts 
of stack space, such as recursive functions. If the stack exceeds the 
allocated size, _chkstack aborts the program with the message: 

<pre class="console">Stack overflow 
</pre>

Use the -s compiler option (see below) to generate stack-overflow 
checking code on entry to every function, although this increases 
program size and reduces speed. Use stack-overflow checking if you 
suspect stack-overflow errors (a symptom is a mysterious crash). 


<h3>Controlling stack size for DOS programs</h3>

Control a DOS program's stack size in the following ways: 

<ul>
	<li> Use the =nnnn command line option (see below) when 
	running the program. 

	<li> Include the declaration

<pre class="ccode">unsigned __cdecl _stack = nnnn;
</pre>

	in the program source code, where nnnn is the 
	size in bytes that you want the stack to be. For C++ code, 
	use: 

<pre class="ccode">extern "C" unsigned __cdecl _stack = nnnn; 
</pre>

	Note that the declaration must appear just as described 
	above to work correctly. 

	<li> Modify the c.asm startup module. 
</ul>

For Win16 compilations, use the linker's /STACK switch to set the stack size. 
<p>

For a DOS program, do not use the linker /STACK 
parameter to set the stack size; use one of the 
methods described above. 
The default stack size is 8192 bytes for 16-bit compilations and 16KB 
for 32-bit compilations. 

<ul>
	<b>-s</b> Check for stack overflow <p>
</ul>

<h3>Aligning data objects</h3>

In 16-bit compilations, the compiler align data objects on 
16-bit word boundaries. This improves the execution speed of code 
running on CPUs with a 16-bit data bus (like the 80286). The default 
alignment for 32-bit compilations is on 32-bit boundaries. 
The default alignment of structure members depends on the memory 
model used for the compilation. Change the alignment 
within structures via the -a compiler option (see the section "-a 
Specify structure alignment" later in this chapter), so that structure 
members are aligned on different boundaries. This option is useful 
for defining a struct that maps onto a hardware device or a 
predefined data element. 
<p>

You can control alignment only within structures; the compiler still 
aligns all other data objects on word or dword boundaries. 
<p>

Struct member alignment can also be specified with the #pragma pack 
preprocessor directive. Refer to Chapter 3, "Digital Mars C++ Language 
Implementation" for more information. 
<p>

The C++ compiler does not generate structs with a size of 0 bytes if 
there are no nonstatic data members; the minimum size of a struct is 
1 byte. This prevents new() from returning 0 when it tries to allocate 
an instance of a struct. 
<p>

<b>Warning:</b>
	Each file referencing a structure must be compiled 
	with the same type of alignment. If two files 
	compiled with different alignment reference the 
	same structure, any erroneous results could be hard 
	to debug. 

<ul>
	<b>-a</b> Specify structure member alignment 
</ul>
	You can set this option from the IDDE in the Compiler 
	subpage on the Build page of the IDDE's Project Settings dialog 
	box. 

<a name="debugging">
<h2>Compiling for debugging</h2>
</a>

Programs compiled with Digital Mars C and C++ can be debugged 
using many third-party debuggers, as well as the Digital Mars C and 
C++ debuggers. 
<p>

There are two basic types of debugger that can be used with 
Digital Mars C and C++ programs: fully symbolic debuggers (those that 
work with symbolic information, like the Digital Mars debuggers or 
Microsoft Corporation's CodeView), and partially symbolic 
debuggers (those that require only source code line numbers and 
map file information, such as Microsoft's Symdeb). 
<p>

<h3>Compatibility with third-party C debuggers</h3>

Fully symbolic debuggers that are compatible with the data format 
used by Microsoft CodeView should give acceptable results when 
used to debug C programs compiled with Digital Mars C++, provided 
they can handle both C and Pascal function calling conventions. 
Some information on local variables may not be available due to the 
automatic register assignments carried out by Digital Mars compilers. 
(Digital Mars C and C++ make intelligent use of registers within 
functions, automatically assigning frequently used variables to 
registers. This register assignment uses any available register and not 
simply SI and DI.) Some debuggers cannot handle variables in 
registers other than SI and DI and consequently cannot display or 
track them. 
<p>

The Digital Mars C and C++ debuggers can display, modify, and track 
all the local variables within a function. 


<h3>Compatibility with third-party C++ debuggers</h3>

Although some other third-party C 
debuggers can partially debug C++ programs, they cannot obtain or 
handle all the information needed to fully debug C++ code. The 
main difficulties are these: 

<ul>
	<li> C++ function names are displayed by the debugger in 
	their mangled form, as used internally by the compiler. 

	<li> Expanding a derived class shows only those variables 
	added in the derived class. Base-class variables cannot be 
	seen. 

	<li> Pointers to a base class always are shown as such, even if 
	they really point to a derived class. 

	<li> Inline functions can cause some debuggers severe 
	problems and must be avoided. 

	<li> C debuggers have no facilities for examining class 
	definitions or hierarchies. 
</ul>

To fully overcome these problems, use a C++ debugger. 
The Digital Mars C++ debugger provides full debugging facilities for 
C++ programmers. It lets class definitions be fully expanded, C++ 
scope rules be understood, pointer conversions be done 
automatically, overloaded operators be presented correctly, and 
function prototypes be examined. 


<h3>Overview of compiler debugging options</h3>

If the compiler always generates full debugging information for all 
variables, then the object files would be very large, and the linker would 
have to remove a great deal of redundant information. You can 
control the level of debugging information the compiler provides 
with the -g option (see the section "-g Generate debugging 
information" later in this chapter). The compiler can produce five 
levels of debugging information: 

<ul>
	<li> Full symbolic debugging and line number information 
	(-g option) for all variables used in a module. Programs 
	can be debugged at the source level with full debugging 
	information. 

	<li> Symbolic information only (-gs option). This provides all 
	the symbolic information but does not generate any line 
	number information. This level conserves space and 
	allows the debugger to work on larger programs but 
	prevents debugging at the source level; programs must be 
	debugged at the object code level. 

	<li> Symbolic information for global structs and typedefs, 
	whether they are referenced or not, as well as for all 
	variables referenced (-gh option). 

	<li> Symbolic information for each class that the generated 
	code references, as well as for all variables referenced. 
	(-gf option). 

	<li> Line numbers only (-gl option). This option is mainly for 
	use with partially symbolic debuggers. It emits no 
	symbolic information, except what is normally placed in 
	the linker map file. This level provides full line number 
	information. This allows debugging at the source code 
	level, but only global symbols are available; local and 
	static symbols cannot be observed. 
</ul>


Compiling with any level of debugging information significantly 
increases the size of the object file. The size of the executable file 
also increases, often doubling. 
<p>

<h3>Debugging options</h3>

<ul>
	<b>-C</b>  Prevent inline expansion of C++ functions <p>

	<b>-g</b>  Generate debug info for types of referenced variables <p>

	<b>-g4</b>   Generate Codeview 4 format debug info. This is the default. <p>

	<b>-gf</b>  Generate debug info for full class hierarchy for any referenced
	classes. <p>

	<b>-gg</b> Make static functions global <p>

	<b>-gh</b>  Generate debug info for all global structs and typedefs <p>

	<b>-gl</b>  Generate line number info only <p>

	<b>-gp</b>  Generate pointer validation code <p>

	<b>-gs</b>  Generate symbol info only (do not generate line number info) <p>

	<b>-gt</b>  Generate prolog/epilog for use with the dynamic profiler.

	<b>-S</b>  Always generate stack frame <p>
</ul>

<h3>Linking for debugging</h3>

When compiling for debugging, the compiler automatically passes 
the correct information to the linker. If you use a separate link step, 
you need to pass the appropriate options to the linker yourself. 
<p>

These are the options for Digital Mars OPTLINK or Microsoft 
LINK for all levels of debugging information: 

<ul>
	<li> <b>/m</b> (create map file) 
	<li> <b>/co</b> (link for CodeView) 
	<li> To use Microsoft LINK, specify the <b>-L</b><i>linker</i> compiler 
	option. <i>linker</i> is which linker to run.
	Only Microsoft LINK 5.1 or later versions correctly 
	handle the symbolic information. 
</ul>

<b>Note:</b> 
	When creating debugging information, OPTLINK 
	uses CodeView Version 4 format if any object 
	module in the link step contains CV4 records. In this 
	case, it throws away any CV3 records it encounters. 
	OPTLINK creates an executable with CV3 
	debugging format only if every debug record is in 
	CV3 format. To retain CV3 records in objects, run 
	OPTLINK with the /CO:3 or /NOCVPACK options, 
	and then run Microsoft's CVPACK. 
<p>

See the
<a href="../ugr/ugr.html" title="IDDE Reference" target="_top">User's Guide and Reference</a>
for more information on using the Digital Mars debuggers. 


<h3>Notes on debugging with CodeView</h3>

Unlike the Digital Mars C++ debugger, which is statement oriented, the 
Microsoft CodeView debugger is a line oriented source debugger. At 
the source code level, the smallest unit of code CodeView can 
handle is a line, not a statement. To use CodeView most effectively 
with Digital Mars C++, follow these rules: 

<ul>
	<li> CodeView cannot handle inline functions. 

	<li> Make each statement in the source code occupy a 
	separate line. Also, CodeView does not break down 
	complex macros, so if you suspect a macro of containing 
	a bug, write the macro as a regular source statement. 

	<li> Compile source modules with the -g option and link with 
	the /co (CodeView) and /noi (do-not-ignore case) 
	options. 

	<li> An apparent limitation causes CodeView for Windows to 
	halt unexpectedly if you attempt to debug executables 
	that contain large tables, such as applications built with 
	MFC and compiled with Digital Mars C++. One workaround 
	is to find the table that exceeds the maximum size, 
	rebuild the objects that contribute to it without debugging 
	information, and then re-link. Or, relink the with 
	OPTLINK using the /NODEBUG and /DEBUG options (no 
	need to recompile). 
</ul>

Refer to Microsoft's documentation for information on CodeView. 

<h3>Debugging aids in the run-time library</h3>

There are a number of features in the run-time library that help 
detect common run-time errors: 

<ul>
	<li> If a NULL pointer is passed to printf where a pointer to 
	a string is expected, printf uses the string "null" 
	instead. For example: 

<pre class="ccode">printf("String '%s'\n", NULL); 
</pre>

	prints: 

<pre class="console">String '(null)' 
</pre>

	<li> If a NULL near pointer is de-referenced, the string that is 
	at location 0 in the data segment is "ERROR: NULL 
	pointer." For example: 

<pre class="ccode">char buf[100];
strcpy(buf, NULL); 
printf("String '%s'\n", buf); 
</pre>

	prints (for code compiled with the Tiny, Small, and 
	Medium models): 

<pre class="console">String 'ERROR: NULL pointer' 
</pre>
</ul>

If you optimize the code being debugged, remember that 
optimization moves variables and sections of code and creates only 
one scope per function. Avoid using the same variable names in 
nested scopes. 


<h3>Specifying linker and assembler options</h3>

The compiler options described below let you run third party linkers 
and assemblers on the SC command line, or pass options to the 
linker or assembler. 

<ul>
	<b>-L</b>  Using non-Digital Mars linker. <p>

	<b>-L</b><i>linker</i>  Use linker <i>linker</i> instead of OPTLINK. <p>

	<b>-L/</b><i>switch</i>  Pass <b>/</b><i>switch</i> to linker. <p>

	<b>-M</b><i>asm</i>   Use assembler <i>asm</i> instead of MASM. <p>

	<b>-M/</b><i>switch</i>  Pass <b>/</b><i>switch</i> to assembler. <p>
</ul>

<h3>Controlling segmentation</h3>

When writing large 16 bit Windows programs, you sometimes need to 
place functions that frequently call each other into the same 
segment. This optimization helps speed execution. This section 
explains how to segment your code. Use these methods 
independently or in any combination. 

<ul>
	<li> Use the -NTcsname compiler option, which sets the 
	code segment for a file to be csname. 

	<li> Use the -NS compiler option, which creates a new code 
	segment each time the compiler encounters a global far 
	function. The name of the segment is the name of the 
	function, with _TEXT appended. 

	<li> For Compact and Large model compilations, use the -GT 
	compiler option, which places arrays larger than a 
	specified number of bytes in far data segments instead of 
	DGROUP. 

	<li> Use the #pragma: 
<pre class="ccode">#pragma SC cseg csname 
</pre>
	which places what follows in the segment csname. The 
	-NS option overrides the #pragma for global far 
	functions. 
</ul>

<h3>Preventing data segment overflow</h3>

Many large programs run out of space in the default data segment 
DGROUP. The solution is to move some data out of DGROUP into 
other segments. Here are some methods you can use: 

<ul>
	<li> Compile with the -R option, which causes switch 
	statement tables to be placed in the code segment rather 
	than in DGROUP. 

	<li> Declare literal strings you want to place in the code 
	segment with the type modifier __cs. 

	<li> Compile with the -Ns option, which places strings that 
	are part of expressions into the code segment rather than 
	in DGROUP. 

	<li> Declare statically allocated data as far; for example: 
	int __far array[100]; 
</ul>


For information on declaring data as far and placing data in the code 
segment, see Chapter 7, "Choosing a Memory Model." 
<p>

Data declared as far should be data that is relatively large and is 
accessed relatively infrequently, as more overhead is required to 
access those data. 
<p>

If another module should reference far static data, declare it as far, as 
in: 
<pre class="ccode">extern int __far array[]; 
</pre>
Otherwise, the compiler assumes that the data is in the default data 
segment DGROUP. Digital Mars C++ differs from some other compilers 
in this respect— extern data is not assumed to be in DGROUP. 
Although our implementation involves more work on the program-
mer's part (putting __far in the right places), the control this offers 
makes it very worthwhile for high-performance applications. Also, 
most applications need less than 64KB of static data, and so need not 
pay a penalty for assuming that extern data is not accessible via 
DS. 


<h3>Virtual function tables (vtbls)</h3>

The compiler generates a table of pointers to functions for each class 
that has virtual functions or is derived from a class with virtual 
functions. In the small data models (Tiny, Small, and Medium), it 
creates these tables in DGROUP by default. For the Compact and 
Large data models, it writes these tables to the code segment by 
default. 
<p>

To further minimize use of code space in Compact and Large model 
programs, place vtbls in far data segments with -NV. 


<h3>Segmentation options</h3>

Use the options described below to control how the compiler 
segments your program. 

<ul>
	<b>-NS</b> Create new code segments for far functions <p>

	<b>-Ns</b> Put strings in expressions into code segment <p>

	<b>-NT</b><i>name</i>  Set code segment name to <i>name</i>.<p>

	<b>-NV</b> Put virtual function tables in far data segments.<p>

	<b>-R</b> Put switch tables in code segment<p>

	<b>-GT</b><i>nnnn</i> Put large arrays in far data segments.<p>
</ul>


<h3>Code generation options</h3>

The options described below control how the compiler generates 
code. 

<ul>
	<b>-0, -2, -3, -4, -5, -6</b> Specify CPU instruction set <p>

	<b>-c</b>  Compile only, do not link executable. <p>

	<b>-C</b>  Disable inline function expansion. <p>

	<b>-D</b>[<i>macro</i>[=<i>text</i>]]  Define macro <p>

	<b>-Nc</b> Perform function level linking <p>

	<b>-NF</b> ignore extended keywords <p>

	<b>-NL</b> Do not embed default library record <p>

	<b>-o</b>  Optimize code for speed <p>

	<b>-o+space</b>  Optimize code for space <p>

	<b>-P</b>  Default to pascal linkage <p>
</ul>

<h3>Compiling for Windows</h3>

    See <a href="windowspe.html">Windows Prolog/Epilog Code Generation</a>.

<h3>Templates</h3>

<ul>
	<b>-XI</b><i>spec</i>  Create instance of template <p>

	<b>-XD</b>  instantiate template for any functions declared but not defined <p>

	<b>-XN</b>  no template function instantiation <p>
</ul>


<a name="internationalization">
<h3>Internationalization Options</h3>
</a>

<ul>
	<b>-j[0|1|2]</b> Recognize multibyte Asian language characters in the source
</ul>


<br><br><br><br>

</td></table>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

