
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - DOS 32 Programming Guidelines</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:25:46 2006
</div>
</div>

<!-- Generated by Ddoc from dos32.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ctg">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>
</center>

    <a href="ctg.html"><b>Compiler & Tools Guide</b></a><br>

<hr><b>Compiling</b><br>

    &#149; <a href="ctgCompilingCode.html">Compiling Code</a><br>
    &#149; <a href="C-Language-Implementation.html">C Implementation</a><br>
    &#149; <a href="CPP-Language-Implementation.html">C++ Implementation</a><br>
    &#149; <a href="ctgLanguageImplementation.html">Language Extensions</a><br>
    &#149; <a href="ctgMixingLanguages.html">Mixing Languages</a><br>
    &#149; <a href="ctgAsm.html">Assembly Language</a><br>
    &#149; <a href="ctgInlineAsm.html">Inline Assembler</a><br>
    &#149; <a href="ctgOptimizer.html">Optimizing Code</a><br>
    &#149; <a href="ctgNumerics.html">Numerics Programming</a><br>
    &#149; <a href="regular.html">Regular Expressions</a><br>
    &#149; <a href="acrtused.html">Acrtused</a><br>
    &#149; <a href="pragmas.html">Pragmas</a><br>
    &#149; <a href="precompiled.html">Precompiled Headers</a><br>
    &#149; <a href="predefined.html">Predefined Macros</a><br>
    &#149; <a href="warnings.html">Warning Messages</a><br>
    &#149; <a href="ctgCompilerErrors.html">Error Messages</a><br>
    &#149; <a href="warnings.html#runtime">Runtime Messages</a><br>
    <br>

<hr><b>Linking</b><br>

    &#149; <a href="optlink.html">Optlink</a><br>
    &#149; <a href="ctgLinkSwitches.html">Switches</a><br>
    &#149; <a href="ctgDefFiles.html">Module Definition Files</a><br>
    &#149; <a href="ctgLinkOps.html">Operation and Design</a><br>
    &#149; <a href="OptlinkErrorMessages.html">Error Messages</a><br>
    <br>

<hr><b>Win32 Programming</b><br>

    &#149; <a href="win32programming.html#win32">Win32 Programming</a><br>
    <br>

<hr><b>DOS and Win16<br>Programming</b><br>

    &#149; <a href="ctgMemoryModel.html">Memory Models</a><br>
    &#149; <a href="pointers16.html">16 Bit Pointer Types<br> and Type Modifiers</a><br>
    &#149; <a href="win32programming.html#handle">Handle Pointers</a><br>
    &#149; <a href="win32programming.html#dos">DOS</a><br>
    &#149; <a href="dos32.html">DOS 32 (DOSX)</a><br>
    &#149; <a href="win32programming.html#win16">Win16</a><br>
    &#149; <a href="win32programming.html#win16dll">Win16 DLLs</a><br>
    &#149; <a href="windowspe.html">Win16 Prolog/Epilog</a><br>
    <br>

<hr><b>C/C++ Extensions</b><br>

    &#149; <a href="contract.html">Contract Programming</a><br>
    &#149; <a href="debugstatement.html">__debug statement</a><br>
    &#149; <a href="debugstatement.html#debugdeclaration">__debug declaration</a><br>
    &#149; <a href="trace.html">Dynamic Profiling</a><br>
    &#149; <a href="html.html">Embedding C in HTML</a><br>
    <br>

<hr><b>Tools</b><br>

    &#149; <a href="bcc.html" title="Convert Borland compiler commands">BCC</a><br>
    &#149; <a href="chmod.html" title="Examine and change file attributes">CHMOD</a><br>
    &#149; <a href="cl.html" title="Convert Microsoft compiler commands">CL</a><br>
    &#149; <a href="coff2omf.html" title="Convert COFF .obj and .lib to OMF">COFF2OMF</a><br>
    &#149; <a href="coffimplib.html" title="Convert COFF import library OMF">COFFIMPLIB</a><br>
    &#149; <a href="sc.html" title="Compiler command">DMC</a><br>
    &#149; <a href="diff.html" title="Compare files">DIFF</a><br>
    &#149; <a href="diffdir.html" title="Compare directories">DIFFDIR</a><br>
    &#149; <a href="dump.html" title="Dump files in hex">DUMP</a><br>
    &#149; <a href="dumpobj.html" title="Dump object files in hex">DUMPOBJ</a><br>
    &#149; <a href="dumpexe.html" title="Dump exe files">DUMPEXE</a><br>
    &#149; <a href="exe2bin.html" title="Create .com files">EXE2BIN</a><br>
    &#149; <a href="flpyimg.html" title="Read/Write Floppy Image">FLPYIMG</a><br>
    &#149; <a href="grep.html" title="Search files for string">GREP</a><br>
    &#149; <a href="ctgHelp.html" title="Creating Help Tools">HC</a><br>
    &#149; <a href="implib.html" title="Build import libraries">IMPLIB</a><br>
    &#149; <a href="lib.html" title="Object file librarian">LIB</a><br>
    &#149; <a href="libunres.html" title="Analyze library and object files">LIBUNRES</a><br>
    &#149; <a href="make.html" title="Simple make utility">MAKE</a><br>
    &#149; <a href="makedep.html" title="Update makefile dependencies">MAKEDEP</a><br>
    &#149; <a href="me.html" title="MicroEmacs Text Editor">ME</a><br>
    &#149; <a href="obj2asm.html" title="Object file disassembler">OBJ2ASM</a><br>
    &#149; <a href="patchobj.html" title="Patch object files">PATCHOBJ</a><br>
    &#149; <a href="ctgRC.html" title="Microsoft Resource compiler">RC</a><br>
    &#149; <a href="rcc.html" title="Digital Mars Resource compiler">RCC</a><br>
    &#149; <a href="sc.html" title="Compiler command">SC</a><br>
    &#149; <a href="shell.html" title="Shell scripts">SHELL</a><br>
    &#149; <a href="smake.html" title="Manage complex projects">SMAKE</a><br>
    &#149; <a href="touch.html" title="Set file timestamps">TOUCH</a><br>
    &#149; <a href="unmangle.html" title="Format C++ mangled names">UNMANGLE</a><br>
    &#149; <a href="whereis.html" title="Search for files">WHEREIS</a><br>
    <br>

<hr><b>Porting to DMC++</b><br>

    &#149; <a href="switchtodigitalmars.html">Switching to DMC++</a><br>
    &#149; <a href="switchtodigitalmars.html#microsoft">from Microsoft</a><br>
    &#149; <a href="switchtodigitalmars.html#borland">from Borland</a><br>
    &#149; <a href="ctgPorting.html">Porting Guide</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>DOS 32 (DOSX) Programming Guidelines</h1>

	32-bit protected-mode DOS programs with a linear address space of 4
	gigabytes (4GB) can be created by compiling with either of two memory
	models.
	Programs compiled with these memory models can run on any IBM 
	PS/2 or PC/AT computers or compatibles with an 80386, 80486, 
	Pentium or later x86 CPU and can take advantage of all the features
	of the 32 bit 80386 architecture. 
	<p>

	For more information on the 32-bit protected mode 
	memory models,
	see <a href="ctgMemoryModel.html">Choosing a Memory Model</a>. 


<ul>
	<li> <a href="#compatibility">DOS extender compatibility and requirements</a>
	<li> <a href="#building">Building and running DOSX programs</a>
	<li> <a href="#protection">Memory protection mechanisms</a>
	<li> <a href="#differences">Differences between 32-bit and 16-bit DOS programs</a>
	<li> <a href="#vram">Accessing video ram in DOSX</a>
	<li> <a href="#realmode">Interfacing to real mode functions</a>
	<li> <a href="#realtoprotected">Accessing real mode memory from protected mode</a>
	<li> <a href="#firstmeg">Accessing the first megabyte of memory</a>
	<li> <a href="#intreal">Calling a real mode interrupt not implemented by DOSX</a>
	<li> <a href="#realbuffer">Passing a buffer to a real mode interrupt</a>
	<li> <a href="#protectedpointers">Using protected mode pointers</a>
	<li> <a href="#memorymappedio">Accessing memory mapped i/o devices</a>
	<li> <a href="#samplepointers">Sample code to manipulate pointers</a>
	<li> <a href="#dual">Dual mode DOSX/Win32 programs</a>
	<li> <a href="#pharlap">DOSX compatibility with Phar Lap</a>
	<li> <a href="#nasm">Using NASM built .obj files with DOSX</a>
</ul>

<!-- ======================================================= -->
<hr><a name="compatibility"><h2>DOS Extender Compatibility and Requirements</h2></a>

	Use either of these DOS extenders: 

<ul>
	<li> The X32VM DOS Extender, which is a free download
	from <a href="http://www.dosextender.com">here</a>.
	To use it, compile with the DOSX memory 
	model (<b>-mx</b>) and link with the OPTLINK linker. 

	<li> The Phar Lap 386|DOS Extender, which is available 
	separately from Phar Lap. To use it, compile with the Phar 
	Lap 386 memory model (<b>-mp</b>) and link with the Phar Lap 
	linker (OPTLINK does not support linking Phar 
	Lap programs). Contact Phar Lap for licensing 
	information. 
</ul>

	<b>Note:</b> 
	Digital Mars C++ no longer supports the <b>-mz</b> memory 
	model for the ZPM 32-bit DOS extender. 


<h3>Hardware requirements</h3>

	Programs compiled with the DOSX 386 or Phar Lap 386 memory 
	models run only on computers with an 80386, 80486, or Pentium 
	CPU. 
	<p>

	Hardware-sensitive items that can affect DOSX programs include the 
	enabling hardware for the A20 line and 8259 interrupt controllers. If 
	these are compatible with either their PC/AT or IBM PS/2 
	counterparts, they should not affect DOSX applications. 
	<p>

	If the A20 enabling hardware is not PC/AT compatible or IBM PS/2 
	compatible, an XMS extended memory manager (XMM) compatible 
	with that computer may be required. (An extended memory manager 
	is a program installed at boot time by inserting the appropriate line 
	in the config.sys file.) If this is the case, the program will exit 
	with the error message: 

<pre>
	Cannot enable the A20 line, XMS memory manager required 
</pre>


	The vast majority of 80386 equipped personal computers can run
	DOSX programs without the need for extended memory manager
	software.
	<p>

	Extended memory is not required to run DOSX 386 programs. If
	extended memory is available, however, it will be added to the
	heap/stack space. This means that DOSX 386 programs will run on
	80386 computers that have no extended memory if there is sufficient
	conventional memory available.
	<p>

	The DOSX 386 memory model will not operate on computers
	equipped with a 16 bit processor 80286 or 8088.
	If the startup code detects any 16 bit
	processor older than a 80386, it will exit with the error
	message:

<pre>
	Fatal error, 80386 in real mode is required 
</pre>

<h3>Software requirements</h3>

	DOSX programs are compatible with IBM's vdisk.sys, Microsoft's 
	ramdrive.sys, smartdrv.sys, himem.sys and other drivers 
	that may or may not use extended memory. The DOSX extender is 
	known to be compatible with these drivers: 

<ul>
	<li> Microsoft himem.sys 
	<li> Microsoft ramdrive.sys 
	<li> Microsoft smartdrv.sys 
	<li> Microsoft Windows Version 3.0 and 3.1 in Standard mode, 
	Real mode, and Enhanced 386 mode 
	<li> Qualitas 386^MAX Version 5.0 and later (not compatible 
	with earlier versions) 
	<li>IBM vdisk.sys 
	<li> Quarterdeck's QEMM memory manager 
</ul>

	<b>Note:</b> 
	Some extended memory managers, such as 
	himem.sys, are not compatible with vdisk.sys. 
	Installing both of those programs simultaneously 
	results in no extended memory being available for 
	other application programs, regardless of the 
	amount of extended memory that is not actually 
	being used. 
	<p>

	When it starts up, a DOSX program allocates all the extended and 
	conventional memory it needs. If there is an XMM available, the 
	program uses it to allocate the extended memory and enable the A20 
	line. If there is no XMM, the program allocates the memory and 
	enables the A20 line itself. 
	<p>

	DOSX programs contain code to protect driver buffers in extended 
	memory so that invalid pointers cannot write over them. You can 
	access memory allocated to an extended memory RAM disk only by 
	calling the RAM disk code. 
	<p>

	The DOSX memory model is not compatible with drivers that leave 
	the processor in V86 mode unless the driver is VCPI compatible, like 
	Qualitas 386^MAX version 5.0 and higher, or DPMI compatible, like 
	Microsoft Windows 3.0 and higher. If a DOSX program determines 
	that the processor is in V86 mode and the software that switched it 
	to that state is neither VCPI nor DPMI compatible, the DOSX 
	program exits with the message: 

<pre>
	Fatal error, 80386 in real mode is required 
</pre>

<h3>DOSX memory limitations</h3>

	DOSX has the following memory limits: 

<ul>
	<li> With no memory managers at all: 64MB. This is because 
	the BIOS function call INT 15 function 0x88 returns the 
	number of kilobytes of extended memory in register AX, 
	which can hold a value no bigger than 65,535. Thus, the 
	maximum amount of memory the BIOS can indicate is 
	64MB. 

	<li> With XMS compatible devices like Microsoft's 
	himem.sys: 64MB. This is due to limitations in the XMS 
	interface. 

	<li> With a VCPI host, memory is limited only by the host. 

	<li> Under DPMI hosts, DOSX allocates only 3/4 of available 
	memory, to allow the host to run other applications 
	simultaneously. The DPMI interface specification supports 
	up to 4GB, so DOSX can allocate up to 3GB. 
</ul>

	<b>Note:</b> 
	If less than 1Mb of extended memory is available, 
	Windows 3.0 in 386 enhanced mode does not 
	reliably run protected mode programs except from 
	the DOS prompt. In this instance you need to add 
	memory or upgrade to Windows 3.1. 

<!-- ======================================================= -->
<hr><a name="building"><h2>Building and running DOSX programs</h2></a>

<h3>Building a DOSX Executable</h3>

	To compile and link a DOSX program, perform the following steps: 

<ul>
	<li> Compile with the DOSX memory model (-mx). 

	<li> The predefined macro _DOS386 is defined for DOSX 
	compilations; add #ifdef directives to code where 
	necessary. See the source code in ..\src\core for 
	examples of how to do this. 

	<li> The compiler can call the linker, as in this 
	example:

<pre>
	sc -mx test1.obj test2.obj -otest.exe 
</pre>

	To perform the link step manually, link the 
	DOSX startup code in cx.obj. You must link with 
	OPTLINK. For example: 

<pre>
	optlink \dm\lib\cx+test1+test2,tmp; 
</pre>

	<li> The only library for DOSX is sdx.lib. x386.lib is part 
	of sdx.lib, and is included in source form for 
	rebuilding sdx.lib. 
</ul>

<h3>Running a DOSX Program</h3>

	DOSX allows use of all the features of the 80386. In 
	particular: 

<ul>
	<li> Extended memory is used as conventional memory, in a 
	manner that is transparent to the programmer. 

	<li> Arrays are limited only by available memory size. 

	<li> Integers are 32-bit values, the native data size for 80386 
	processors. 

	<li> Code runs faster. 

	<li> All pointers, calls, and jumps are near. 

	<li> The 80386 detects errors and exits with a diagnostic rather 
	than crashing. 
</ul>

	DOSX programs have a simple, built-in interface to DOS. All I/ O, 
	such as printf(), write(), and getchar() calls, use the built-in 
	DOS interface code transparently. 
	<p>

	To the user, a DOSX program looks like a typical executable. It 
	requires no special loaders or device drivers because everything it 
	needs to run is contained within it. A DOSX program is only about 
	10KB larger than if it had used the Large memory model. 
	<p>

	When it runs, a DOSX program places the processor in protected 
	mode, allocates all available extended and conventional memory, 
	and executes all instructions in protected mode. It returns to real 
	mode only when it needs to interface with real mode code such as 
	DOS, or hardware interrupt handlers. 


<h3>Managing memory</h3>

	When a DOSX program starts up, it checks for extended memory 
	management software in this order: 

	<ol>
	<li> DPMI hosts, such as Windows 3.0 and higher 
	<li> VCPI hosts, such as Qualitas 386^MAX version 5.0 and 
	higher 
	<li> XMS compatible devices, such as himem.sys 
	<li> The BIOS function call INT 15 function 0x88 
	</ol>

	A DOSX program uses the first device it finds to allocate all the 
	extended memory and enable the A20 line. If it cannot find any of 
	the above devices, it looks for any driver that uses extended 
	memory, such as ramdrive.sys, smartdrv.sys, or 
	vdisk.sys. It allocates all unused extended memory. 
	<p>

	If you are using extended memory software that isn't a DPMI host, 
	the program also allocates all the unused memory and combines it 
	with the extended memory in an area called the X memory space. 
	Your program treats this block of memory as a large, single, 
	continuous block. The extended memory that drivers have allocated 
	is not part of this block, so errant pointers cannot overwrite it. The 
	first megabyte of memory, including the video display buffer, is also 
	not part of this block, and you can access it as you would in any 
	other memory model. 
	<p>

	Your program loads its code and static data into the bottom of the X 
	memory space. The heap grows up from the top of static data 
	towards the stack, and stack grows down from the top of the X 
	memory space towards the heap. 

<pre>
Figure 20-1 X memory space 

	Stack
	  I
	  V
	Unused
	  ^
	  I
	Heap
	Static data
	Code
</pre>

	The stack can grow until it reaches the first 4KB boundary above 
	the top of the heap. If the stack tries to grow beyond that, the 
	program is aborted. 
	<p>

	The default minimum size for a DOSX program's stack is 4096 bytes. 
	Change the minimum stack size with the =<i>nnnn</i> command 
	option, or with the <tt>_stack</tt> global variable:

<pre>
	unsigned int _stack = nnnn; 
</pre>

	This number is rounded up to the nearest 4KB boundary. DOSX
	uses this number to prevent the heap from growing into the 
	stack. Memory allocation functions such as malloc() and 
	calloc() fail when the heap has grown to the largest size possible 
	given the current minimum stack size. 


<h3>Running on DPMI hosts in 386 enhanced mode</h3>

	To handle interrupts such as 0x08 to 0x0F, 0x70 to 
	0x77, 0x1B, 0x1C, 0x23, or 0x24, or use the msm_signal function, 
	all code, data, and stack that the interrupt handler might access must 
	be locked. This prevents the interrupt handler from being swapped 
	out to disk. You can lock the necessary memory with the function 
	__x386_memlock. Use __x386_memunlock to unlock memory. 
	These functions can be called even if the program is not running 
	under DPMI, in which case they will always return success. You also 
	need to lock the code, data, and stack segments when using the 
	functions cerror_open and cerror_close. 


<!-- ======================================================= -->
<hr><a name="protection"><h2>Memory protection mechanisms</h2></a>

The X memory model uses the 80386 protection mechanisms to 
check for invalid pointers, detect stack overflow, and protect code 
from overwrites. 
<p>

When you link a program for the DOSX memory model, OPTLINK 
adds code to your program to handle all interrupts except hardware 
interrupts. When the processor detects a fault, it issues an interrupt. 
The DOSX code then prints out diagnostic information and 
terminates the program. For example, if you use a null pointer, the 
output might be: 


<pre>
	INTERRUPT 0DH, GENERAL PROTECTION FAULT
	possible illegal address 

	error code = 0000 

	cs = 002B	eip = 00000E6A
	ss = 003B	esp = 000B6FF0 
	ds = 0033	ebp = 000B6FFC
	es = 0033	eax = 00000000 
	fs = 0000	ebx = 0000FF00
	gs = 0000	ecx = 00000000 
	eflags = 00013246 edx = 00002B74
			esi = 000000D4 
			edi = 00002E55 
	absolute start address of DGROUP 10000000
	available conventional memory 00025000 to 0009D000
	available extended memory 001C0000 to 00200000 
	X memory space located at 10000000 to 100B7000 
</pre>


To execute an interrupt, return to real mode by calling 
int86() or int86x() before executing the interrupt. 


<!-- ======================================================= -->
<hr><a name="differences"><h2>Differences between 32-bit and 16-bit DOS programs</h2></a>

When you use a 32-bit memory model, there are no far calls or far 
pointers. Pointers contain only a 32-bit offset. Arrays are limited by 
the amount of available memory, up to 4GB. The amount of data 
that functions like read() and write() can transfer is limited by 
the amount of available disk space, up to 4GB. 


<h3>Differences affecting library functions</h3>

These standard library functions behave differently in 32-bit memory 
models. For more information see the function's description in the 
Run-Time Library Reference. 

<pre>
	bdos() bdosx() _chkstack() 
	getDS() int86() int86x() 
	intdos() intdosx() peek() 
	poke() segread() write() 
</pre>

<h3>Standard library functions not supported with DOSX</h3>

You cannot use the following functions in programs compiled with 
the DOSX memory model: 

<pre>
	bios_disk() dos_abs_disk_read() 
	dos_abs_disk_write() farmalloc() 
	farcalloc() farcoreleft() 
	farfree() farrealloc() 
</pre>

<h3>Special functions for the DOSX memory model</h3>

There are a number of special functions provided for use with the 
DOSX memory model. For more information see the function 
descriptions in the Run-Time Library Reference. 



<!-- ======================================================= -->

<hr><a name="vram"><h2>Accessing video ram in DOSX</h2></a>

	There are numerous ways to do it, either by using
	library functions or by creating a special 32-bit
	protected mode pointer:

<ul>
	<li> The easiest way to write code to directly access video ram
	for DOS, DESQView, DOSX and Win32 is to use the
	<a href="../rtl/disp.html">disp</a> package.
	Of course, this method has the advantage of being maximally portable.
	<p>

	<li> Use a selector with an appropriate base address.
	<p>
	The sample code below allocates a new selector with a base address 
	that points to 0x0B8000, which is in the video buffer for a color 
	monitor. This calls a function that returns a far pointer in 
	DX: EAX. If the selector is allocated successfully, the offset in 
	EAX will be zero. If not, EAX will hold the requested address and DX 
	will hold a base address of absolute zero (equivalent to 
	_x386_zero_base_selector in the next example). Note that all 
	the code fragments in this section are part of the same program. The 
	following example defines the variables used in the other examples 
	as well: 

<pre>
	include macros.asm
	begdata 
	extrn _x386_zero_base_selector: word, _disp_base:word 
	enddata 

	begcode
	extrn _x386_mk_protected_ptr:dword, 
		_x386_get_abs_address,dword
	extrn _disp_open:near 

	public _main
	_main proc near 
	    push 0b8000h
	     call _x386_mk_protected_ptr 
		; returns pointer in DX: EAX 
	    mov es,dx	; should reference a video selector
	     mov byte ptr es:[0],'X' 
		; places an X on the screen 
</pre>



	<li> Use a selector with a base address of absolute zero. 
	<p>

	This sample code writes to the screen using a selector 
	with an address of absolute zero. This selector is stored in a global 
	variable and is available for applications to use as required: 

<pre>
	mov es,_x386_zero_base_selector	; load the selector 
	mov byte ptr es:[0b8002h],'Y'	; places a Y on the screen 
</pre>


	<li> Use near pointers based on the selector in DS. 
	<p>

	The next block of sample code writes to the screen using near 
	pointers based on the default selector normally found in DS. Your 
	code must first call the function _x386_get_abs_address to 
	determine the base address of DS (DGROUP). Since this value is 
	always greater than 1MB, you need to use a negative offset to access 
	the video buffer. The segment limits DOSX sets on DS allow the use 
	of negative offsets, as illustrated by the following: 

<pre>
	push ds		; push far pointer ds:0
	push 0		; returns address in EAX 
	call _x386_get_abs_address ;returns address in EAX 

	neg eax		; DS:EAX now points to zero
	mov byte ptr ds:[eax+0b8004H],'Z' 
			; places a Z on the screen 
</pre>


	<li> Use the _disp_open library function to identify the 
	video card and create a selector that points to the video 
	buffer. 

	This code fragment calls the _disp_open run-time library 
	function (from the Display package) to identify the video card and 
	create a selector that points to the video buffer. When you use this 
	method to access video memory, you should inspect the value in 
	_disp_open to make sure it is non-zero. If _disp_open fails to 
	identify the video card and uses the BIOS to access the video buffer, 
	_disp_base will equal zero. 

<pre>
	call _disp_open	; initialize _disp_base
	mov  es,_disp_base 
	mov byte ptr es:[6],'T'	; places a 'T' on the screen 

	mov ah,4ch
	int 21h		; terminates sample program 
	_main endp
	endcode 
	end 
</pre>


	<li> Use _x386_zero_base_ptr that is declared in dos.h as


<pre>
	void *_x386_zero_base_ptr;
</pre>

	You now can build a 32 bit absolute address by adding a 32bit offset to 
	this pointer:

<pre>
	char *ScreenAtA000 = (char*)_x386_zero_base_ptr + 0xA0000;
</pre>

	Note that you don't use segment:offset in this case but a linear memory 
	address.
	<p>

	<small>(Thanks to Heinz Saathof)</small>
	<p>
</ul>

<!-- ======================================================= -->
<hr><a name="realmode"><h2>Interfacing to real mode functions</h2>

To enclose real mode code, use the begcode_16 and 
endcode_16 macros found in x386mac. asm. Real mode code 
must return with a far return value. To call the real mode procedure: 

<pre>
	mov AX,250eh
	mov EBX,	; seg:offset of real mode procedure 
	mov ECX,	; number of words to copy from
			; protected stack to real mode stack 
	int 21h 
</pre>

ECX must not be greater than 63 (two-byte) words; therefore there is 
a maximum of 126 bytes that can be transferred. Making ECX zero 
will make the call slightly faster and preserve real mode stack space. 
The real mode procedure receives control with a stack of about 300 
bytes in size. The dword return address is immediately placed on the 
stack and any copied parameters are placed above that. All general 
registers are preserved when a protected mode function calls a real 
mode function, as well as when the real mode function returns 
control to the protected mode function. The real mode function 
receives ds = cs; all other segment registers are undefined. Upon 
return to protected mode, all general registers are as they were left 
by the real mode code. Segment registers are as they were prior to 
the int 21h call. The stack will be unchanged even if the real mode 
function changed the values of the parameters on the real mode 
stack; the real mode function cannot return values on the stack. 
<p>

Note that it is difficult to get the real mode segment value, since 
there are no segment fixups in the protected mode code. To get the 
segment value of the real mode code: 


<pre>
	mov ax,2509h	;get system segments and selectors
	int 21h 
</pre>


All general registers will be destroyed and filled with various real 
and protected mode segments and selectors. The value of interest is 
the real mode code segment returned in BX. The following program 
demonstrates the use of a real mode procedure: 

<pre>
	include macros.asm
	include x386mac.asm 

	begcode_16	; define start of real mode
			; code segment 
	real_proc proc far 
	mov EAX,[ESP+4]	; mov first parameter into EAX
	retf 
	real_proc endp 

	endcode_16	;end of real mode code segment 

	begcode
	public _main 
	_main proc near
	push 12345678h	; parameter to send to real 
			; mode code
	mov AX,2509h	; get system segments and 
			; selectors
	int 21h		; get real mode segment in BX 
	rol EBX,16	; put segment in high word of EBX 
	mov BX, offset real_proc	; EBX now = cs:ip
	mov ECX,2	;copy two words or one dword 
	mov AX,250eh
	int 21h		;call real mode procedure 

	; make a GP fault to examine registers:
	push CS 
	pop SS
	; illegal value in SS will terminate program 
	; and dump registers to screen. EAX should
	; equal 12345678h 

	_main endp
	endcode 
	end 
</pre>

While function call 250eh is similar to Pharlap's function 250eh, it is 
not identical; function 2509h as used above is totally different from 
Pharlap's version, and Pharlap function 2510h which allows the 
caller to specify all registers is not supported in DOSX. Other 
relevant Pharlap-like function calls which DOSX supports are as 
follows: 

<pre>
Function Description

2502-2507 Deals with real and protected mode interrupt 
	vectors 
2508 Gets base address of selector 
250c Gets hardware interrupt vectors 
250d Gets real mode data buffer address and real mode 
	call back device address 
2511 Executes interrupt in real mode 
252b Subfunctions 5 and 6; locks and unlocks virtual 
	memory (useful under DPMI) 
</pre>

The real mode data buffer (function 250d) is shared with the DOS 
extender and is overwritten during disk i/ o or screen i/ o, so it should 
only be used for temporary storage. The normal size of this buffer is 
16K bytes, but it may be smaller if there is insufficient conventional 
memory. Keep in mind that real mode libraries will have some 
difficulty accessing protected mode data. 


<!-- ======================================================= -->
<hr><a name="realtoprotected"><h3>Accessing real mode memory from protected mode</h3></a>

The example program which shows how to access real mode 
memory from protected mode. In this example, 45K bytes of static 
data are allocated in the real mode code segment; this is roughly the 
maximum that can be used. 

<pre>
	include macros.asm
	include x386mac.asm 
	comment&amp;
	This program demonstrates how to allocate static 
	real mode memory, and access it both from real
	mode code and 32-bit protected mode code. The 
	function main places the number 12345678h in the
	real mode array "real_data". main then calls the 
	real mode function "real_proc", which retrieves
	that number and returns to protected mode with 
	that number in EAX. main then causes a GP fault
	so that the registers can be examined. 
	&amp;
	begcode_16	; define start of real mode code 
			; segment 

	real_data db 45000 dup (0) ; real mode data 

	real_proc proc far	; procedure to call from
				; protected mode 
	assume DS:__X386_CODESEG_16 ; name of real mode code segment 
	mov EAX, dword ptr DS:real_data[10000] ; mov the dummy data into EAX 
	retf
	real_proc endp 

	endcode_16	; end of real mode code segment 
	begdata		; protected mode data segment
	extrn __x386_zero_base_selector:word 
			; data selector enddata 

	begcode		; protected mode code segment 
	public _main
	_main proc near 
	mov AX,2509h	; get system segments and
			; selectors 
	int 21h		; get real mode segment in BX 

	comment&amp;
	There are no fixups done on 32-bit code, so you 
	cannot use segment names as immediate values;
	you must use function 2509h. This function 
	destroys all registers, filling each 32-bit
	register with two segments or two selectors. 
	&amp; 

	push EBX	; save real mode segment which is in BX 

	mov ES,__x386_zero_base_selector
	; note that the above selector is not hardwired, 
	; but is available through the public variable
	; as shown above. It has a base of 0, 4GB limit 

	movzx EBX,BX	; zero upper word
	shl EBX,4	; convert segment to absolute 
			; address
	assume ES: nothing 
	mov dword ptr ES: real_data[EBX+10000],12345678h
	; above instruction puts dummy data in 
	; real_data[ 10000], the selector in ES
	; points to zero. EBX gives the offset of the 
	; start of the real mode segment. Ensure that ES
	; does not have any "assumes" on it 

	pop EBX	; restore real mode segment in BX
	rol EBX,16 
	mov BX, offset real_proc ; EBX now = cs:ip of
				 ; real_proc 
	xor ECX,ECX		 ; copy zero parameters on stack
	mov AX, 250eh 
	int 21h			; call real_proc 

	; make a general protection fault to examine
	; registers 

	push CS
	pop SS 
	; illegal value in ss will terminate program and
	; dump registers to screen. 
	;eax should have the value 12345678h 

	_main endp
	 endcode 
	end 
</pre>

<!-- ======================================================= -->
<hr><a name="firstmeg"><h3>Accessing the first megabyte of memory</h3></a>

To access any part of the first 1Mb of memory in a DOSX program, 
you need to perform one of these operations: 

<ul>
	<li> Use far pointers 

	<li> Use a "segment wrap" algorithm to access the firs 1Mb 
with near pointers 
</ul>

Both these methods are illustrated in the sample code that follows. 
Which method you choose depends on the situation: for one-time 
access, far pointers would typically be easiest; for multiple accesses, 
near pointers might be best. 

<pre>
	include macros.asm 

	begdata extrn __x386_zero_base_selector:word 
		; data selector for using far pointers
	extrn __x386_get_abs_address:dword 
		; function pointer for using near pointers 

	enddata 

	begcode
	public _main 
	_main proc near 

	comment&amp;
	The far pointer method: A selector is stored in 
	a global variable as shown in the extrn
	definition above. This selector has a base 
	address of zero and a 4 Gb address limit. It is
	primarily useful for addressing the first 1Mb 
	since everything above the first 1Mb is remapped
	with the paging mechanism and thus is not 
	readily usable. This selector can be used to
	access the video buffer as follows: 
	&amp; 

	; place an X in the upper left corner
	; of a color monitor 

	mov ES,__x386_zero_base_selector
	mov byte ptr ES:[ 0b8000h], 'X' 

	comment&amp;
	The segment wrap method: This method is a bit 
	more complex initially, but the use of near
	pointers is a great advantage in some cases. It 
	relies on the fact that the 80386 "wraps" around
	the 4 Gb address just like an 8088 wraps around 
	the 1 mbyte address. The segment limits have been
	set up such that the default DS selector cannot access
	addresses low enough to corrupt the code; however,
	there is no limit on upper 
	addresses other than generating page faults if you
	try to read or write to empty space. To make 
	the segment wrap work, you first have to find the base
	address of DGROUP. This varies 
	depending on whether the system is DPMI or non DPMI.
	The example below determines this at run 
	time so it will work in either situation.
	&amp; 

	push DS
	push 0		; put far pointer to start of DGROUP 
			; on stack
	call dword ptr __x386_get_abs_address 
			; returns address in EAX
	add ESP, 8	; pop far pointer from stack 
			; then subtract address in EAX from
			; address in DS to get to zero 

	neg EAX 

	; now DS:[EAX] points to absolute zero. Add the
	; value required to EAX to access an address in 
	; the first 1Mb. 

	; To place X in upper right corner of a
	; color monitor: 

	mov byte ptr DS:[0b809Eh + EAX],'X' 

	ret 

	_main endp
	endcode 
	end 
</pre>


<!-- ======================================================= -->
<hr><a name="intreal"><h3>Calling a real mode interrupt not implemented by DOSX</h3></a>

<ul>

	Call <tt>int86_real()</tt> or </tt>int86x_real</tt>
	or define something like this if you want your code to compile
	on DOSX and large model as well:

	<pre>
        #if (sizeof(int)==4)
	#define _CALL_INT(intnum,regsin,regsout) int86_real(intnum,&amp;(regsin),&amp;(regsout))
	#define _CALL_INTS(intnum,regsin,regsout,segregs) int86x_real(intnum,&amp;(regsin),&amp;(regsout),&amp;(segregs))
        #else
	#define _CALL_INT(intnum,regsin,regsout) int86(intnum,&regsin,&regsout)
	#define _CALL_INTS(intnum,regsin,regsout,segregs) int86x(intnum,&amp;(regsin),&amp;(regsout),&amp;(segregs))
        #endif

	</pre>
</ul>

<!-- ======================================================= -->
<hr><a name="realbuffer"><h3>Passing a buffer to a real mode interrupt</h3></a>

<ul>

	The real mode interrupt expects a real mode pointer (segment:offset)
	below the 1 Mbyte limit. Allocate a buffer in real mode memory and
	pass its real mode address to the interrupt:

	<pre>

	unsigned short _x386_convmemalloc(unsigned size);
	//allocate a  conventional memory block
	//return the conventional memory segment, 0 if error
	//!!! allocate 4 k byte minimum !!!
	//!!! there is no way to deallocate this memory !!!

	unsigned short _x386_convmemalloc(const unsigned size)
	{
	    REGS regs;
	    regs.x.bx = (unsigned short)((size + 15) &gt;&gt; 4);
	    regs.h.ah = 0x48;
	    int86(0x21, &regs, &regs);
	    return (regs.x.flags &amp; _cf_)
		? 0                // DOS error number is in ax
		: regs.x.ax;
	}
	</pre>

	example:

	<pre>
        #if (sizeof(int)==4)

	unsigned convmemseg,dosptr;    // real mode segment, pointer
	void* dosxptr;                 // DOSX pointer
	#define DGROUP MKFP(getDS(),0)

	convmemseg = (unsigned)_x386_convmemalloc(size);
	dosptr = convmemseg &lt;&lt; 16;       // offset = 0
	dosxptr = (void*)( - _x386_get_abs_address(DGROUP) + (convmemseg &lt;&lt; 4));

        #endif
	</pre>
</ul>

<!-- ======================================================= -->
<hr><a name="protectedpointers"><h3>Using protected mode pointers</h3></a>

You can use a protected mode pointer to access video memory (or 
other memory in the first 1Mb not assigned to your program). 
Memory above the 1Mb boundary not assigned to your program is 
protected, except under DMIP where protection is less strict. All 
linear addresses above the 1Mb boundary point to memory that is 
owned by the application. Extended memory that is not owned by 
the application is simply not mapped, and does not exist from the 
application's point of view. 


<!-- ======================================================= -->
<hr><a name="memorymappedio"><h3>Accessing memory mapped i/o devices</h3></a>

DOSX code cannot access memory mapped i/o devices above the 
1Mb boundary. 

<!-- ======================================================= -->
<hr>
<a name="samplepointers"><h2>Sample code to manipulate pointers</h2></a>

	Roland writes:
	<p>

	Here is some code to manipulate pointers.
	Compile and run for 16 bit large model and 32 bit DOSX model as well.
	It comes from code debugged and tested for years,
	but I had to do some cut and paste to make this.

	<pre>
	//-----------------------------------------------------------------------
	// written by Roland VARICHON for RONE Technologies 69100 FRANCE
	#endif

	#if (sizeof(int)==2)
	    #define __INTSIZE 2
	#else
	    #define __INTSIZE 4
	#endif

	#if (__INTSIZE==4)
	    #include <io.h>  //getDS
	#endif

	//-----------------------------------------------------------------------
	//some definitions and declaration:


	#if (__INTSIZE==2)
	   #define dword unsigned long
	#else
	    #define dword unsigned int
	#endif

	#define dosptr dword        //real mode far pointer: segment:offset

	#define dosptr_tooff(ptr) ( ((((unsigned)(ptr))&gt;&gt;12) &amp;
	~0xf)+(((unsigned)(ptr)) &amp; 0xffff) )
	//transform a dosptr to an offset based on 0000:0000 addresse

	extern "C" dosptr off_todosptr(const dword s);
	//transform an offset based on 0000:0000 addresse to a dosptr
	//see asm code below

	extern "C" dosptr dosptr_align(const dosptr ptr);
	//align a dosptr: transform it so that offset &lt;= 0xf
	//see asm code below

	extern "C" dosptr dosptr_add(const dosptr ptr, const dword v);
	//add v to a dosptr, return an aligned dosptr
	//!! v must be &gt;=0
	//see asm code below

	extern "C" dosptr dosptr_seek(const dosptr ptr, const long v);
	//same as dosptr_add but v can be &lt;0
	//see asm code below

	//-----------------------------------------------------------------------------

	//C++ code

	#if (__INTSIZE==2)

	#define _dosptr_toptr(ptr) ( ((void*)(ptr)) )
	//nop on 16 bit lare model

	#define _ptr_align(ptr) ( ((void*)dosptr_align((dosptr)(ptr))) )
	//align a real mode far pointer: transform it so that offset &lt;= 0xf

	#define _ptr_add(ptr,v) ( ((void*)dosptr_add((dosptr)(ptr),v)) )
	//add an offset to a real mode far pointer, return an aligned real mode far
	pointer
	//!! v must be &gt;=0

	#define _ptr_seek(ptr,v) ( ((void*)dosptr_seek((dosptr)(ptr),v)) )
	//same as _ptr_add but v can be &lt;0

	#else
	//__INTSIZE==4

	//#include <dos.h> //_x386_get_abs_addresse
	//commented here because in a SC++ version, if included here it didn't
	compile, i don't know why

	#define DGROUP MK_FP(getDS(),0)

	#define _offtoptr(off) ( ((void*)(-_x386_get_abs_address(DGROUP)+off)) )
	//transform an offset based on 0000:0000 addresse to a DOSX near pointer

	#define _dosptr_toptr(ptr) (
	((void*)(-_x386_get_abs_address(DGROUP)+dosptr_tooff(ptr))) )
	//transform a real mode far pointer to a DOSX near pointer

	#define _ptr_align(ptr) ( ((void*)(ptr)) )
	//nop in DOSX model

	#define _ptr_add(ptr,v) ( ((void*)(((byte*)(ptr))+((unsigned)(v)))) )
	//add an offset to a pointer

	#define _ptr_seek(ptr,v) ( ((void*)(((byte*)(ptr))+((int)(v)))) )
	//same as _ptr_add but v is int

	#endif    //__INTSIZE==2

	//-----------------------------------------------------------------------------
	//ASSEMBLY CODE
	; you may have to rewrite the functions as i can't give
	; you all the macro i wrote for assembly
	;it may be enough to be understandable
	;just know that all names beginning with '@' charactere are macros

	;extern "C" dword dosptr_tooff(dosptr s);
	@CS
	@PROC _dosptr_tooff,&lt;_dosptr ??s&gt;;
	    @enter
	    movzx eax,WORD PTR P.??s
	    movzx edx,WORD PTR P.??s[WORD]
	    shl  edx,4
	    add  eax,edx
	      IF (INTG EQ 2)
	    shld edx,eax,16
	      ENDIF
	    @leave
	@ENDP
	@ENDS

	;extern "C" dosptr off_todosptr(dword s);
	;//
	@CS
	@PROC _off_todosptr,&lt;_dword ??s&gt;;
	    @enter
	    mov  eax,P.??s
	    mov  edx,eax
	    shr  edx,4
	    and  _ax,0fh
	      IF (INTG EQ 4)
	    shl  eax,16
	    shrd eax,edx,16
	      ENDIF
	    @leave
	@ENDP
	@ENDS

	;extern "C" dosptr dosptr_align(dosptr ptr);
	;//
	@CS
	@PROC _dosptr_align,&lt;_dosptr ??ptr&gt;;
	    @enter
	    movzx eax,WORD PTR P.??ptr
	    mov  edx,eax
	    shr  _dx,4
	    add  dx,WORD PTR P.??ptr[WORD]
	    and  _ax,0fh
	      IF (INTG EQ 4)
	    shl eax,16
	    shrd eax,edx,16
	      ENDIF
	    @leave
	@ENDP
	@ENDS

	;extern "C" dosptr dosptr_add(dosptr ptr, dword v);
	;//
	@CS
	@PROC _dosptr_add,&lt;_dosptr ??ptr, _dword ??v&gt;;
	    @enter
	    movzx eax,WORD PTR P.??ptr
	    add  eax,P.??v
	    mov  edx,eax
	    shr  edx,4
	    add  dx,WORD PTR P.??ptr[WORD]
	    and  _ax,0fh
	      IF (INTG EQ 4)
	    shl eax,16
	    shrd eax,edx,16
	      ENDIF
	    @leave
	@ENDP
	@ENDS

	;extern "C" dosptr dosptr_seek(dosptr ptr, long_short v);
	;//
	@CS
	@PROC _dosptr_seek,&lt;_dosptr ??ptr, _dword ??v&gt;;
	    @enter
	    movzx eax,WORD PTR P.??ptr
	    movzx edx,WORD PTR P.??ptr[WORD]
	    shl  edx,4
	    add  eax,edx
	    add  eax,P.??v
	    mov  edx,eax
	    shr  edx,4
	    and  _ax,0fh
	      IF (INTG EQ 4)
	    shl  eax,16
	    shrd eax,edx,16
	      ENDIF
	    @leave
	@ENDP
	@ENDS

	</pre>

<!-- ======================================================= -->
<hr><a name="dual"><h2>Dual mode DOSX/Win32 programs</h2></a>

	While DOSX programs will run under Win32, they still suffer from inherent
	problems from being DOS programs. For example, they cannot deal with long
	filenames. Long command lines will not work. Some versions of Win32 have
	poor support for 32 bit DOS. Win32 does not do a good job of transitioning
	environment variable settings when crossing Win32/DOS boundaries. The time
	of day DOS functions are less accurate than the Win32 versions, which can
	cause problems when comparing file times.
	<p>

	The best solution is to create a dual mode DOSX/Win32 program.
	A dual mode program is simply two entirely distinct programs
	bundled together into one EXE file. When running under DOS, the
	DOSX program is run, because the DOS program loader does not
	recognize a Win32 program. When running under Win32, the Win32
	loader will recognize and run the Win32 program.
	<p>

	Thus, a dual mode program delivers the best of both worlds -
	compatibility with DOS, and no compromise when running under
	Win32.
	<p>

	A dual mode program is built by first compiling the program, for
	example <tt>hello.c</tt> for DOSX. Then, build a .def file that names
	the DOSX version as the stub executable. Build the Win32 program
	and link with the .def file:

	<pre>
	-------------- hello.c ------------
	#include &lt;stdio.h&gt;

	int main()
	{
	#if _WIN32
	    printf("hello world from WIN32!\n");
	#else
	    printf("hello world from DOS!\n");
	#endif
	}
	--------------- hello.def ----------
	<a href="ctgDefFiles.html#exetype">EXETYPE</a> NT
	<a href="ctgDefFiles.html#stub">STUB</a> 'hellodos.exe'
	</pre>

	To build:

	<pre>
	sc -mx hello -ohellodos.exe
	sc hello hello.def
	</pre>

<!-- ======================================================= -->
<hr><a name="pharlap"><h3>DOSX compatibility with Phar Lap</h3></a>

	DOSX does emulate some Phar Lap function calls. However, in some 
	cases the emulation is not exact, and is only compatible in the 
	context in which the DOSX library uses the function 
	calls. There are also many Phar Lap functions that are not 
	implemented. If you use the library functions, most compatibility 
	issues should not be a concern. Assembly language programmers 
	might have problems with function calls like 0x 2516 (not 
	implemented in DOSX) or 0x2509 (implemented but incompatible 
	with the corresponding Phar Lap function). 
	<p>

	Functions that are not implemented will return EAX = 0xA5A5A5A5, 
	with the carry flag set; this is the Phar Lap convention for handling 
	unimplemented functions. 

<!-- ======================================================= -->
<hr><a name="nasm"><h3>Using NASM built .obj files with DOSX</h3></a>

	Add 'class=CODE' in the segment declaration. DOSX sets the code
	segment to execute only, and does not set the execution privilege
	bits for code segments, so it is necessary to be accurate about
	which segments are code and which are data.
	Not doing this will cause the resulting program to crash.
	<p>

	<small>(Thanks to Laurentiu Pancescu)</small>


<br><br><br><br>

</td></table>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

