
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - Switching to Digital Mars C++
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:25:47 2006
</div>
</div>

<!-- Generated by Ddoc from switchtodigitalmars.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ctg">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>
</center>

    <a href="ctg.html"><b>Compiler & Tools Guide</b></a><br>

<hr><b>Compiling</b><br>

    &#149; <a href="ctgCompilingCode.html">Compiling Code</a><br>
    &#149; <a href="C-Language-Implementation.html">C Implementation</a><br>
    &#149; <a href="CPP-Language-Implementation.html">C++ Implementation</a><br>
    &#149; <a href="ctgLanguageImplementation.html">Language Extensions</a><br>
    &#149; <a href="ctgMixingLanguages.html">Mixing Languages</a><br>
    &#149; <a href="ctgAsm.html">Assembly Language</a><br>
    &#149; <a href="ctgInlineAsm.html">Inline Assembler</a><br>
    &#149; <a href="ctgOptimizer.html">Optimizing Code</a><br>
    &#149; <a href="ctgNumerics.html">Numerics Programming</a><br>
    &#149; <a href="regular.html">Regular Expressions</a><br>
    &#149; <a href="acrtused.html">Acrtused</a><br>
    &#149; <a href="pragmas.html">Pragmas</a><br>
    &#149; <a href="precompiled.html">Precompiled Headers</a><br>
    &#149; <a href="predefined.html">Predefined Macros</a><br>
    &#149; <a href="warnings.html">Warning Messages</a><br>
    &#149; <a href="ctgCompilerErrors.html">Error Messages</a><br>
    &#149; <a href="warnings.html#runtime">Runtime Messages</a><br>
    <br>

<hr><b>Linking</b><br>

    &#149; <a href="optlink.html">Optlink</a><br>
    &#149; <a href="ctgLinkSwitches.html">Switches</a><br>
    &#149; <a href="ctgDefFiles.html">Module Definition Files</a><br>
    &#149; <a href="ctgLinkOps.html">Operation and Design</a><br>
    &#149; <a href="OptlinkErrorMessages.html">Error Messages</a><br>
    <br>

<hr><b>Win32 Programming</b><br>

    &#149; <a href="win32programming.html#win32">Win32 Programming</a><br>
    <br>

<hr><b>DOS and Win16<br>Programming</b><br>

    &#149; <a href="ctgMemoryModel.html">Memory Models</a><br>
    &#149; <a href="pointers16.html">16 Bit Pointer Types<br> and Type Modifiers</a><br>
    &#149; <a href="win32programming.html#handle">Handle Pointers</a><br>
    &#149; <a href="win32programming.html#dos">DOS</a><br>
    &#149; <a href="dos32.html">DOS 32 (DOSX)</a><br>
    &#149; <a href="win32programming.html#win16">Win16</a><br>
    &#149; <a href="win32programming.html#win16dll">Win16 DLLs</a><br>
    &#149; <a href="windowspe.html">Win16 Prolog/Epilog</a><br>
    <br>

<hr><b>C/C++ Extensions</b><br>

    &#149; <a href="contract.html">Contract Programming</a><br>
    &#149; <a href="debugstatement.html">__debug statement</a><br>
    &#149; <a href="debugstatement.html#debugdeclaration">__debug declaration</a><br>
    &#149; <a href="trace.html">Dynamic Profiling</a><br>
    &#149; <a href="html.html">Embedding C in HTML</a><br>
    <br>

<hr><b>Tools</b><br>

    &#149; <a href="bcc.html" title="Convert Borland compiler commands">BCC</a><br>
    &#149; <a href="chmod.html" title="Examine and change file attributes">CHMOD</a><br>
    &#149; <a href="cl.html" title="Convert Microsoft compiler commands">CL</a><br>
    &#149; <a href="coff2omf.html" title="Convert COFF .obj and .lib to OMF">COFF2OMF</a><br>
    &#149; <a href="coffimplib.html" title="Convert COFF import library OMF">COFFIMPLIB</a><br>
    &#149; <a href="sc.html" title="Compiler command">DMC</a><br>
    &#149; <a href="diff.html" title="Compare files">DIFF</a><br>
    &#149; <a href="diffdir.html" title="Compare directories">DIFFDIR</a><br>
    &#149; <a href="dump.html" title="Dump files in hex">DUMP</a><br>
    &#149; <a href="dumpobj.html" title="Dump object files in hex">DUMPOBJ</a><br>
    &#149; <a href="dumpexe.html" title="Dump exe files">DUMPEXE</a><br>
    &#149; <a href="exe2bin.html" title="Create .com files">EXE2BIN</a><br>
    &#149; <a href="flpyimg.html" title="Read/Write Floppy Image">FLPYIMG</a><br>
    &#149; <a href="grep.html" title="Search files for string">GREP</a><br>
    &#149; <a href="ctgHelp.html" title="Creating Help Tools">HC</a><br>
    &#149; <a href="implib.html" title="Build import libraries">IMPLIB</a><br>
    &#149; <a href="lib.html" title="Object file librarian">LIB</a><br>
    &#149; <a href="libunres.html" title="Analyze library and object files">LIBUNRES</a><br>
    &#149; <a href="make.html" title="Simple make utility">MAKE</a><br>
    &#149; <a href="makedep.html" title="Update makefile dependencies">MAKEDEP</a><br>
    &#149; <a href="me.html" title="MicroEmacs Text Editor">ME</a><br>
    &#149; <a href="obj2asm.html" title="Object file disassembler">OBJ2ASM</a><br>
    &#149; <a href="patchobj.html" title="Patch object files">PATCHOBJ</a><br>
    &#149; <a href="ctgRC.html" title="Microsoft Resource compiler">RC</a><br>
    &#149; <a href="rcc.html" title="Digital Mars Resource compiler">RCC</a><br>
    &#149; <a href="sc.html" title="Compiler command">SC</a><br>
    &#149; <a href="shell.html" title="Shell scripts">SHELL</a><br>
    &#149; <a href="smake.html" title="Manage complex projects">SMAKE</a><br>
    &#149; <a href="touch.html" title="Set file timestamps">TOUCH</a><br>
    &#149; <a href="unmangle.html" title="Format C++ mangled names">UNMANGLE</a><br>
    &#149; <a href="whereis.html" title="Search for files">WHEREIS</a><br>
    <br>

<hr><b>Porting to DMC++</b><br>

    &#149; <a href="switchtodigitalmars.html">Switching to DMC++</a><br>
    &#149; <a href="switchtodigitalmars.html#microsoft">from Microsoft</a><br>
    &#149; <a href="switchtodigitalmars.html#borland">from Borland</a><br>
    &#149; <a href="ctgPorting.html">Porting Guide</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>Switching to Digital Mars C++</h1>

Digital Mars C++ offers numerous advantages over other compilers,
both in programmer productivity and in the speed and robustness of
generated code. Switching to Digital Mars C++ is well worth the effort.
This chapter outlines general considerations for converting existing code. 


<h3>What's in This Chapter</h3>

<ul>
	<li> <a href="#portable">Portable Programming Practices</a>
	<ul>
	    <li> Object compatibility with other compilers. 
	    <li> Using third party libraries with Digital Mars C++. 
	    <li> Recompiling for Digital Mars C++. 
	</ul>
	<li> <a href="#microsoft">Converting from Microsoft</a>
	<li> <a href="#borland">Converting from Borland</a>
</ul>

<hr>
<a name="portable">
<h2>Portable Programming Practices</h2>
</a>

Some of the programming practices that help make code portable 
and reusable also help make it compatible with Digital Mars C++. Your 
code will be easier to convert if you: 


<ul>
	<li> Use ANSI standard library functions wherever possible 
	and avoid compiler-specific extensions. 

	<li> Do not rely on the location, alignment, or size of objects 
	in memory. In addition to the inevitable implementation 
	dependencies of memory models, the Digital Mars C++ 
	compiler assigns different widths to some of the standard 
	data types. 

	<li> Do not rely on objects of the same size being treated as if 
	they had the same type. Digital Mars C++ enforces stricter 
	type checking than either Microsoft C++ or Borland C++, 
	and will generate warnings or errors in these instances. In 
	addition, loosely typed code will often fail under 32-bit 
	compilation. For example, Digital Mars C++ defines the 
	WORD type as an unsigned short, and the UINT type 
	as an unsigned int. If these types are treated 
	identically in your code, you can use the -Jm compiler 
	option to relax type checking. 

	<li> Use manifest constants wherever possible, instead of 
	relying on explicit (and possibly compiler or environment 
	dependent) values. 

	<li> Write function prototypes for all your user-defined 
	functions. See the Chapter 3, "Digital Mars C++ Language 
	Implementation" for more information. 

	<li> Can avoid linking files compiled with different compilers. 
	Before you begin conversion, delete all .obj and .lib 
	files created with your old compiler for which you have 
	the source code. Also, be sure that the INCLUDE and LIB 
	environment variables reference the Digital Mars C++ 
	directories so you do not accidentally compile with one 
	vendor's headers and link with the other's libraries. 
</ul>

<h3>Object Level Compatibility</h3>

Digital Mars C++ object modules are "broadly compatible" with 
Microsoft and Borland objects. However, there are some differences: 

<ul>
	<li> The Digital Mars C++ compiler's "helper" functions (long 
	multiply, float, and so on) are different than their Borland 
	or Microsoft counterparts. If you do not want to recode 
	calls to these functions, remove the other vendor's helper 
	functions from their libraries and include them in your 
	converted code. 

	<li> Digital Mars' floating point libraries are reentrant; our 
	object code is therefore different than Microsoft's or 
	Borland's for functions with C linkage. You can work 
	around this problem by rewriting affected functions to 
	pass a pointer to their return value as a parameter, or by 
	using C++, FORTRAN, or Pascal linkage instead of C 
	linkage. 

	<li> The layout of the struct_iob in stdio. h is different 
	for Digital Mars C++. Therefore, you cannot link buffered 
	I/ O functions compiled with Digital Mars' stdio. h with 
	buffered I/ O functions compiled with a different 
	stdio. h. To avoid problems, compile all modules in a 
	program with the same version of stdio. h. 

	<li> By default, Digital Mars C++ aligns structure members on 
	16-bit boundaries in 16-bit compilations; Microsoft and 
	Borland C++ do not. For binary compatibility, compile 
	with the -a option to suppress structure member 
	alignment. 
</ul>


<h3>Using Third-Party Libraries</h3>

If you must use third-party libraries written for Microsoft or Borland 
C++ with the Digital Mars C++ compiler, there is no simple way to 
determine which features are compatible. Your code could even link 
correctly and still contain obscure errors. 
<p>

If you have the source to the third-party library, try recompiling it 
with Digital Mars C++. A better solution is to obtain the Digital Mars 
version of the library from the vendor. 
Recompiling for Digital Mars C++ In many cases, converting programs written for another compiler to 
Digital Mars C++ can be as easy as recompiling them. Here are some 
steps you can take to ease recompilation: 


<ul>
	<li> Compile without the global optimizer until your program 
	runs without errors. A working program can occasionally 
	fail when optimized. For more information, see Chapter 
	25, "Optimizing Code." 

	<li> In Digital Mars C++, character data is signed by default. If 
	your code depends on char data being unsigned, 
	compile with either the -J or -Ju options. -J treats 
	chars as unsigned, not sign extended. -Ju treats chars as 
	unsigned, sign extended. 

	<li> If your code does not follow strict ANSI type checking 
	rules, use the -Jm option, which relaxes type checking. 
</ul>


<h3>Compile time warnings</h3>

By default, the Digital Mars C++ compiler generates warnings in 
response to more conditions than do most other compilers. If you 
find these unfamiliar warnings annoying, compile with the -w 
(warning level) option. Each instance of -w on the SC command line 
turns off a specific warning. For example, the command: 

<pre>
	sc -w2 -w6 myfile.cpp 
</pre>

turns off warnings number 2 and 6. For information on warnings and 
their numbers, see Chapter 2, "Compiling Code." 




<hr>
<a name="microsoft">
<h1>Converting from Microsoft</h1>
</a>

This chapter describes differences you should consider when
converting code written for Microsoft Visual C++ Version 1.5
to Digital Mars C++. 

<h3>What's in This Chapter</h3>

This chapter discusses compatibility issues between Microsoft Visual 
C++ and Digital Mars C++ with respect to these issues: 

<ul>
	<li> Keywords 
	<li> Predefined macros 
	<li> Header files 
	<li> Libraries 
	<li> MFC 
	<li> Memory model support 
	<li> Assembly language interface 
	<li> Compiler options 
</ul>

<h3>Keywords</h3>

Digital Mars C++ supports most of Microsoft C's nonstandard 
keywords. The following table lists Microsoft's keyword extensions 
and their Digital Mars counterparts: 

<pre>
	Table 23-1 Support for Microsoft keywords 
	Unsupported Microsoft keywords 
	__fastcall 
	__fortran 
	__saveregs 
	__segment 
	__segname 
	__self 
</pre>


<h3>Predefined Macros</h3>

Digital Mars C++ supports most of Microsoft C's nonstandard macros. 
The following table lists Microsoft's extended macros and their 
Digital Mars counterparts: 


<pre>
	Table 23-2 Support for Microsoft C nonstandard macros 

	Unsupported Microsoft macros	Digital Mars counterparts 
	_CHAR_UNSIGNED			_CHAR_UNSIGNED 
	_FAST				No support 
	_MSC_VER			__DMC__ (works the same, but 
					version numbers are for SC) 
	_MSDOS 
	MSDOS 				Recommended use is as a 
					command line argument 
	_PCODE				No support 
	_QC				No support 
	M_I286				M_I286 
	M_I386				M_I386 
	M_I8086				M_I8086 
	M_I86				M_I86 
	M_I86CM				M_I86CM 
	M_I86HM				No support 
	M_I86LM				M_I86LM 
	M_I86MM				M_I86MM 
	M_I86SM				M_I86SM 
	M_I86TM				M_I86TM 
</pre>

<h3>Header Files</h3>

The Digital Mars C++ run-time library includes all the Microsoft 
nonstandard headers. Many of these headers simply reference the 
Digital Mars header file that contains equivalent functions. Digital Mars 
C++ issues a warning whenever your code makes use of such a 
header file. In general, we recommend switching to ANSI-compliant 
headers wherever possible. 


<h3>Library Functions</h3>

Digital Mars C++ supports the great majority of Microsoft Visual C++ 
Version 1.5 library functions. The table below lists the only Microsoft 
functions that the Digital Mars C++ run-time library does not support: 


<pre>
	Table 23-3 Unsupported Microsoft library functions 

	Unsupported 	Microsoft 	Comments
	functions	header 

	Graphics functions graph.h	Digital Mars C++ does not 
					support the DOS graphics 
					system. 

	Charting functions pgchart.h
	 
	Virtual memory	vmemory.h	Digital Mars C++ no longer 
	functions			supports Virtual Code 
					Management (VCM). 


	QuickWin functions io.h 

	_bexpand	malloc.h	Use farrealloc instead. 
	_bfree		malloc.h 
	_bfreeseg	malloc.h 
	_bheapadd	malloc.h	Not needed with Digital Mars 
					C++ heap management. 
	_bheapchk	malloc.h 
	_bheapmin	malloc.h 
	_bheapseg	malloc.h 
	_bheapset	malloc.h 
	_bheapwalk	malloc.h 
	_bmalloc	malloc.h 
	_bmsize		malloc.h 
	_brealloc	malloc.h 
	_dieeetomsbin	math.h 
	_dmsbintoieee	math.h 
	_expand		malloc.h	Use realloc instead. 
	_fexpand	malloc.h	Use farrealloc instead. 
	_fheapchk	malloc.h 
	_fheapmin	malloc.h 
	_fheapset	malloc.h 
	_fheapwalk	malloc.h 
	_fieeetomsbin	math.h 
	_fmsbintoieee	math.h 
	_heapadd	malloc.h	Not needed with Digital Mars 
					C++ heap management. 
	_heapchk	malloc.h 
	_heapmin	malloc.h 
	_heapset	malloc.h 
	_heapwalk	malloc.h 
	_j0, _j1, _jnl	math.h 
	_j0l, _j1l, _jn	math.h 
	_nexpand	malloc.h	Use realloc instead. 
	_nheapadd	malloc.h	Not needed with Digital Mars 
					C++ heap management. 
	_nheapchk	malloc.h 
	_nheapmin	malloc.h 
	_nheapset	malloc.h 
	_nheapwalk	malloc.h 
	_setbnew_handler new.h 
	_sethnew_handler new.h 
	_y0, _y1, _ynl	math.h 
	_y0l, _y1l, _yn	math.h 
</pre>


<h3>Microsoft Foundation Classes</h3>

Digital Mars C++ for Windows and DOS includes the Microsoft 
Foundation Classes Version 2.5, for the Large memory model only. 
Digital Mars C++ for Win32 includes 32-bit MFC 3.0. 
<p>

Digital Mars' versions of the Microsoft Foundation Class Library are 
licenced from Microsoft Corporation. 
<p>

 
	When compiling code that uses the Microsoft 
	Foundation Classes, use the -gf option (see 
	Chapter 2, "Compiling Code"). 


<h3>Memory Models</h3>

The Digital Mars C++ implementation of those 16-bit memory models 
also supported by Microsoft C (the Small, Medium, Compact, and 
Large) is similar, but not exactly the same. The significant differences 
are: 


<ul>
	<li> In the Digital Mars Compact and Large models, unlike their 
	Microsoft counterparts, the stack segment and data 
	segment are not the same. Near pointers in these models 
	are relative to the data segment and cannot be used to 
	access automatic or parameter variables. Check your 
	assembly language source code to ensure that SS is not 
	assumed to be equal to DS. 

	<li> Microsoft C only creates a far data segment if the amount 
	of data exceeds 32,767 bytes, or exceeds the value 
	specified via the /Gt option to CL (Digital Mars C++ has a 
	corresponding compiler option, -GT). While data is 
	always assigned to the near data segment by default, 
	functions are near by default in the Compact model and 
	far by default in the Large model in Digital Mars C++. 

	<li> Digital Mars' malloc() functions take an unsigned int 
	as an argument for all 16-bit memory models and take an 
	unsigned long for 32-bit models. Therefore, the 16-bit 
	models limit the size of a data object to 64KB blocks. To 
	allocate a block greater than 64KB, call farmalloc, 
	which takes an unsigned long. 

	<li> At program startup, a Microsoft C program's heap 
	management run-time allocates _amblksiz bytes of far 
	heap space. Additional heap is allocated in _amblksiz 
	blocks as needed. In contrast, Digital Mars C++ makes a call 
	to DOS for each request for far heap space. 

	<li> Unlike Microsoft C, Digital Mars C++ does not allocate heap 
	blocks of zero size if a program requests them. NULL is 
	returned instead. 

	<li> Unlike Microsoft C, Digital Mars C++ cleans up free heap 
	space when a program releases a block of memory. 

	<li> Digital Mars C++ does not support the Microsoft C 
	_heapadd, _bheapadd, and _nheapadd functions 
	because its heap manager calls DOS each time a program 
	requests far heap space. 

	<li> Digital Mars C++ does not support the Microsoft _expand, 
	_bexpand, _fexpand, and _nexpand routines. Use 
	realloc in place of _expand or _nexpand calls (or 
	wherever possible), and farrealloc in place of 
	_bexpand or _fexpand. However, be aware that 
	realloc and farrealloc, unlike _expand, can move 
	the block to a new location to satisfy the reallocation 
	request, in which case they will return the new location of 
	the reallocated block. 

	<li> Digital Mars C++ does not support these additional non-standard 
	Microsoft memory management functions: 
	_heapchk, _bheapchk, _fheapchk, _nheapchk, 
	_heapwalk, _bheapwalk, _fheapwalk, 
	_nheapwalk, _heapset, _bheapset, _fheapset, 
	_nheapset, _heapmin, _bheapmin, _fheapmin, 
	_nheapmin. 
</ul>


<h3>Huge memory model support</h3>

Digital Mars C++ does not support the Huge memory model. That is, a 
pointer whose type is unspecified cannot be made huge by default. 
However, the compiler supports huge pointers and huge data (via 
the __huge modifier). 
<p>

Digital Mars C++ also supports the Microsoft halloc and hfree 
functions. 

<h3>Support for based pointers</h3>

Digital Mars C++ does not support a based heap. No support for based 
pointers is available except for: 

<pre>
	__based(__segname("_CODE"));
	__based(__segname("_DATA")); 
	__based(__segname("_STACK")); 
</pre>

If your code makes use of based pointers, convert 
them to far pointers. Based pointers are a nonstandard construct and 
the code generated using them is not significantly better than for far 
pointers. 


<h3>Assembly Language Interface</h3>

The Digital Mars C++ assembly language interface is very similar to 
Microsoft's. The only differences are: 

<ul>
	<li> DS is not equal to SS for the Compact and Large memory 
	models. 

	<li> For C functions (those declared as __cdecl or extern 
	"C"), double and float values are returned in the 
	registers, rather than in a static memory locaton. For C++, 
	FORTRAN, and Pascal functions, double and float 
	values are returned on the stack in a manner compatible 
	with Microsoft C. 

	<li> In Digital Mars C++, structs, floats, and doubles are 
	returned by allocating a temporary variable on the stack 
	and passing a hidden pointer to it. The called function 
	copies the return values into this variable and returns a 
	pointer to it. 
</ul>


<h3>Compiler Options</h3>

Digital Mars C++ provides a wide range of compiler command line 
options, many of which perform operations similar or identical to a 
Microsoft compiler option. 
<p>

To convert your old Microsoft compiler command lines to the most 
similar Digital Mars command lines possible, use the
<a href="cl.html#cl">CL</a> utility. CL 
automatically converts Microsoft command lines to SC command 
lines, and then runs SC.
<hr>
<a name="borland">
<h1>Converting from Borland</h1>
</a>

This chapter describes the differences you should consider when
converting code written for Borland C++ Version 4.0 to Digital Mars C++. 

<ul>
	<li> Keywords 
	<li> Predefined macros 
	<li> Header files 
	<li> Libraries 
	<li> Memory model support 
	<li> Assembly language interface 
	<li> Compiler options 
</ul>


<h3>Keywords</h3>

Digital Mars C++ supports many of Borland C's nonstandard keywords. 
The following table lists Borland's extended keywords and their 
Digital Mars counterparts: 

<pre>
	Table 24-1 Support for Borland nonstandard keywords 
	Unsupported Borland keywords Digital Mars counterparts 
	_cs __cs 
	_ds No equivalent 
	_es No equivalent 
	_saveregs No equivalent 
	_seg No equivalent 
	_ss __ss 
</pre>

<h3>Predefined Macros</h3>

Digital Mars C++ supports many of Borland C's nonstandard macros. 
The following table lists Borland's extended macros and their 
Digital Mars counterparts: 


<pre>
	Table 24-2 Support for Borland C++ nonstandard macros 

	Unsupported Borland macros Digital Mars counterparts 

	__BORLANDC__	__DMC__ (works the same, but 
				version numbers are for SC) 
	__BCPLUSPLUS__	__DMC__	(works the same, but 
				version numbers are for SC) 
	__CDECL__	No equivalent 
	__COMPACT__	__COMPACT__ 
	__DLL__		_WINDLL 
	__HUGE__	No equivalent 
	__LARGE__	__LARGE__ 
	__MEDIUM__	__MEDIUM__ 
	__MSDOS__	No equivalent 
	__PASCAL__	No equivalent 
	__OVERLAY__	No equivalent 
	__SMALL__	__SMALL__ 
	__TEMPLATES__	No equivalent 
	__TINY__	__TINY__ 
	__TCPLUSPLUS__	__DMC__ (works the same, but 
				version numbers are for SC) 
	__TURBOC__	__DMC__ (works the same, but 
				version numbers are for SC) 
	_Windows	_WINDOWS 
</pre>


<h3>Header Files</h3>

The Digital Mars C++ run-time library includes all the Borland non-standard 
headers. Many of these headers simply reference the 
Digital Mars header file that contains equivalent functions. Digital Mars 
C++ issues a warning whenever code uses a header file. In general, 
we recommend switching to ANSI-compliant headers wherever 
possible. 


<h3>Library Functions</h3>

Digital Mars C++ supports most Borland library functions. The table 
below lists those Borland functions that the Digital Mars C++ run-time 
library does not support: 


<pre>
	Table 24-3 Unsupported Borland library functions 
	Unsupported 	Borland header	Comments
	functions 

	Graphics functions	graphics.h 
	Text display functions	conio.h 
	_dos_getvect		dos.h 
	_dos_setvect		dos.h 
	_harderr		dos.h 
	_hardresume		dos.h 
	_hardreturn		dos.h 
	_OvrInitEms		dos.h 
	_OvrInitExt		dos.h 
	_setcursortype		conio.h Use display package functions 
	cgets			conio.h Use display package functions 
	cprintf			conio.h Use display package functions 
	cputs			conio.h Use display package functions 
	closedir		dirent.h 
	cscanf			conio.h 
	dostounix		dos.h
	farheapcheck		alloc.h
	farheapcheckfree	alloc.h
	farheapchecknode	alloc.h
	farheapfillfree		alloc.h
	farheapwalk		alloc.h
	getpass			conio.h
	getvect			dos.h
	harderr			dos.h
	hardresume		dos.h
	hardreturn		dos.h
	heapcheck		alloc.h
	heapcheckfree		alloc.h
	heapchecknode		alloc.h
	heapfillfree		alloc.h
	heapwalk		alloc.h
	import			dos.h
	importb			dos.h
	intr			dos.h
	opendir			dirent.h
	outport			dos.h
	outportb		dos.h
	readdir			dirent.h
	rewinddir		dirent.h
	setvect			dos.h
	unixtodos		dos.h
</pre>

 
	Some Digital Mars C++ run-time library functions have 
	different types or numbers of arguments from their 
	Borland counterparts, return different values, or 
	support different defined constants. For information 
	on specific functions see the Run-Time Library 
	Reference. 


<h3>Borland Graphics Interface</h3>

Digital Mars C++ does not support any of the functions, fonts, or 
drivers in the Borland Graphics Interface. 


<h3>Memory Models</h3>

The Digital Mars C++ implementations of those 16-bit memory models 
also supported by Borland C++ (the Tiny, Small, Medium, Compact, 
and Large models) are similar. Their significant differences include: 

<ul>
	<li> In the Digital Mars Compact and Large models, unlike their 
	Borland counterparts, the stack and data segments are not 
	the same. Near pointers in these models are relative to the 
	data segment and cannot access automatic or parameter 
	variables. Check your assembly language source code to 
	ensure that SS is not assumed to be equal to DS. 

	<li> Digital Mars' malloc() functions take an unsigned int 
	as an argument for 16-bit memory models and take an 
	unsigned long for 32-bit models. Therefore, the 16-bit 
	models limit the size of a data object to 64KB blocks. To 
	allocate a block greater than 64KB, call farmalloc, 
	which takes an unsigned long. 

	<li> At program startup, Borland's memory-management 
	routine allocates all available DOS memory as one block 
	of far heap space. In contrast, Digital Mars C++ makes a call 
	to DOS for each request for far heap space. 

	<li> Digital Mars C++ does not support these additional non-standard 
	Borland memory-management functions: 
	heapcheck, farheapcheck, heapfillfree, 
	farheapfillfree, heapwalk, farheapwalk, 
	coreleft. 
</ul>


<h3>Huge memory model support</h3>

Digital Mars C++ does not support the Huge memory model. That is, a 
pointer whose type is unspecified cannot be made huge by default. 
However, the compiler supports huge pointers and huge data (via 
the huge modifier). 
<p>

Digital Mars C++ does not support the Borland halloc and hfree 
functions. Convert calls to these functions to the corresponding 
Digital Mars far calls (which have unsigned long argument types 
and can, therefore, allocate huge blocks) or store the affected data in 
a different structure (a huge array, for example). 


<h3>Assembly Language Interface</h3>

The Digital Mars C++ assembly language interface is very similar to 
Borland's. The only differences are: 

<ul>
	<li> DS is not equal to SS for the Compact and Large memory 
	models. 

	<li> For C functions (those declared as __cdecl and extern 
	"C"), double and float values are returned in registers, 
	rather than in a static memory location. For C++, 
	FORTRAN, and Pascal functions, double and float 
	values are returned on the stack in a manner compatible 
	with Borland C. 

	<li> In Digital Mars C++, structs, floats, and doubles are 
	returned by allocating a temporary variable on the stack 
	and passing a hidden pointer to it. The called function 
	copies the return values into this variable and returns a 
	pointer to it. 

	<li> Digital Mars C++ does not support the _FLAGS register 
	variable. 

	<li> Digital Mars C++ does not store long double values as 
	10-byte quantities; they are the same as doubles (8 bytes). 
</ul>


<h3>Compiler Options</h3>

Digital Mars C++ provides a wide range of compiler command line 
options, many of which perform operations similar or identical to a 
Borland C++ compiler option. 
<p>

To convert Borland compiler command lines to the most similar 
Digital Mars command lines possible, use the
<a href="cl.html#bcc">BCC</a> utility. BCC 
automatically converts Borland C++ command lines to SC command 
lines and then runs SC.



<br><br><br><br>

</td></table>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

