
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - C++ Language Implementation
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:25:45 2006
</div>
</div>

<!-- Generated by Ddoc from CPP-Language-Implementation.d -->



<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ctg">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>
</center>

    <a href="ctg.html"><b>Compiler & Tools Guide</b></a><br>

<hr><b>Compiling</b><br>

    &#149; <a href="ctgCompilingCode.html">Compiling Code</a><br>
    &#149; <a href="C-Language-Implementation.html">C Implementation</a><br>
    &#149; <a href="CPP-Language-Implementation.html">C++ Implementation</a><br>
    &#149; <a href="ctgLanguageImplementation.html">Language Extensions</a><br>
    &#149; <a href="ctgMixingLanguages.html">Mixing Languages</a><br>
    &#149; <a href="ctgAsm.html">Assembly Language</a><br>
    &#149; <a href="ctgInlineAsm.html">Inline Assembler</a><br>
    &#149; <a href="ctgOptimizer.html">Optimizing Code</a><br>
    &#149; <a href="ctgNumerics.html">Numerics Programming</a><br>
    &#149; <a href="regular.html">Regular Expressions</a><br>
    &#149; <a href="acrtused.html">Acrtused</a><br>
    &#149; <a href="pragmas.html">Pragmas</a><br>
    &#149; <a href="precompiled.html">Precompiled Headers</a><br>
    &#149; <a href="predefined.html">Predefined Macros</a><br>
    &#149; <a href="warnings.html">Warning Messages</a><br>
    &#149; <a href="ctgCompilerErrors.html">Error Messages</a><br>
    &#149; <a href="warnings.html#runtime">Runtime Messages</a><br>
    <br>

<hr><b>Linking</b><br>

    &#149; <a href="optlink.html">Optlink</a><br>
    &#149; <a href="ctgLinkSwitches.html">Switches</a><br>
    &#149; <a href="ctgDefFiles.html">Module Definition Files</a><br>
    &#149; <a href="ctgLinkOps.html">Operation and Design</a><br>
    &#149; <a href="OptlinkErrorMessages.html">Error Messages</a><br>
    <br>

<hr><b>Win32 Programming</b><br>

    &#149; <a href="win32programming.html#win32">Win32 Programming</a><br>
    <br>

<hr><b>DOS and Win16<br>Programming</b><br>

    &#149; <a href="ctgMemoryModel.html">Memory Models</a><br>
    &#149; <a href="pointers16.html">16 Bit Pointer Types<br> and Type Modifiers</a><br>
    &#149; <a href="win32programming.html#handle">Handle Pointers</a><br>
    &#149; <a href="win32programming.html#dos">DOS</a><br>
    &#149; <a href="dos32.html">DOS 32 (DOSX)</a><br>
    &#149; <a href="win32programming.html#win16">Win16</a><br>
    &#149; <a href="win32programming.html#win16dll">Win16 DLLs</a><br>
    &#149; <a href="windowspe.html">Win16 Prolog/Epilog</a><br>
    <br>

<hr><b>C/C++ Extensions</b><br>

    &#149; <a href="contract.html">Contract Programming</a><br>
    &#149; <a href="debugstatement.html">__debug statement</a><br>
    &#149; <a href="debugstatement.html#debugdeclaration">__debug declaration</a><br>
    &#149; <a href="trace.html">Dynamic Profiling</a><br>
    &#149; <a href="html.html">Embedding C in HTML</a><br>
    <br>

<hr><b>Tools</b><br>

    &#149; <a href="bcc.html" title="Convert Borland compiler commands">BCC</a><br>
    &#149; <a href="chmod.html" title="Examine and change file attributes">CHMOD</a><br>
    &#149; <a href="cl.html" title="Convert Microsoft compiler commands">CL</a><br>
    &#149; <a href="coff2omf.html" title="Convert COFF .obj and .lib to OMF">COFF2OMF</a><br>
    &#149; <a href="coffimplib.html" title="Convert COFF import library OMF">COFFIMPLIB</a><br>
    &#149; <a href="sc.html" title="Compiler command">DMC</a><br>
    &#149; <a href="diff.html" title="Compare files">DIFF</a><br>
    &#149; <a href="diffdir.html" title="Compare directories">DIFFDIR</a><br>
    &#149; <a href="dump.html" title="Dump files in hex">DUMP</a><br>
    &#149; <a href="dumpobj.html" title="Dump object files in hex">DUMPOBJ</a><br>
    &#149; <a href="dumpexe.html" title="Dump exe files">DUMPEXE</a><br>
    &#149; <a href="exe2bin.html" title="Create .com files">EXE2BIN</a><br>
    &#149; <a href="flpyimg.html" title="Read/Write Floppy Image">FLPYIMG</a><br>
    &#149; <a href="grep.html" title="Search files for string">GREP</a><br>
    &#149; <a href="ctgHelp.html" title="Creating Help Tools">HC</a><br>
    &#149; <a href="implib.html" title="Build import libraries">IMPLIB</a><br>
    &#149; <a href="lib.html" title="Object file librarian">LIB</a><br>
    &#149; <a href="libunres.html" title="Analyze library and object files">LIBUNRES</a><br>
    &#149; <a href="make.html" title="Simple make utility">MAKE</a><br>
    &#149; <a href="makedep.html" title="Update makefile dependencies">MAKEDEP</a><br>
    &#149; <a href="me.html" title="MicroEmacs Text Editor">ME</a><br>
    &#149; <a href="obj2asm.html" title="Object file disassembler">OBJ2ASM</a><br>
    &#149; <a href="patchobj.html" title="Patch object files">PATCHOBJ</a><br>
    &#149; <a href="ctgRC.html" title="Microsoft Resource compiler">RC</a><br>
    &#149; <a href="rcc.html" title="Digital Mars Resource compiler">RCC</a><br>
    &#149; <a href="sc.html" title="Compiler command">SC</a><br>
    &#149; <a href="shell.html" title="Shell scripts">SHELL</a><br>
    &#149; <a href="smake.html" title="Manage complex projects">SMAKE</a><br>
    &#149; <a href="touch.html" title="Set file timestamps">TOUCH</a><br>
    &#149; <a href="unmangle.html" title="Format C++ mangled names">UNMANGLE</a><br>
    &#149; <a href="whereis.html" title="Search for files">WHEREIS</a><br>
    <br>

<hr><b>Porting to DMC++</b><br>

    &#149; <a href="switchtodigitalmars.html">Switching to DMC++</a><br>
    &#149; <a href="switchtodigitalmars.html#microsoft">from Microsoft</a><br>
    &#149; <a href="switchtodigitalmars.html#borland">from Borland</a><br>
    &#149; <a href="ctgPorting.html">Porting Guide</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">

<h1>C++ Language Implementation</h1>

	The C++ language standard (C++98) is:

	<blockquote>
	<cite>"Information Technology - Programming Languages - C++"</cite>,
	<a href="http://webstore.ansi.org/ansidocstore/product.asp?sku=ISO%2FIEC+14882%2D1998">
	ISO/IEC 14882-1998
	</a>
	</blockquote>

	A more readable definition and tutorial on C++ is:

	<blockquote>
	<cite>
	<a href="http://www.amazon.com/exec/obidos/ASIN/0201700735/classicempire">
	The C++ Programming Language Special Edition
	</a></cite>
	Bjarne Stroustrup, Addison-Wesley
	</blockquote>

	<ul>
	<li> <a href="#cpp_preprocessor">Preprocessor</a>
	<li> <a href="#cpp_impdef">Implementation-defined Behavior</a>
	<li> <a href="#cpp_language">Language Conformance</a>
	<li> <a href="#templates">Templates</a>
	<li> <a href="#with">The __with Statement</a>
	<li> <a href="#cpp_unimplemented">Unimplemented Features</a>
	<li> <a href="#cpp_extensions">C++ Extensions</a>
	</ul>

<a name="cpp_preprocessor"><h2>Preprocessor</h2></a>

	The preprocessor used is the same one as for <a href="#c_preprocessor">C</a>.


<a name="cpp_impdef"><h2>Implementation-defined Behavior</h2></a>

	This section documents the items listed as "implementation-defined"
	in C++98. The sections are the spec paragraph numbers.

<h3>4.7-3</h3>

	When an integer is converted to a smaller, signed integer, the value 
	is unchanged if it can be represented in the smaller type. Otherwise, 
	the compiler copies the corresponding low order bits of the larger 
	type to the smaller type. The high order bit of the smaller integer 
	becomes the sign bit, with whatever value it received from the 
	corresponding bit of the larger integer. 

<h3>4.8-1</h3>

	When a less precise float type is converted to a more precise 
	float, the value is unchanged. On the other hand, when a more 
	precise float is converted to a less precise float, and if the value 
	is within the representable range, then the result may be either the 
	next higher or the next lower representable value, depending on the 
	setting of the rounding mode. The default rounding mode is to 
	round to the nearest representable value. 

<h3>4.9-2</h3>

	If a conversion is from an integral type to a floating type, and if the 
	value is in the range that the compiler can represent, but not 
	represent exactly, then the compiler rounds the result according to 
	the current rounding mode. The default rounding mode is to round 
	to the nearest representable value.

<h3>5.2.10-3</h3>

	<tt>reinterpret_cast</tt> simply 'paints' a new type on to an
	existing bit pattern. No change in the bit pattern is performed.

<h3>5.2.10-4</h3>

	The bits are simply transferred to the integral type, 0 extended
	if the integral type is larger than the pointer type.

<h3>5.2.10-5</h3>

	Mappings between pointers and integral types are simply a
	one to one transfer of bits. No changes to the bits are made.

<h3>5.6-4</h3>

	When dividing two integers with the / operator, where the result is 
	inexact and one and only one of the operands is negative, the result 
	is the smallest integer greater than the algebraic quotient (such as 
	-23/4 = -5). The result of the % operator, when the division is 
	inexact and only one of the operands is negative, yields a negative 
	result (such as -23%4 = -3). If the right operand of the % or / 
	operator is 0, the result for integers is a compile time error or
	a runtime exception. For floating point divide by 0, the result is
	an overflow.

<h3>5.8-3</h3>

	When the left operand of the right-shift operator (&gt;&gt;) is
	a signed type and negative, the implementation performs a signed
	right shift. 


<h3>9.6-1 Bit Fields</h3>

	Declare a bit-field as any integral type. The size of the 
	declared type determines the word size for that bit-field. 
	Consequently, a word may be 8, 16, or 32 bits wide. 
	<p>

	A sequence of bit-fields with the same word size can be packed into 
	a structure. No bit-field may be wider than its word size. If a bit-field 
	straddles a word boundary, it is placed in the next word. 
	For example, the bit-field declaration 

<pre class="ccode">struct bits
{
    int b1: 24; 
    int b2: 16;
    int b3: 16; 
    int b4: 24;
}; 
</pre>

	is represented in memory as: 


<pre>
31.......0
unused..b1 
b3......b2 
unused..b4 
</pre>

	The compiler allocates bit-fields beginning with the low-order bit of 
	a word. When packing bit-fields within a structure, the compiler uses 
	an unnamed field with a width of 0 to close out the current word. A 
	bit-field with a different word size from the preceding bit-field 
	causes this closing out to happen automatically, just as a nonbit-field 
	member of the structure does. 

<h3>9.6-3</h3>

	Plain (neither explicitly signed nor unsigned) bit fields are signed.


<a name="cpp_language"><h2>Language Conformance</h2></a>

	DMC++ is not yet fully compliant with C++98. The more significant
	differences are listed.


<h4>Note</h4>

	To enforce C++98 compatibility use the -A compiler 
	option. For a discussion of the changes this 
	produces in the compiler's actions, see
	<a href="ctgCompilingCode.html">"Compiling Code"</a>. 


<h3>Alignment</h3>

For 16-bit applications, types and structure members are aligned on 
word (16-bit) boundaries; for 32-bit applications, they are aligned on 
double-word (32-bit) boundaries. Win32 applications align on 8-byte 
(64-bit) boundaries. 

<pre>
ARM p. 22 (cf. p. 7; 3.2.1c), Gray pp. 486-7 
</pre>

Within structures, you can set alignment on byte, word (two bytes, 
the default), or long word (four bytes) boundaries. To suppress the 
default alignment within structures, pass the -a[1|2|4|8] option 
to the compiler. This ensures that structure members are aligned on 
the specified boundary. Such structure realignment is useful for 
defining structures that map onto particular hardware devices or 
predefined data elements. Alignment control operates only within 
structures; everything else is aligned on word boundaries. 
<p>

The compiler does not generate structures of size 0 if there are no 
nonstatic data members; the minimum size of a structure is 1 byte. 
This minimum size prevents new() from returning zero when it 
allocates an instance of a structure. 
<p>

<b>Warning:</b>
	Compile each source file referencing a 
	given structure with the same type of alignment. If 
	two files that reference the same structure are 
	compiled with different alignments, the compiler 
	does not detect it, but you will get unpredictable error 
	messages from the linker or at run time. 


<h3>Anonymous unions</h3>

C++-style anonymous unions are supported in C-compiled code. 

<h3>C++ style inline functions</h3>

Digital Mars's C compiler supports C++-style inline functions in C code. 
To declare a C function as an inline function, use the extended 
keyword __inline instead of inline. 


<h3>How Digital Mars C++ Implements C++</h3>

These sections discuss implementation-specific features of C++ that 
are not features of C. 

<h3>The _new_handler variable</h3>

The _new_handler variable lets your program call a special 
function, which you provide, when a call to new fails due to lack of 
memory. The special function can free up memory in a way that 
preserves the run-time integrity of your program. If you use 
_new_handler, you do not need to check the return value of new 
for failure. 
<p>

The variable _new_handler is declared to be a pointer to a 
function. It is declared in the C++ Standard Library, and is NULL by 
default. Its declaration is: 

<pre class="ccode">void (*_new_handler)(void); 
</pre>

When new fails, it tests whether _new_handler points to a 
function or if _new_handler is NULL. If _new_handler contains 
a value, the function it points to is called. If properly written, the 
function will reclaim memory until there is enough to satisfy the 
original request to new. If _new_handler is NULL, new returns a 
NULL pointer. 
<p>

There are two ways to set _new_handler; directly as 
in: 

<pre class="ccode">void newfailed_ handler(void); // prototype of handler 
_new_handler = newfailed_handler; // set _new_handler 
</pre>


or through the set_new_handler() library function as in: 

<pre class="ccode">set_new_handler(newfailed_handler); 
</pre>

<h3>Static constructors and destructors</h3>

Static constructors/destructors are implemented in a 
manner compatible with Microsoft Visual C++. For each module that 
has a static constructor or destructor, a pointer to the constructor or 
destructor function is placed in a special segment (XIFU, XIFL, or 
XIFM). The startup code cinit.obj then looks at the constructor 
segment and calls the constructors. The exit function calls the 
destructors by looking at the destructor segment XOF (for near data 
models) or XO (for far data models). 
<p>

Static constructors are called in the reverse of the order in which 
they were linked. Consequently, constructors in the standard library 
are called first. Static destructors are called in the order they were 
linked. Destructors in the standard library are called last. 
<p>

When the run-time library prints a run-time error message, the 
program is aborted without calling any static destructors. Because it 
is possible that a serious error has occurred, to limit the damage it is 
preferable to immediately stop the program. For example, when the 
heap has been corrupted, halt execution. 


<h3>Exception handling</h3>

	Exception handling is not enabled by default, because many C++ programs
	do not use any exception handling, but support for it will add significantly
	to the size of the resulting program.
	To enable exception handling, compile with the <b>-Ae</b> 
	compiler option.


<h3>Run time type identification</h3>

	Run tyme type identification (RTTI) is not enabled by default,
	because many C++ programs
	do not use RTTI, but support for it will add significantly
	to the size of the resulting program.
	To enable exception handling, compile with the <b>-Ar</b> 
	compiler option.
	<p>

	RTTI adds a new member to the virtual function table, a pointer to 
	the type information stored in the table. Thus, classes cannot share 
	vtbl[] s (an optimization the compiler performs by default) when 
	compiling with RTTI. The pointer to the type information is located 
	at a negative offset relative to the start of the vtbl[]; this preserves 
	compatibility with the Microsoft Object Model, which does not 
	support RTTI. 


<h3>Internal Limits</h3>

The following limits apply:

<pre>
Max length of an identifier: 254 
Max length of an external identifier: 254 
Number of arguments to a macro: 127 
Depth of nested #include directives: number of file handles 
</pre>

	The compiler sets no limits on the following code elements, but 
	operating system or hardware requirements may impose practical 
	limits: 

<pre>
Complexity of a declaration 
Length of macro replacement text 
Number of arguments to a function 
Number of cases in a switch 
Number of characters in an argument to a macro 
Number of characters in a line 
Number of characters in a string 
Number of command line arguments 
Number of #if directives that can be nested 
Number of #include paths 
Number of subscripts in an array 
</pre>


The header limits.h specifies the largest and smallest values of 
the integral types.
<p>

There are 3 basic floating point types.
<p>

	<table border=1 cellspacing=0 cellpadding=5>
	<tr> <th> Type <th>Default Size <th>Format
	<tr> <td> float	    <td> 4 bytes		<td> IEEE single precision 
	<tr> <td> double	<td> 8 bytes		<td> IEEE double precision 
	<tr> <td> long double <td> 8(10) bytes		<td> IEEE double (extended) precision 
	</table>
	<p>

The header floating.h, defines the implementation defined characteristics
of the floating types.

<h3>Hexadecimal floating-point constants</h3>

	C99 hexadecimal floating point constants are allowed in C++.

<h3>Character constants</h3>

The mapping of characters in the source character set to the 
execution character set is one-to-one. The basic execution character 
set consists of 256 extended-ASCII characters: 127 U. S. ASCII 
characters plus system defined extensions. All 
integer character constants or escape sequences
can be represented with the basic 
execution character set. 
<p>

ARM p. 10, Gray pp. 480-1 
<p>

Multi-character constants have type int and can contain between 
one and four characters from the execution character set. If the 
constant has more than four characters, then the compiler generates 
an error. If a character string of three or four characters is assigned to 
a short, then the last two characters are used in the assignment. 
For example: 

<pre class="ccode">short foo = 'ABCD'; 
</pre>

will assign CD (0x4344) to foo. 
<p>

If the character following the backslash character is not one of the 
defined escape sequences, then the compiler generates an 
"undefined escape sequence" error. 


<h3>String literals</h3>

If a string literal begins with the sequence \p or \P, the compiler 
treats it as a Pascal string. The compiler replaces the \p or \P with 
the length of the string. Null, '\0', is not appended to Pascal strings, 
as it is with C strings. 
<p>

String literals are distinct. They do not overlap in memory, but it is
good practice to not modify them at runtime.


<h3>Integer Variables</h3>

The size of an integer is memory-model dependent, but it is always 
at least two bytes. An integer is signed by default. For example: 

<pre class="ccode">int x, y, z;
int u = 3000; 
signed int v = -56;// signed int == int
unsigned int r = 0xf000; 
</pre>

For 16-bit memory models, an int is two bytes; for 32-bit memory 
models, an int is four bytes. 


<h3>Short integers</h3>

Short integers are two bytes in Digital Mars C++. For example: 

<pre class="ccode">short a, b;
short int c = -45; 
signed short d = 2145;
unsigned short int e = 0x123f; 
</pre>

<h3>Long integers</h3>

Long integers are four 
bytes. For example: 

<pre class="ccode">long a, b, c = 109;
long f = -1L; 
signed long g = 67;
unsigned long int h = 0x0045123f; 
</pre>


<h3>Long long integers</h3>

	<tt>long long</tt> and <tt>unsigned long long</tt> integers
	in 32-bit compilations are eight bytes.
	Neither are supported in 16 bit compilations.
	For compatibility with other compilers,
	<tt>__int64</tt> and <tt>unsigned __int64</tt> are
	synonyms for <tt>long long</tt> and <tt>unsigned long long</tt>.


<h3>Floating-Point Variables</h3>

As with integers, the size of float types is system-dependent. All 
floating-point numbers require at least four bytes. 

<h3>Single precision variables</h3>

Single precision floating-point numbers are stored in the data type 
float. A float uses four bytes. For example: 

<pre class="ccode">float fl1, fl2;
float fnum = 1.56; 
float gnum = 1.23E3; 
</pre>

<h3>Double precision variables</h3>

Double precision floating-point numbers are stored in the data type 
double. A double may be larger or the same size as a float, but 
never smaller. For example: 

<pre class="ccode">double dp1, ext;
double dnum = 11.435; 
double fnum = 121.23E4; 
</pre>

In Digital Mars C++, a double is an eight byte unit. 

<h3>Long double precision variables</h3>

The long specifier may be added to double to make a type long 
double. A long double may be larger or the same size as a 
double, but never smaller. For example: 

<pre class="ccode">long double ld = 1.678E33; 
</pre>

In Digital Mars C++, a long double is the same size as a double, eight 
bytes, for all 16 bit memory models and for all 32 bit DOS memory models.
For 32 bit Windows, a long double is 10 bytes. 


<h3>Character Variables</h3>

Character variables are used to store single ASCII characters, such as 
the letter 'c'. They are declared using the keyword char. Each 
character is one byte in size. The range of char type values depends 
on whether the character is signed or unsigned. In Digital Mars C++ the 
char data type is signed and can store values between -128 and 
+127. Use of char types above 127 requires declaring the variable as 
unsigned char. The -J compiler option makes char types 
unsigned. 
<p>

There are several ways to denote char values. One way uses the 
character flanked by single quotes, such as 'A'. The second way 
uses the character's ASCII code preceded by a backslash and flanked 
by quotes, such as '\65'. Alternatively, within an assignment 
statement, you can simply use the integer value of the ASCII code, 
such as 65. Character variables can also be expressed in the same 
formats as character constants, as discussed earlier. Examples of each 
of these ways of denoting char values are included here: 

<pre class="ccode">char a_character = 'A';
char a_character = '\65'; 
char a_character = 65;
signed char a_character = 0x41; 
unsigned char a_character; 
</pre>

<h3>Character strings</h3>

Strings are initialized using the same syntax as character 
arrays. Alternatively, the following syntax can be used: 

<pre class="ccode">char s[6] = "hello"; 
</pre>

Digital Mars C++ supports this syntax with automatic arrays as well as 
with global and static arrays. In this example, the 6 is optional. 
When the size of the array is not given, the compiler allocates 
enough space to hold the string and its terminating null character. 
<p>

Digital Mars C++ also supports the wide-character string type, 
wchar_t, for example: 

<pre class="ccode">wchar_t s[] = L" hello"; 
</pre>

Wide char types are used to refer to wide-character strings; they are 
equivalent to unsigned shorts (two bytes). They are used to hold 
character sets where individual characters do not fit into a single 
byte. Wide char types are needed, for example, when attribute 
information, such as color or font, is encoded along with the 
character's ASCII value. The type of wchar_t is defined in 
stddef.h. 


<h3>Standard Conversions</h3>

In a variety of circumstances, the compiler must convert one numeric 
type into another. This section discusses the standard type 
conversions: integral promotions, integral conversions, floating-point 
conversions, conversions between floating-point and integral types, 
and arithmetic conversions. 


<h3>Integral promotions</h3>

Digital Mars C++ follows ANSI C in that integral promotion is "value-preserving." 
See ARM p. 32 for an in-depth discussion of "value-preserving" 
vs. "unsigned-preserving" integral promotions, and their 
relationship to earlier C++ and C implementations. 
<p>

ARM pp. 31-2, 322, Gray p. 489 

<h3>Explicit Type Conversion</h3>

In general, the compiler promotes and sign-extends smaller integral 
types to larger integral types without losing information. In other 
words, the low order bits are copied to the corresponding positions 
of the larger integral type, and the sign bit of the small type is copied 
to the sign bit of the larger type. 
<p>

In C++, a pointer or reference to an object of a const type can be 
cast into a pointer or a reference to a non-const type. The resulting 
reference still applies to the original object. In Digital Mars C++, it is 
possible to modify the value of the constant object through the 
resulting pointer or reference. This works only if the original pointer 
or reference contained a valid address. In this way, you can cast 
away the "constness" of an object. 
<p>

ARM p. 71, 37, Gray pp. 500-2 


<h3>Overflows in numeric expressions</h3>

Overflows in integral expressions are ignored. Overflows in floating
point expressions produce infinity according to the rules of IEEE
arithmetic.


<h3>Additive operators</h3>

The compiler treats memory as linear address space. You can 
reference outside the bounds of an array without the compiler 
detecting it, for example: 

<pre class="ccode">int a[10];
void f() 
{
    int* p = &a[10]; 
    *p = 0xdeadbeef;
} 
</pre>

You can subtract two pointers that point to objects in the same array 
in order to find the number of elements separating the operands. 
The result is of type ptrdiff_t, which is defined as long in 
&lt;stddef.h&gt;. It is an error to subtract pointers which point to 
objects of differing types. However, explicit casting allows the 
operations and circumvents the error. 
<p>

ARM p. 73, Gray p. 503 


<h3>Class member access</h3>

If a member of a union is accessed after a value has been stored in a 
different member of the union, the compiler does not convert the 
type of the member stored into the type of the member doing the 
access. For example: 

<pre class="ccode">union u_tag
{
    int ival; 
    float fval;
} u_obj; 
int i;
u_obj.fval = 4.0; 
i = u_obj.ival;
</pre>

assigns 0x40800000 to i, because the bit pattern stored in 
u_obj.fval is assigned to variable i with no conversion. 
<p>

ARM p. 53 

<h3>Sizeof</h3>

In Digital Mars C++, the type, size_t, is defined as an unsigned 
int in stddef.h. 
<p>

ARM p. 56, Gray p. 497 

<a name="cpp_extensions"><h2>C++ Extensions</h2></a>
<h3>The __typeinfo expression</h3>

Digital Mars C++ implements the expression type: 

<pre class="ccode">__typeinfo (expression) 
</pre>

The syntax for __typeinfo is identical to the syntax for sizeof 
expressions. __typeinfo returns an int, whose bit settings specify 
the type of expression: 

<pre>
	1 expression is a class/struct/union 
	2 expression has a destructor 
	4 expression has a virtual destructor 
</pre>

Other bits are reserved, and should not be assumed to contain a 
meaningful value. 
<p>

__typeinfo, like sizeof, yields information about the static type, 
not the dynamic type, so: 

<pre class="ccode">class A {. . .};
class B : A {. . .}; 
class A *p = new B;
int i = __typeinfo (*p); 
// returns information on A, not B
int s = sizeof (* p); 
// returns information on A, not B 
</pre>

Since the compiler generates different code for objects like array 
new/ delete depending on the presence of a destructor, 
__ typeinfo can be useful in code that must manipulate storage 
allocation in a robust manner. 


<h3>New</h3>

If a class of objects has a constructor, an object of that class can be 
created using the new operator if suitable arguments are provided or 
if there is a default constructor for the class. In either case, the new 
operator allocates memory for the object. 
<p>

ARM p. 61, Gray p. 499 

<h2>Miscellaneous Declarations</h2>

<h3>Enumeration declaration</h3>

In 16-bit compilations, the size of an enumeration is always the same 
size as an int. In 32-bit compilations, the size of an enumeration is 
always 32 bits. 
<p>

ARM pp. 114-5, Gray p. 523 


<h3>Class Members</h3>

The compiler allocates nonstatic data members of a class in order of 
appearance in the source file, regardless of intervening access 
specifiers. 
<p>

ARM p. 173,241, Gray p. 545 


<h3>Pointers to Functions</h3>

In Digital Mars C++, function pointers can be declared as pointing to 
functions with FORTRAN, Pascal, or C linkages by using the 
__fortran, __pascal, or __cdecl keywords, respectively. 
Attempting to assign a pointer, currently pointing to a C++, C, 
FORTRAN, or Pascal function, to a pointer to a different function 
type generates a compiler error. In particular, a pointer to a C++ 
function cannot be assigned to a pointer to a C function. 
<p>

The declaration of a pointer to a function must 
specify both the return type and the parameter list. For example: 

<pre class="ccode">int memcmp( void *, void *, unsigned); 
</pre>

requires a compatible function pointer to be declared as: 

<pre class="ccode">int (*fp)(void *, void *, unsigned); 
</pre>


The portable way to create a pointer to a C function from within C++ 
is to use: 

<pre class="ccode">extern "C"
{
    int (*fp)(int); 
}
</pre>

The alternative, nonportable, syntax is: 

<pre class="ccode">int (__cdecl *fp)(int);
</pre>
 
Similarly, the way to declare a C++ function with a parameter that is 
a C function pointer is: 

<pre class="ccode">extern "C" { typedef (FP)(int); }
int foo(FP fp);
</pre>

<h3>Functions with Variable Numbers of Arguments</h3>

Digital Mars C++ supports functions with variable numbers of 
arguments in a manner compatible with Microsoft's C++ compiler for 
Windows NT. 
<p>

Digital Mars C++ generates code with C linkage for any function with a 
variable number of arguments, even if the function is explicitly 
declared to have Pascal linkage. 


<h3>Function Prototyping</h3>

The Digital Mars C++ compiler promotes arguments in function 
definitions. When the promoted types of the arguments to a function 
definition conflict with the types of the parameters in the 
corresponding prototype, errors can occur. 
<p>

For example, if you write a prototype for a function that takes a 
float argument, and define the same function using an "old style" 
function definition, an ANSI compiler will promote the float to a 
double when it compiles the definition. This will generate an error 
because the definition no longer matches the prototype. In other 
words, the function is now defined to take an argument of type 
double, but prototyped to take a float. 
<p>

When you compile with the require prototypes -r (strict 
prototyping) option, Digital Mars C++ does not generate an error in 
cases where an old style function definition and a prototype exist for 
the same function. In other words, no error is generated as long as 
the types for the parameters in the prototype are the same as the 
types of the arguments to the function before promotion. 
<p>

If you do not compile with -r, Digital Mars C++ considers the differing 
function definitions to be invalid and generates an error. The same 
results occur when you compile with -A (enforce the ANSI 
standard). 

<a name="templates">
<h2>Templates</h2>
</a>

One of the more interesting features of the C++ language is the 
template. Templates let you define container classes and generic 
functions without giving up type checking. Digital Mars C++ provides 
for the definition, declaration, and use of both class templates and 
function templates, as described in ARM, Chapter 14, and Gray, 
Chapter 8. 


<h3>Template definitions and examples</h3>

Briefly, a function template declaration states the existence of a 
function template definition. For example: 

<pre class="ccode">template &lt;class T&gt; square(T v); 
</pre>

declares the existence of a square function whose argument, v, is of 
type T, and whose return value is also of type T. 
<p>

A function template definition provides the information needed by 
the compiler to generate instantiations. For example: 

<pre class="ccode">template &lt;class T&gt; square(T v)
{ 
    return v * v;
} 
</pre>

defines the square function to produce a return value by multiplying 
the argument, v, by itself. Observe that this is still not enough 
information for the compiler to generate code for a specific square 
operation. The needed information is provided by the context in 
which the square function is called. For example: 

<pre class="ccode">void byUse()
{   
    int i = 5;
    float f = 3.14; 
    i = square(i);
    f = square(f); 
}
</pre>
 
instructs the compiler to produce two specializations of the square 
function: one for ints and one for floats. In Digital Mars C++, 
specialization is the use of a template that generates code. 
<p>

A class template declaration states the existence of a class template 
definition. For example: 

<pre class="ccode">template &lt;class T&gt; class List; 
</pre>

declares the existence of a List class object. 
<p>

A class template definition specifies a list of members for the class 
template. For example: 

<pre class="ccode">template &lt;class T&gt; class List
{   
public:
    T *GetFirst(); 
    List *GetRest();

private: 
    T *pFirst;
    List *pRest; 
}; 
</pre>

where template member function definitions, which provide the 
information needed by the compiler to generate member definitions, 
are needed for GetFirst and GetRest. For example: 

<pre class="ccode">template &lt;class T&gt; T *List&lt; T&gt;::GetFirst()
{ 
    return *pFirst;
} 
</pre>

simply calls the internal C function, pFirst. 
<p>

As with template functions, a call in a specific context is needed for 
the compiler to produce a specialization of a template member 
function. 

<h3>Generating code for templates</h3>

When using templates, it is important to remember that the compiler 
can only generate code when the compiler encounters a 
specialization of a template. It cannot generate code from the 
template definition alone, because the compiler would then have to 
generate code for all possible specializations. Because the compiler 
generates code when it encounters a specialization of a template 
definition, it is possible that it will generate identical code in more 
than one object file. 
<p>

The linker, rather than the compiler, eliminates the redundant code 
from multiple occurrences of the same specialization. By default, the 
compiler marks the code generated by each specialization as a 
COMDAT. The linker processes COMDATs specially, removing 
duplicate definitions. For more information on COMDATS, see the 
section on the -NC option in Chapter 2, "Compiling Code." 
<p>

For the compiler to be able to generate code for a template member 
function, it must have access to the class template and the template 
member function definition, as well as the relevant specialization. 
Consequently, the template member function definition must be 
included in the compilation unit (for example, the source file and its 
included files) that contains the specializations of the class template. 
<p>

A simple and effective way to use templates is to include template 
declarations with the template definitions. When this is done, the 
compiler will be able to generate code when it needs to and the 
linker will remove duplicate instance definitions using the COMDAT 
mechanism. 
<p>

ARM p. 378, Gray p. 613 


<a name="with"><h3>The __with Statement</h3></a>

For ease in porting Modula 2 code to C++, Digital Mars C++ includes a 
__with construct. The form __with is used instead of with to 
avoid name-space conflicts. The syntax of the __with construct is: 

<pre class="bnf">	__with (expression)
	    statement 
</pre>

where expression must evaluate to an instance of an object of a class. 
It is evaluated only once. Within the statement, a scope is introduced 
for this class. This scope is searched before all other scopes. When a 
member of the class is parsed, it is semantically equivalent to 
expression. member. 
<p>

__with statements do not affect access rules. __with clauses may 
be nested; the rules are the same as for braces {}. Refer to 
class members of a previously nested __with clause without 
specifying the class; if an identifier is not a member of the innermost 
__with clause, outer __with clauses are searched automatically. 
<p>

The following example shows how to resolve member references 
using nested __with statements. 

<pre class="ccode">class A 
{
    int X;
  public: 
    int Y;
} a; 


int func(int i, A *p)
{
    A *q = p; 
    p[0].y = 2;
    p[1].y = 8; 
    __with (*p)
    {
	y = 4;	// p[0].y = 4 
	p++;	// does not affect __with's expression 
	__with (*q)
	{
	    if (i == 3) 
		return y; // returns q-&gt;y (4)
	} 
	if (i == 5)
	    return x;	// illegal; p-&gt;x is private
	else if (i == 6) 
	    return p-&gt;y; // returns 8
	else 
	    return y;	// p-&gt;y is returned (4)
    } 
} 
</pre>

<hr><a name="cpp_unimplemented"><h2>Unimplemented Features</h2></a>

While Digital Mars C++ strives to be fully compatible with C++98,
some features remain unimplemented, for example:

<ul>
	<li> <tt>export</tt> keyword.
	<li> Enums larger than an int.
</ul>


<br><br><br><br>

</td></table>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

