
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - Mixing Languages
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:25:45 2006
</div>
</div>

<!-- Generated by Ddoc from ctgMixingLanguages.d -->



<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ctg">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>
</center>

    <a href="ctg.html"><b>Compiler & Tools Guide</b></a><br>

<hr><b>Compiling</b><br>

    &#149; <a href="ctgCompilingCode.html">Compiling Code</a><br>
    &#149; <a href="C-Language-Implementation.html">C Implementation</a><br>
    &#149; <a href="CPP-Language-Implementation.html">C++ Implementation</a><br>
    &#149; <a href="ctgLanguageImplementation.html">Language Extensions</a><br>
    &#149; <a href="ctgMixingLanguages.html">Mixing Languages</a><br>
    &#149; <a href="ctgAsm.html">Assembly Language</a><br>
    &#149; <a href="ctgInlineAsm.html">Inline Assembler</a><br>
    &#149; <a href="ctgOptimizer.html">Optimizing Code</a><br>
    &#149; <a href="ctgNumerics.html">Numerics Programming</a><br>
    &#149; <a href="regular.html">Regular Expressions</a><br>
    &#149; <a href="acrtused.html">Acrtused</a><br>
    &#149; <a href="pragmas.html">Pragmas</a><br>
    &#149; <a href="precompiled.html">Precompiled Headers</a><br>
    &#149; <a href="predefined.html">Predefined Macros</a><br>
    &#149; <a href="warnings.html">Warning Messages</a><br>
    &#149; <a href="ctgCompilerErrors.html">Error Messages</a><br>
    &#149; <a href="warnings.html#runtime">Runtime Messages</a><br>
    <br>

<hr><b>Linking</b><br>

    &#149; <a href="optlink.html">Optlink</a><br>
    &#149; <a href="ctgLinkSwitches.html">Switches</a><br>
    &#149; <a href="ctgDefFiles.html">Module Definition Files</a><br>
    &#149; <a href="ctgLinkOps.html">Operation and Design</a><br>
    &#149; <a href="OptlinkErrorMessages.html">Error Messages</a><br>
    <br>

<hr><b>Win32 Programming</b><br>

    &#149; <a href="win32programming.html#win32">Win32 Programming</a><br>
    <br>

<hr><b>DOS and Win16<br>Programming</b><br>

    &#149; <a href="ctgMemoryModel.html">Memory Models</a><br>
    &#149; <a href="pointers16.html">16 Bit Pointer Types<br> and Type Modifiers</a><br>
    &#149; <a href="win32programming.html#handle">Handle Pointers</a><br>
    &#149; <a href="win32programming.html#dos">DOS</a><br>
    &#149; <a href="dos32.html">DOS 32 (DOSX)</a><br>
    &#149; <a href="win32programming.html#win16">Win16</a><br>
    &#149; <a href="win32programming.html#win16dll">Win16 DLLs</a><br>
    &#149; <a href="windowspe.html">Win16 Prolog/Epilog</a><br>
    <br>

<hr><b>C/C++ Extensions</b><br>

    &#149; <a href="contract.html">Contract Programming</a><br>
    &#149; <a href="debugstatement.html">__debug statement</a><br>
    &#149; <a href="debugstatement.html#debugdeclaration">__debug declaration</a><br>
    &#149; <a href="trace.html">Dynamic Profiling</a><br>
    &#149; <a href="html.html">Embedding C in HTML</a><br>
    <br>

<hr><b>Tools</b><br>

    &#149; <a href="bcc.html" title="Convert Borland compiler commands">BCC</a><br>
    &#149; <a href="chmod.html" title="Examine and change file attributes">CHMOD</a><br>
    &#149; <a href="cl.html" title="Convert Microsoft compiler commands">CL</a><br>
    &#149; <a href="coff2omf.html" title="Convert COFF .obj and .lib to OMF">COFF2OMF</a><br>
    &#149; <a href="coffimplib.html" title="Convert COFF import library OMF">COFFIMPLIB</a><br>
    &#149; <a href="sc.html" title="Compiler command">DMC</a><br>
    &#149; <a href="diff.html" title="Compare files">DIFF</a><br>
    &#149; <a href="diffdir.html" title="Compare directories">DIFFDIR</a><br>
    &#149; <a href="dump.html" title="Dump files in hex">DUMP</a><br>
    &#149; <a href="dumpobj.html" title="Dump object files in hex">DUMPOBJ</a><br>
    &#149; <a href="dumpexe.html" title="Dump exe files">DUMPEXE</a><br>
    &#149; <a href="exe2bin.html" title="Create .com files">EXE2BIN</a><br>
    &#149; <a href="flpyimg.html" title="Read/Write Floppy Image">FLPYIMG</a><br>
    &#149; <a href="grep.html" title="Search files for string">GREP</a><br>
    &#149; <a href="ctgHelp.html" title="Creating Help Tools">HC</a><br>
    &#149; <a href="implib.html" title="Build import libraries">IMPLIB</a><br>
    &#149; <a href="lib.html" title="Object file librarian">LIB</a><br>
    &#149; <a href="libunres.html" title="Analyze library and object files">LIBUNRES</a><br>
    &#149; <a href="make.html" title="Simple make utility">MAKE</a><br>
    &#149; <a href="makedep.html" title="Update makefile dependencies">MAKEDEP</a><br>
    &#149; <a href="me.html" title="MicroEmacs Text Editor">ME</a><br>
    &#149; <a href="obj2asm.html" title="Object file disassembler">OBJ2ASM</a><br>
    &#149; <a href="patchobj.html" title="Patch object files">PATCHOBJ</a><br>
    &#149; <a href="ctgRC.html" title="Microsoft Resource compiler">RC</a><br>
    &#149; <a href="rcc.html" title="Digital Mars Resource compiler">RCC</a><br>
    &#149; <a href="sc.html" title="Compiler command">SC</a><br>
    &#149; <a href="shell.html" title="Shell scripts">SHELL</a><br>
    &#149; <a href="smake.html" title="Manage complex projects">SMAKE</a><br>
    &#149; <a href="touch.html" title="Set file timestamps">TOUCH</a><br>
    &#149; <a href="unmangle.html" title="Format C++ mangled names">UNMANGLE</a><br>
    &#149; <a href="whereis.html" title="Search for files">WHEREIS</a><br>
    <br>

<hr><b>Porting to DMC++</b><br>

    &#149; <a href="switchtodigitalmars.html">Switching to DMC++</a><br>
    &#149; <a href="switchtodigitalmars.html#microsoft">from Microsoft</a><br>
    &#149; <a href="switchtodigitalmars.html#borland">from Borland</a><br>
    &#149; <a href="ctgPorting.html">Porting Guide</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>Mixing Languages</h1>

Digital Mars C++ supports linkage with C, FORTRAN, and Pascal functions.
This chapter describes the function-naming and parameter-passing conventions
for linking these languages. It also details the
implementation of type-safe linkage, which 
allows the linker to check the types of function arguments across 
separately compiled modules and lets the programmer use the same 
function name for different functions. 
<p>
For information about calling assembly language routines from C or 
C++, see <a href="ctgAsm.html">Using Assembly Language Functions</a>. 


<h3>What's in This Chapter</h3>

<ul>
	<li> Type-safe linkage. 

	<li> C++ linkage. 

	<li> C linkage. 

	<li> Mixing C and C++ modules. 

	<li> Name mangling in C++. 

	<li> Fortran and Pascal linkage. 

</ul>
<h2>Type-Safe Linkage</h2>

The Digital Mars C++ implementation of type-safe linkage is designed 
to make it easy to call, from a C++ program, a function 
written in another language or vice versa. The system Digital Mars uses 
is identical to the one described in the Microsoft Object Mapping 
Specification, published by Microsoft's Language Business Unit. 
<p>
Type-safe linkage is an important feature of DMC++, even if 
only linking C++ modules. It lets you overload functions 
(give different functions the same name) because it provides the 
linker with a unique identifier for each function. The compiler 
mangles the name you give a function, in combination with the 
number and type of its arguments, to produce a unique identifier for 
the linker. 

<h3>Problems with traditional (unsafe) C linkage</h3>

Traditional C linkage mechanisms are unsafe because they give the 
compiler no viable way to check the types of function arguments 
across separately compiled program modules. This deficiency can 
cause serious problems at compile time. For instance, suppose the 
following function is defined in a header file: 
<pre>
	void checkit(unsigned char c); 
</pre>
where c is defined as unsigned char because some of the values 
it needs to check for are in the range 128 through 255. This header is 
typically included in the file that defines checkit. 
<p>
As is also common in C programming, checkit is used in a second 
file. Rather than include the header file, the programmer (per 
convention) separately declares the prototype for checkit at the 
top of the second file. The following prototype is used: 
<pre>
	void checkit(char c); 
</pre>
If the program is compiled on a system that uses unsigned chars by 
default, the above code compiles and executed perfectly. However, 
if the program is then ported to a compiler where chars are signed 
by default (like DMC++), the program yields unpredictable 
results because the call to checkit in the second file treats values 
over 127 as negative. 
<p>
Bugs of this type can prove very difficult to find because the 
compiler processes one file at a time and therefore cannot detect 
type violations in function prototypes across files. But with type-safe 
linkage, the compiler generates two different internal (hidden) 
identifiers for the two prototypes. Since no matching function is 
provided for the second prototype, the linker flags this external 
function reference as unresolved. 


<h3>Advantages of type-safe linkage</h3>

Type-safe linkage offers these important advantages over traditional 
C linkage: 

<ul>
	<li> You can overload C++ functions without using the 
	overload keyword. 

	<li> The linker automatically checks the types of function 
	arguments across modules. 

	<li> The compiler provides improved error checking and error 
	reporting with respect to type mismatches. 
</ul>

This system still allows linkage to external libraries and precompiled 
C code without having to recompile them. It is also more flexible 
than modifying function linkage with the __cdecl, __pascal, or 
__fortran keywords alone. However, each linkage type 
(Digital Mars C++ supports FORTRAN and Pascal linkage, in addition to 
the built-in C++ and C linkage specifications) differs from the others 
in function-naming, parameter-passing conventions, or both, 
depending on the target environment. 


<h2>C++ Linkage</h2>

C++ linkage is the linkage type the C++ compiler uses by 
default. 

<h3>Function naming</h3>

The C++ compiler mangles the names of functions with 
C++ linkage to include information on the number and types of 
arguments they take. For member functions, information as to the 
class to which a function belongs is also included. 


<h3>Overloading</h3>

All functions are automatically overloaded. Whenever a new version 
of a function is defined, it must have a prototype that the compiler 
can distinguish; otherwise, it cannot be overloaded. Because the 
internal name for each function is unique, the compiler can resolve a 
function call to the correct version of the overloaded function, even 
if it occurs in a third-party external library. Since the overloading of 
functions is automatic, the overload keyword is redundant 
(although it is still allowed). Do not use the overload keyword in 
new code because it could be removed from the C++ language 
definition. 
<p>

If you accidentally overload a function (that is, if you declare it twice 
with different argument types), one of these functions will not have 
a function definition with matching argument types, and the linker 
will report an unresolved external reference. This happens even if 
the re-declarations occur in two separately compiled modules. 


<h3>How the compiler treats functions with C++ linkage</h3>

The compiler performs these operations on functions with C++ 
linkage: 

<ul>
	<li> It mangles all function names (that is, type information is 
	appended to the function name). 

	<li> For functions that take a fixed number of arguments: 

	<ul>
		<li> It pushes arguments from left to right onto the stack 
		before the function is called (the rightmost argument 
		is closest to the stack pointer). 

		<li> The called function (not the caller) cleans the 
		arguments off the stack. On 8086-based processors, 
		this is accomplished via the RET N instruction, where 
		N is the number of bytes on the stack. 

		<li> It returns structures by allocating a temporary variable 
		on the stack and passing a hidden pointer to it. The 
		called function copies the return values into the 
		temporary variable and returns a pointer to it. This 
		method is reentrant. 

		<li> It returns floats and doubles in registers (unlike 
		Microsoft C). This method is reentrant. 
	</ul>
	<li> For functions that take a variable number of arguments: 

	<ul>
		<li> It pushes arguments from right to left onto the stack 
		before the function is called (the leftmost argument is 
		closest to the stack pointer). 

		<li> The caller of the function cleans the arguments off the 
		stack. 

		<li> It returns floats and doubles in registers (unlike 
		Microsoft C). This method is reentrant. 

		<li> It returns structures that are 1, 2, or 4 bytes long in 
		registers. Larger structures are returned by creating a 
		temporary variable in a static buffer, copying the 
		return value into the buffer, and returning a pointer to 
		it. This method is not reentrant. 
	</ul>
</ul>

<h3>Mixing C++ linkage with other linkage types</h3>

C does not support C++ linkage. You can call C functions 
from C++ code but you cannot call C++ functions from C code. 
With the C++ compiler, you can use the syntax: 
<pre>
	extern "C++" { } 
</pre>
to specify C++ linkage when the declaration of a C++ function is 
nested inside declarations for some other linkage type. See the 
section "Type-Safe Linkage" in this chapter for more information. 
<p>
<b>Note:</b> 
	The __near and __far keywords are ignored for 
	member functions and always use the default for 
	the memory model used. This behavior simplifies 
	the implementation of virtual functions. 


<h2>C Linkage</h2>

The C linkage method allows programs written in C++ to link with 
and call C library functions. C linkage has the same effect with the 
C++ compiler as the __cdecl keyword has with the C compiler. 
<p>

C linkage is the default linkage for .c files when compiled without 
the -cpp flag. If a function is declared as using C linkage, and a 
function definition is found in the C++ source file, that function is 
compiled as a C function and not as a C++ function. Any calls to that 
function from other C++ functions are handled correctly. 
<p>

Digital Mars's C linkage is compatible with the C linkage used by the 
Microsoft C compiler. 


<h3>How the compiler treats functions with C linkage</h3>

The compiler treats functions with C linkage as follows: 
<ul>
	<li> It prefixes an underscore (_) to all global names. 

	<li> It does not mangle function names. 

	<li> It pushes arguments from right to left onto the stack 
	before the function is called (the leftmost argument is 
	closest to the stack pointer). 

	<li> The caller of the function cleans the arguments off the 
	stack. 

	<li> It returns structures that are 1, 2, or 4 bytes long in 
	registers. It returns larger structures by creating a 
	temporary variable in a static buffer and passing a hidden 
	pointer to it. This method is not reentrant. 

	<li> It returns floats and doubles in registers (unlike 
	Microsoft C). This method is reentrant. 
</ul>

<h3>Specifying C linkage in C++ code</h3>

In C++ code, use this syntax to specify C linkage: 
<pre>
	extern "C" { } 
</pre>
In C code, you can specify C linkage explicitly by using the 
__cdecl type modifier, provided you do not require strict ANSI C 
compatibility. 
<p>

<b>Note:</b>
	The compiler recognizes the main function as 
	special and always compiles it with C linkage. 


<h2>Mixing C and C++ Modules</h2>

C++ lets you call a C function from a C++ program. Only 
minor changes to header files typically are required. 
Compatibility with existing source code Every effort has been made to maximize
compatibility between 
DMC++ and other C++ and C compilers, but you may need to 
take some precautions when compiling code written with other 
compilers. See Chapter 22, "Switching to Digital Mars C++," for 
information. 


<h3>Compatibility with earlier versions of Digital Mars C++</h3>

Programs that compiled under earlier versions of DMC++ 
should compile and run with only minor modifications under 
Version 7. However, you need to recompile all your code because of 
differences in the way the new compiler stores objects in memory. 
You might also need to make some changes to header files to 
account for the new compiler's more stringent type checking. 


<h3>Recompiling C code as C++ code</h3>

We recommend that you rename your C modules with an extension 
that the compiler recognizes as a C++ file extension, or compile with 
the -cpp switch, so that your C functions use the default C++ 
linkage. This provides the benefit of cross-module type checking for 
those functions. Recompiling C functions as C++ functions also 
means an increase in speed because the compiler can use the more 
efficient C++ parameter-passing method. 
<p>
If you wish to retain C linkage for functions that call assembly 
language routines, remember to ensure that the interface to C++ is 
correct (see
<a href="ctgAsm.html">Using Assembly Language Functions</a>
for information). 


<h3>Using existing C libraries</h3>

If you need to link separately compiled C and C++ object files, use 
an existing C library without having to recompile it, or use assembly 
language routines that have been designed to interface to C. You 
need to ensure that the C++ modules use the right linking 
conventions when calling functions contained in C or assembly 
language modules. 
<p>
Unless your C modules are compiled with a third-party C compiler, 
you do not have to recompile them. Follow the steps below to 
generate an object file and associated header files that you can link 
to both C and C++ modules. All that is required is a modification of 
the associated header files. 
<p>

<b>Note:</b> 
	When constructing makefiles, be sure to run the 
	right compiler for each file. The default extension 
	for C files is .c. Valid extensions for C++ files are 
	.cpp, .cxx, or .cc. 


<h3>Changing the header files</h3>

To modify an existing C library to work with Digital Mars C++, insert 
the following code at the beginning of each header file: 

<pre>
	#ifdef __cplusplus
	extern "C" { 
	#endif 
</pre>
And, at then end of the file, insert this code: 
<pre>
	#ifdef __cplusplus
	} 
	#endif 
</pre>
You can then use the header with both C and C++ files. 
<p>
Where it is undesirable to modify the header file, you can use the 
following technique to encapsulate the #include statement in the 
source file: 
<pre>
	extern "C" {
	#include "c_header.h" 
	}
</pre>
<h3>Prototyping the functions in a library</h3>

If, after linking your program with a library, you get one or more 
linker error messages about unprototyped functions, it is likely that 
not all of the functions contained in the library are prototyped in the 
header files for the library. You need to provide prototypes for those 
functions that do not have them and place them in the header files. 
You know which functions require prototyping by looking at the 
first part of the function name reported by the linker, up to the 
underscore. The procedure is the same for assembly language 
functions. 
<p>
Once you have modified a header file, you should be able to use the 
library without difficulty, provided you always include the required 
headers for the functions you use (as you must for the standard C 
libraries supplied with the compiler). 


<h2>Name Mangling in C++</h2>

Name mangling refers to the way in which the compiler alters 
function names internally so that it can track member functions, 
function overloading, and argument types. 
<p>
The general layout for the DMC++ name mangling is 
described in the Microsoft Object Mapping Specification, published 
by Microsoft's Language Business Unit. 
<p>
The basis for this name mangling is the function name itself, with an 
added signature that holds information about the class (if any) to 
which the function belongs and the number and types of its 
arguments. 
<p>
When constructing a C++ function name, the compiler takes the 
original function name as the root of the encoded name. If the 
function being encoded is a C++ operator, the compiler must also 
supply a function name to represent the operator. 
<p>
To view the mangled names of your functions, compile them and 
then use the
<a href="dumpobj.html">DUMPOBJ</a> or
<a href="obj2asm.html">OBJ2ASM</a> utilities to view the resulting 
object file, or link the code and run the
<a href="unmangle.html">UNMANGLE</a>
utility on the executable or map file. 
<p>
You can also examine mangled names in a compiled program with 
the Digital Mars C debugger or with the Digital Mars C++ debugger in 
pure C mode. 

<h2>FORTRAN and Pascal Linkage</h2>

The FORTRAN and Pascal linkage types let you link
C++ code to code written in other languages that use FORTRAN or 
Pascal calling conventions. 
<p>
In DMC++, the FORTRAN and Pascal linkage types behave 
identically. However, you should use the appropriate specifier for 
functions of each type because the calling conventions for FORTRAN 
and Pascal may differ in future releases or on other platforms. 

<h3>Compilation of functions with FORTRAN/Pascal linkage</h3>

The compiler treats functions with FORTRAN or Pascal linkage as 
follows: 
<ul>
	<li> It does not prefix an underscore (_) to global names. 

	<li> It converts all global names to uppercase. 

	<li> It does not append type information to function names. 

	<li> It pushes arguments onto the stack from left to right. 

	<li> The called function cleans the stack. 

	<li> Structures, floats, and doubles are returned by 
	allocating a temporary variable on the stack and passing a 
	hidden pointer to it. The called function copies the return 
	values into this variable and returns a pointer to it. This 
	method is reentrant. 
</ul>

<h3>Specifying FORTRAN/Pascal linkage in C code</h3>

In C code, use the __pascal type modifier to get Pascal linkage 
and the __fortran type modifier to get FORTRAN linkage, 
provided you do not require strict ANSI C compatibility. 


<h3>Specifying FORTRAN/Pascal linkage in C++ code</h3>

In C++ code, use this syntax to specify Pascal or FORTRAN linkage: 
<pre>
	extern "Pascal" { } 
</pre>
or 
<pre>
	extern "FORTRAN" { } 
</pre>
You cannot use the C++ syntax in C programs. 
<p>
<b>Warning:</b>
	Although the FORTRAN and Pascal linkage methods 
	allow C++ programs to call functions of these types 
	or vice versa, they do not handle any other required 
	conversions. For example, conversions of NULL-
	terminated C++ strings into Pascal strings with a 
	length prefix are not automatic. 

<h3>__cdecl, __fortran, and __pascal</h3>

In Digital Mars C++, it is possible to call functions that do not use 
the default function calling conventions. For instance, system 
functions in the Microsoft Windows API use Pascal calling 
conventions. The keywords __cdecl, __fortran, and __pascal 
tell the C compiler that the functions to which they refer use the 
calling and parameter-passing conventions of C, FORTRAN, or 
Pascal, respectively, rather than the default conventions. In this 
respect, they work in the same way as extern "C", extern 
"FORTRAN", and extern "Pascal" do in the C++ compiler, 
except that the extern format also engages the function-naming 
conventions of the indicated language. 
<p>


<b>Note:</b> 
	Although you can use these keywords in both C 
	and C++, use them with caution. The preferred 
	method to use with C++ is the extern "C", 
	extern "FORTRAN" or extern "Pascal" 
	syntax. This will make the C++ code portable to 
	other C++ compilers. 
<p>

For example, to declare Pascal-calling conventions in C: 

<pre>
	extern int __pascal my_function(); 
</pre>

in C++: 

<pre>
	extern "Pascal" int my_function(); 
</pre>

Declaring data as __cdecl, __fortran, or __pascal influences 
how the name appears to the linker. However, the name always 
appears to the debugger as it appears in the source. __cdecl 
causes an underscore to be added to the front of the name, which is 
the default. __fortran or __pascal causes the name to convert 
to upper case. For example, the following code appears as blang to 
the linker: 

<pre>
	int __pascal blang; 
</pre>

Notice that the keyword appears immediately before the variable 
name. 
<p>

<b>Note:</b> 
	If you do not use __cdecl, __fortran, 
	__pascal, or the extern functions, the compiler 
	mangles variable names according to Microsoft 
	specifications. This deviates from the ARM 
	description, which recommends that names not be 
	mangled. 


<h3>Portability of Extended Keywords</h3>

One useful 
method of ensuring portability to other systems is by 
conditionally defining the extended keywords as empty: 

<pre>
	// Remove extended keywords for non Digital Mars
	// compilers 

	#if !defined(__DMC__)
	#define __cdecl 
	#define __pascal
	#define __fortran 
	#endif 
</pre>

<b>Note:</b> 
	In general, function pointers can cause subtle problems when the 
	function pointed to is not the compiler's default type. The rule to 
	remember is that the extended keyword must appear immediately 
	before the *, which determines that the type is a function pointer. 
	The correct syntax for declaring a pointer to a 
	Pascal function is: 

<pre>
	int (__pascal *fp)(void); 
</pre>


<br><br><br><br>

</td></table>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

