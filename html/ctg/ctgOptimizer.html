
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - Optimizing Code
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:25:45 2006
</div>
</div>

<!-- Generated by Ddoc from ctgOptimizer.d -->



<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ctg">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>
</center>

    <a href="ctg.html"><b>Compiler & Tools Guide</b></a><br>

<hr><b>Compiling</b><br>

    &#149; <a href="ctgCompilingCode.html">Compiling Code</a><br>
    &#149; <a href="C-Language-Implementation.html">C Implementation</a><br>
    &#149; <a href="CPP-Language-Implementation.html">C++ Implementation</a><br>
    &#149; <a href="ctgLanguageImplementation.html">Language Extensions</a><br>
    &#149; <a href="ctgMixingLanguages.html">Mixing Languages</a><br>
    &#149; <a href="ctgAsm.html">Assembly Language</a><br>
    &#149; <a href="ctgInlineAsm.html">Inline Assembler</a><br>
    &#149; <a href="ctgOptimizer.html">Optimizing Code</a><br>
    &#149; <a href="ctgNumerics.html">Numerics Programming</a><br>
    &#149; <a href="regular.html">Regular Expressions</a><br>
    &#149; <a href="acrtused.html">Acrtused</a><br>
    &#149; <a href="pragmas.html">Pragmas</a><br>
    &#149; <a href="precompiled.html">Precompiled Headers</a><br>
    &#149; <a href="predefined.html">Predefined Macros</a><br>
    &#149; <a href="warnings.html">Warning Messages</a><br>
    &#149; <a href="ctgCompilerErrors.html">Error Messages</a><br>
    &#149; <a href="warnings.html#runtime">Runtime Messages</a><br>
    <br>

<hr><b>Linking</b><br>

    &#149; <a href="optlink.html">Optlink</a><br>
    &#149; <a href="ctgLinkSwitches.html">Switches</a><br>
    &#149; <a href="ctgDefFiles.html">Module Definition Files</a><br>
    &#149; <a href="ctgLinkOps.html">Operation and Design</a><br>
    &#149; <a href="OptlinkErrorMessages.html">Error Messages</a><br>
    <br>

<hr><b>Win32 Programming</b><br>

    &#149; <a href="win32programming.html#win32">Win32 Programming</a><br>
    <br>

<hr><b>DOS and Win16<br>Programming</b><br>

    &#149; <a href="ctgMemoryModel.html">Memory Models</a><br>
    &#149; <a href="pointers16.html">16 Bit Pointer Types<br> and Type Modifiers</a><br>
    &#149; <a href="win32programming.html#handle">Handle Pointers</a><br>
    &#149; <a href="win32programming.html#dos">DOS</a><br>
    &#149; <a href="dos32.html">DOS 32 (DOSX)</a><br>
    &#149; <a href="win32programming.html#win16">Win16</a><br>
    &#149; <a href="win32programming.html#win16dll">Win16 DLLs</a><br>
    &#149; <a href="windowspe.html">Win16 Prolog/Epilog</a><br>
    <br>

<hr><b>C/C++ Extensions</b><br>

    &#149; <a href="contract.html">Contract Programming</a><br>
    &#149; <a href="debugstatement.html">__debug statement</a><br>
    &#149; <a href="debugstatement.html#debugdeclaration">__debug declaration</a><br>
    &#149; <a href="trace.html">Dynamic Profiling</a><br>
    &#149; <a href="html.html">Embedding C in HTML</a><br>
    <br>

<hr><b>Tools</b><br>

    &#149; <a href="bcc.html" title="Convert Borland compiler commands">BCC</a><br>
    &#149; <a href="chmod.html" title="Examine and change file attributes">CHMOD</a><br>
    &#149; <a href="cl.html" title="Convert Microsoft compiler commands">CL</a><br>
    &#149; <a href="coff2omf.html" title="Convert COFF .obj and .lib to OMF">COFF2OMF</a><br>
    &#149; <a href="coffimplib.html" title="Convert COFF import library OMF">COFFIMPLIB</a><br>
    &#149; <a href="sc.html" title="Compiler command">DMC</a><br>
    &#149; <a href="diff.html" title="Compare files">DIFF</a><br>
    &#149; <a href="diffdir.html" title="Compare directories">DIFFDIR</a><br>
    &#149; <a href="dump.html" title="Dump files in hex">DUMP</a><br>
    &#149; <a href="dumpobj.html" title="Dump object files in hex">DUMPOBJ</a><br>
    &#149; <a href="dumpexe.html" title="Dump exe files">DUMPEXE</a><br>
    &#149; <a href="exe2bin.html" title="Create .com files">EXE2BIN</a><br>
    &#149; <a href="flpyimg.html" title="Read/Write Floppy Image">FLPYIMG</a><br>
    &#149; <a href="grep.html" title="Search files for string">GREP</a><br>
    &#149; <a href="ctgHelp.html" title="Creating Help Tools">HC</a><br>
    &#149; <a href="implib.html" title="Build import libraries">IMPLIB</a><br>
    &#149; <a href="lib.html" title="Object file librarian">LIB</a><br>
    &#149; <a href="libunres.html" title="Analyze library and object files">LIBUNRES</a><br>
    &#149; <a href="make.html" title="Simple make utility">MAKE</a><br>
    &#149; <a href="makedep.html" title="Update makefile dependencies">MAKEDEP</a><br>
    &#149; <a href="me.html" title="MicroEmacs Text Editor">ME</a><br>
    &#149; <a href="obj2asm.html" title="Object file disassembler">OBJ2ASM</a><br>
    &#149; <a href="patchobj.html" title="Patch object files">PATCHOBJ</a><br>
    &#149; <a href="ctgRC.html" title="Microsoft Resource compiler">RC</a><br>
    &#149; <a href="rcc.html" title="Digital Mars Resource compiler">RCC</a><br>
    &#149; <a href="sc.html" title="Compiler command">SC</a><br>
    &#149; <a href="shell.html" title="Shell scripts">SHELL</a><br>
    &#149; <a href="smake.html" title="Manage complex projects">SMAKE</a><br>
    &#149; <a href="touch.html" title="Set file timestamps">TOUCH</a><br>
    &#149; <a href="unmangle.html" title="Format C++ mangled names">UNMANGLE</a><br>
    &#149; <a href="whereis.html" title="Search for files">WHEREIS</a><br>
    <br>

<hr><b>Porting to DMC++</b><br>

    &#149; <a href="switchtodigitalmars.html">Switching to DMC++</a><br>
    &#149; <a href="switchtodigitalmars.html#microsoft">from Microsoft</a><br>
    &#149; <a href="switchtodigitalmars.html#borland">from Borland</a><br>
    &#149; <a href="ctgPorting.html">Porting Guide</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">

<h1>Optimizing Code</h1>

Optimizers modify compiled code to make it more efficient.
This chapter describes how the Digital Mars global optimization
feature works and how to use it to produce faster and smaller programs. 
<p>

What's in This Chapter:

<ul>
	<li> What global optimization is, and how it differs from local 
	optimization. 
	<li> When and how to use the global optimization feature. 
	<li> Global optimizer options in alphabetical order. 
	<li> Hints and tips for maximizing the efficiency of 
	optimization. 
</ul>

<h3>About Global Optimization</h3>

A global optimizer (as opposed to a local optimizer) analyzes and 
optimizes all the code for a function as a whole. Local optimizers 
look at only one statement at a time or at short sequences of 
statements. A global optimizer uses a powerful technique called 
"data flow analysis" to gather information about each function. The 
more an optimizer knows about a function, the more optimizations 
that are possible. This technique is why global optimizers improve 
code more than local optimizers do. 


<h3>Advantages of using the global optimization feature</h3>

You can tune most C and C++ programs to a particular machine, and 
the global optimization feature does few transformations that you 
cannot duplicate at the source level. However, this kind of fine-tuning 
is usually not appropriate because: 

<ul>
	<li> Tuning code takes time. Compilers are meant to allow 
	programmers to be more productive, and global 
	optimization largely eliminates the need to tune programs 
	by hand. 

	<li> Cryptically tuned code is harder to maintain. 

	<li> Code that is tuned for one machine may turn out to be 
	poorly tuned for another. A widely applicable example of 
	this problem is the fact that different compilers support 
	different register values. 

	<li> Digital Mars C++ uses simple methods to expand inline 
	functions, relying on the global optimization feature to 
	"fix" them into more acceptable code. 

	<li> C++ is one of the few languages that permits implicit 
	promotion of user-defined types; global optimization 
	helps clean up the resulting temporary variables. 
</ul>

<h3>When to use the global optimization feature</h3>

Global optimization slows compilation but is a highly effective 
timesaver on frequently executed programs. Optimization also 
moves code to the extent that some of the correlation between 
source and object code is lost. Therefore, do not use global 
optimization in conjunction with the debugger. 


<h3>Effects of optimization on performance</h3>

Typical computation-bound programs can speed up as much as 30 
percent when optimized. I/O-bound programs may not speed up at 
all. The most dramatic speed improvements are in small, frequently 
executed loops. Speed improves least in code that consists primarily 
of function calls. 


<h3>Optimization versus assembly language code</h3>

Globally optimized code still does not run nearly as efficiently as 
carefully crafted assembly language code. One reason is that the as-sembly 
language programmer knows more about the algorithm than 
the compiler knows. The compiler always optimizes conservatively, 
to ensure safe optimizations. However, you may not have time to 
carefully craft an entire program or program component in assembly 
language; an optimizing compiler then offers the most cost-effective 
solution. 


<h3>What global optimization does not do</h3>

Global optimization does not replace inefficient algorithms with 
efficient ones. It cannot recognize a bubble sort and replace it with a 
quick sort. Regardless of how good a compiler might be, improving 
the algorithm often produces the most dramatic increases in 
execution speed. 


<h3>Optimizing for Windows</h3>

All global optimization methods are safe for use with code that runs 
on any version of Microsoft Windows. 
Using the Global Optimization Feature To use the global optimization feature, specify the -o option to SC. 
<p>

For example, 

<pre>
	sc demo.c -o 
</pre>
means compile and optimize demo.c. 
<p>

To optimize from the IDDE, use the Code Optimization subpage 
on the Build page of the Project Settings dialog box. 


<h3>Using Optimization Flags</h3>

The -o option without specifying any modifiers defaults
to optimizing for program speed.
<p>

<b>Note:</b> The scppn.exe compiler pass uses -o to specifiy the
output file, not optimization. This can be confusing, but there is
generally no need to run scppn.exe independently.

<h3>Optimizing for speed vs. space</h3>

When space is at a premium, you can change the default of "speed 
over space" to "space over speed," like this: 

<pre>
	sc demo.c -o+space 
</pre>

This command compiles demo.c with all optimizations applied; the 
speed optimization is turned off, and the space optimization is 
turned on. For information about what speed and space 
optimizations do, see "Space/speed tradeoffs" later in this chapter. 


<h3>Turning off all optimization methods</h3>

To turn all optimizations off, use the flags -o-all or -o+none. The 
-o+all and -o-none flags are equivalent to -o. 
For example: 

<pre>
	sc demo.c -o+none 
</pre>

compiles demo.c without performing global optimization. 


<h3>Turning off specific optimization methods</h3>

If you must explicitly disable specific methods, do so by first turning 
on all methods with -o and then disabling individual methods one 
at a time with -flag. For example: 

	sc demo.c -o-cnp -o-cp 

performs all optimizations except "constant propagation" and "copy 
propagation." 

<h4>Note:</h4> 
	You cannot turn on individual optimization 
	methods. 


<h3>List of global optimization flags</h3>

The table below lists all the optimization flags. Complete 
descriptions of each flag follow the table. 

<dl><dl>
	<dt><b>all</b> <dd>Perform all optimizations 
	<dt><b>cnp</b> <dd>Constant propagation 
	<dt><b>cp</b> <dd>Copy propagation 
	<dt><b>cse</b> <dd>Global common subexpressions elimination 
	<dt><b>da</b> <dd>Dead assignment elimination 
	<dt><b>dc</b> <dd>Dead code elimination 
	<dt><b>dv</b> <dd>Dead variable elimination; compute live ranges 
	<dt><b>li</b> <dd>Loop invariant removal 
	<dt><b>liv</b> <dd>Loop induction variable replacement 
	<dt><b>loop</b> <dd>Iterate until optimizations have no further effect 
	<dt><b>none</b> <dd>Do no optimizations 
	<dt><b>reg</b> <dd>Assign variables to registers where possible 
	<dt><b>space</b> <dd>Favor space optimizations over execution speed optimizations 
	<dt><b>speed, time</b> <dd>Favor execution speed (time) optimizations over space 
	optimizations 
	<dt><b>vbe</b> <dd>Very busy expressions 
	<dt><b>w</b> <dd>Turn on warnings 
</dl></dl>


<b>all</b> Turns on every optimization except space. The flags none and 
    all are mutually exclusive; +all is equivalent to -none (shutting 
    off none). Use +all to optimize your code to the fullest extent. 
<p>

<b>cnp</b> replaces certain variables with constants. Consider the code: 

<pre>
	A = 5;
	for (i = 0; i &lt; A; i++) 
	    abc[i] = A; 
</pre>

A always has the value 5 within the loop body. To optimize, the 
compiler replaces A with its value: 

<pre>
	A = 5;
	for (i = 0; i &lt; 5; i++) 
	    abc[i] = 5; 
</pre>

Constant propagation opportunities frequently occur when loop 
rotation is done. For example, constant propagation converts: 

<pre>
	while (e)
	    expression; 
</pre>

to: 

<pre>
	if (e)
	    do 
		expression;
	    while (e) 
</pre>


<b>cp</b> Copy propagation is similar to constant propagation, except it copies 
variables instead of constants. For example, it replaces: 

<pre>
	A = b;
	for (i = 0; i &lt; A; i++) 
	    abc[i] = A; 
</pre>

with:

<pre>
	A = b;
	for (i = 0; i &lt; b; i++) 
	    abc[i] = b; 
</pre>

Copy propagation frequently uncovers unnecessary assignments, 
such as the assignment to A, that can be removed. 
<p>

<b>cse</b> 
Common subexpression elimination removes redundant 
computations. For example: 

<pre>
	plus10 = A + B + 10;
	minus10 = A + B - 10; 
	tang = (A + B) / cos(B); // A + B is computed three times 
</pre>

becomes: 

<pre>
	T = A + B;
	plus10 = T + 10; 
	minus10 = T - 10;
	tang = T / cos(B);	// A + B is computed once 
</pre>

<b>da</b>
Eliminates assignments to variables that have no further use. For 
example: 

<pre>
	int abc()
	{   int f; 
	    static int g = 0; 
	    if (g != 3) 
	    {	f = 3; // A dead assignment to f 
		g = 3; // Not a dead assignment
	    } 
	}
</pre>

<b>dc</b> 
Dead code is code that can never execute. Sometimes dead code is 
subtle: 

<pre>
	#define VALUE 0
	if (VALUE &gt; 10) 
	    a = dead + code; // This statement is dead 
</pre>

<b>dv</b> 
Dead variables are automatic variables that are declared but never 
used. They often result from other optimizations. The live range of a 
variable is that portion of a function in which the variable's value 
must be preserved. If the live range is zero, the variable is dead. If 
two or more variables have nonintersecting live ranges, they can 
occupy the same memory location. 
<p>

When allocating a large number of variables into a fixed number of 
registers, the compiler figures the live range of each register and 
compares it with the live range of the corresponding variable. If they 
do not intersect, the compiler assigns the variable to that register. 
<p>

<b>li</b> 
If an expression appears in a loop body but its result never changes, 
then it is a loop invariant, and the compiler can remove its 
computation from the loop. For example: 

<pre>
	while (f()) // b * c is loop invariant
	    g(b * c); 
</pre>

becomes: 

<pre>
	T = b * c;
	while (f()) 
	    g(T); 
</pre>


<b>liv</b> 
Loop invariant removal makes loops faster, especially those that cycle 
through an array. It can make code slightly larger, however. For 
example: 

<pre>
	int a[ARRAY_SIZE], i; 

	for (i = 0; i &lt; ARRAY_SIZE; i++)
	    a[i] = GetNextElement(); 
</pre>


Without this optimization, your code has to perform a multiplication 
each time it figures the address for the next array element 
(i * sizeof( int)). With the optimization, it remembers the 
address of the last element and adds the size of an element to that 
address. 
<p>

<b>loop</b> 
Performing many optimizations makes further optimizations 
possible. This switch tells the compiler to continue until it discovers 
no further optimizations. 
<p>

<b>none</b> 
The none switch shuts off all optimizations, which is the same as 
not using the optimization feature. The none and all 
optimizations are mutually exclusive; +none is equal to -all 
(shutting off all). 
<p>

<b>reg</b> 
reg puts as many variables in registers as possible. Variables are 
assigned to registers based on how often they are used and how 
deeply nested in loops they are. 
<p>

Using the register storage class is unnecessary when you use the 
global optimization feature. However, the compiler honors all such 
declarations in your code. 
<p>

<b>space</b>
<b>speed/time</b> 
Sometimes you must choose whether you want your code to run 
faster or to take up a minimal amount of memory. One specific 
example is: 

<pre>
	while (f())
	    g(); 
</pre>

When optimized for space, the above example becomes: 

<pre>
	goto L1;
	do 
	{   g(); 
	L1:;
	} while (f()); 
</pre>

When optimized for speed, the example becomes: 

<pre>
	if (f())
	{ 
	    do
		g(); 
	    while(f());
	} 
</pre>

<b>Note:</b> 
	If you don't specify +space, the compiler defaults 
	to optimizing for speed. 
<p>

The speed and space flags are mutually exclusive: 

<pre>
	-o-speed is the same as -o+space 
	-o-space is the same as -o+speed 
</pre>

<b>vbe</b>
Very busy expressions occur along more than one path in the flow 
graph: 

<pre>
	if (condition)
	    a = b * c; 
	else
	    d = b * c; 
</pre>


Here b * c is a very busy expression. The optimization is: 

<pre>
	T = b * c;
	if (condition) 
	    a = T;
	else 
	    d = T; 
</pre>

This optimization only saves space; it does not increase execution 
speed. 


<h3>Optimization Tips</h3>

Here are some ideas to keep in mind when you use the global 
optimization feature. 


<h3>Use of const and volatile keywords</h3>

The const keyword defines a variable that is never modified, so the 
compiler does not have to make worst-case assumptions about that 
variable's changing. 
<p>

The volatile keyword tells the compiler that the variable can 
change asynchronously and never "optimizes out" loads and stores 
to volatile variables. 
<p>

You can use the const keyword for static tables and the volatile 
keyword for hardware locations (like low-memory globals) and data 
that could change when an interrupt occurs. 
<p>

Example: 

<pre>
	const static int a = 5, b[3] = { 1,2,7 };
	extern volatile bool flag; 
</pre>

<h3>If a working program fails when optimized</h3>

The compiler uses a strict interpretation of the definition of the C++ 
language and strives to conform to it. However, some aspects of C++ 
are undefined, and the compiler may interpret the same code 
differently, depending on whether optimization is performed. Some 
reasons that code may behave differently when optimized include: 


<ul>
	<li> The code is dependent on the order of evaluation of side 
	effects. For example: 

	<pre>
	a = f1() + f2(); 
	</pre>

	Whether f1() or f2() is executed first is undefined. 
	You can control the order of evaluation by using explicit 
	temporary variables, such as: 


	<pre>
	tmp = f1(); 
	a = tmp + f2(); 
	</pre>

	Now the evaluation order is guaranteed. 

	<li> The code is dereferencing uninitialized pointers. Since the 
	compiler rearranges the physical allocation of variables 
	when it optimizes code, uninitialized variables can 
	contain different values. 

	<li> The code is storing data past the end or before the 
	beginning of arrays or storing data allocated with 
	unsuccessful calls to new or malloc(). 

	<li> The code refers to data freed with realloc() 
	or free(). 

	<li> A variable that could be modified at the interrupt level is 
	not declared with a volatile storage class modifier. 
</ul>

Recompiling code with the global optimization feature can uncover 
problems similar to those encountered when porting to another 
compiler. Adherence to standard "portable" coding practices 
minimizes any problems encountered when using the optimization 
feature. 


<br><br><br><br>

</td></table>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

