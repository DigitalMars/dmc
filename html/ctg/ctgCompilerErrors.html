
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - Compiler Error Messages
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:25:45 2006
</div>
</div>

<!-- Generated by Ddoc from ctgCompilerErrors.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ctg">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>
</center>

    <a href="ctg.html"><b>Compiler & Tools Guide</b></a><br>

<hr><b>Compiling</b><br>

    &#149; <a href="ctgCompilingCode.html">Compiling Code</a><br>
    &#149; <a href="C-Language-Implementation.html">C Implementation</a><br>
    &#149; <a href="CPP-Language-Implementation.html">C++ Implementation</a><br>
    &#149; <a href="ctgLanguageImplementation.html">Language Extensions</a><br>
    &#149; <a href="ctgMixingLanguages.html">Mixing Languages</a><br>
    &#149; <a href="ctgAsm.html">Assembly Language</a><br>
    &#149; <a href="ctgInlineAsm.html">Inline Assembler</a><br>
    &#149; <a href="ctgOptimizer.html">Optimizing Code</a><br>
    &#149; <a href="ctgNumerics.html">Numerics Programming</a><br>
    &#149; <a href="regular.html">Regular Expressions</a><br>
    &#149; <a href="acrtused.html">Acrtused</a><br>
    &#149; <a href="pragmas.html">Pragmas</a><br>
    &#149; <a href="precompiled.html">Precompiled Headers</a><br>
    &#149; <a href="predefined.html">Predefined Macros</a><br>
    &#149; <a href="warnings.html">Warning Messages</a><br>
    &#149; <a href="ctgCompilerErrors.html">Error Messages</a><br>
    &#149; <a href="warnings.html#runtime">Runtime Messages</a><br>
    <br>

<hr><b>Linking</b><br>

    &#149; <a href="optlink.html">Optlink</a><br>
    &#149; <a href="ctgLinkSwitches.html">Switches</a><br>
    &#149; <a href="ctgDefFiles.html">Module Definition Files</a><br>
    &#149; <a href="ctgLinkOps.html">Operation and Design</a><br>
    &#149; <a href="OptlinkErrorMessages.html">Error Messages</a><br>
    <br>

<hr><b>Win32 Programming</b><br>

    &#149; <a href="win32programming.html#win32">Win32 Programming</a><br>
    <br>

<hr><b>DOS and Win16<br>Programming</b><br>

    &#149; <a href="ctgMemoryModel.html">Memory Models</a><br>
    &#149; <a href="pointers16.html">16 Bit Pointer Types<br> and Type Modifiers</a><br>
    &#149; <a href="win32programming.html#handle">Handle Pointers</a><br>
    &#149; <a href="win32programming.html#dos">DOS</a><br>
    &#149; <a href="dos32.html">DOS 32 (DOSX)</a><br>
    &#149; <a href="win32programming.html#win16">Win16</a><br>
    &#149; <a href="win32programming.html#win16dll">Win16 DLLs</a><br>
    &#149; <a href="windowspe.html">Win16 Prolog/Epilog</a><br>
    <br>

<hr><b>C/C++ Extensions</b><br>

    &#149; <a href="contract.html">Contract Programming</a><br>
    &#149; <a href="debugstatement.html">__debug statement</a><br>
    &#149; <a href="debugstatement.html#debugdeclaration">__debug declaration</a><br>
    &#149; <a href="trace.html">Dynamic Profiling</a><br>
    &#149; <a href="html.html">Embedding C in HTML</a><br>
    <br>

<hr><b>Tools</b><br>

    &#149; <a href="bcc.html" title="Convert Borland compiler commands">BCC</a><br>
    &#149; <a href="chmod.html" title="Examine and change file attributes">CHMOD</a><br>
    &#149; <a href="cl.html" title="Convert Microsoft compiler commands">CL</a><br>
    &#149; <a href="coff2omf.html" title="Convert COFF .obj and .lib to OMF">COFF2OMF</a><br>
    &#149; <a href="coffimplib.html" title="Convert COFF import library OMF">COFFIMPLIB</a><br>
    &#149; <a href="sc.html" title="Compiler command">DMC</a><br>
    &#149; <a href="diff.html" title="Compare files">DIFF</a><br>
    &#149; <a href="diffdir.html" title="Compare directories">DIFFDIR</a><br>
    &#149; <a href="dump.html" title="Dump files in hex">DUMP</a><br>
    &#149; <a href="dumpobj.html" title="Dump object files in hex">DUMPOBJ</a><br>
    &#149; <a href="dumpexe.html" title="Dump exe files">DUMPEXE</a><br>
    &#149; <a href="exe2bin.html" title="Create .com files">EXE2BIN</a><br>
    &#149; <a href="flpyimg.html" title="Read/Write Floppy Image">FLPYIMG</a><br>
    &#149; <a href="grep.html" title="Search files for string">GREP</a><br>
    &#149; <a href="ctgHelp.html" title="Creating Help Tools">HC</a><br>
    &#149; <a href="implib.html" title="Build import libraries">IMPLIB</a><br>
    &#149; <a href="lib.html" title="Object file librarian">LIB</a><br>
    &#149; <a href="libunres.html" title="Analyze library and object files">LIBUNRES</a><br>
    &#149; <a href="make.html" title="Simple make utility">MAKE</a><br>
    &#149; <a href="makedep.html" title="Update makefile dependencies">MAKEDEP</a><br>
    &#149; <a href="me.html" title="MicroEmacs Text Editor">ME</a><br>
    &#149; <a href="obj2asm.html" title="Object file disassembler">OBJ2ASM</a><br>
    &#149; <a href="patchobj.html" title="Patch object files">PATCHOBJ</a><br>
    &#149; <a href="ctgRC.html" title="Microsoft Resource compiler">RC</a><br>
    &#149; <a href="rcc.html" title="Digital Mars Resource compiler">RCC</a><br>
    &#149; <a href="sc.html" title="Compiler command">SC</a><br>
    &#149; <a href="shell.html" title="Shell scripts">SHELL</a><br>
    &#149; <a href="smake.html" title="Manage complex projects">SMAKE</a><br>
    &#149; <a href="touch.html" title="Set file timestamps">TOUCH</a><br>
    &#149; <a href="unmangle.html" title="Format C++ mangled names">UNMANGLE</a><br>
    &#149; <a href="whereis.html" title="Search for files">WHEREIS</a><br>
    <br>

<hr><b>Porting to DMC++</b><br>

    &#149; <a href="switchtodigitalmars.html">Switching to DMC++</a><br>
    &#149; <a href="switchtodigitalmars.html#microsoft">from Microsoft</a><br>
    &#149; <a href="switchtodigitalmars.html#borland">from Borland</a><br>
    &#149; <a href="ctgPorting.html">Porting Guide</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">

<h1>Compiler Error Messages</h1>
 
This chapter lists and describes the error and warning messages
generated by the compiler. Use this reference to:

<ul>
	<li> Check or confirm that an error has been reported.
	<li> Discover possible causes for an error. 
	<li> Discover possible ways to correct an error. 
</ul>

Messages marked C++ are generated only by the C++ compiler (SC). 
<p>

Messages marked C are generated only by the C compiler (SC). 
<p>

Messages marked Warning indicate code that may not execute as 
you expect but that does compile. This appendix lists messages in 
alphabetical order. 
<p>

Some descriptions contain a margin note that refers to sections in 
one of these books; the sections contain information relevant to the 
cause of the error: 

<ul>
	<li> The Annotated C++ Reference Manual (ARM) (Addison-Wesley) 
	by Ellis and Stroustrup. 
	<li> The ANSI C Standard (ANSI) (X3.159). 
</ul>


<h3>What's in This Chapter</h3>


<ul>
	<li> How to recognize compiler errors. 
	<li> Types of errors. 
	<li> How to report internal errors. 
	<li> The Digital Mars C and C++ compiler error messages in 
	alphabetical order, and what each message means. 
</ul>

<h3>Recognizing Compiler Error Messages</h3>

When the compiler encounters a line in source code that it does not 
understand, it prints that line with a message. For example: 

<pre>
	a= b;
	^ 
	file.c(15) Error: undefined identifier 'a' 
</pre>

The caret (^) does not indicate what causes a problem but where the 
compiler recognizes a problem. If the caret points to a macro, try 
compiling the file using the Show Results of Preprocessor (-e 
command line option) to see which part of the macro is causing the 
error. 
<p>

The message under the caret starts with the name of the file, the line 
number where the problem occurs, and whether the message is an 
error or a warning. The rest of the message identifies what the 
compiler considers as the problem. 


<h3>Error Message Types</h3>

There are seven error message types. Each message usually contains 
specific information about the problem. 


<h3>Command line errors</h3>

Command line errors result from incorrect command line options or 
parameters. For a quick way to find an online summary of command 
line options and parameters, type sc from the DOS prompt. 


<h3>Lexical errors</h3>

Lexical errors occur when the compiler encounters an unidentified 
or incomplete token. While they do not immediately terminate 
compilation, lexical errors do prevent the compiler from generating 
executable code. An error log tracks lexical errors. 


<h3>Preprocessor errors</h3>

Errors can occur in one of the preprocessing directives. While they 
do not immediately terminate compilation, preprocessor errors can 
prevent the compiler from generating executable code. 


<h3>Syntax errors</h3>

While they do not immediately terminate compilation, syntax errors 
can prevent the compiler from generating executable code. The 
compiler normally lists four errors of the preprocessor, syntax, 
lexical types before exiting. Use the -x option to let compilation 
continue to the end of the source file before exiting with an error. 


<h3>Warnings</h3>

Warnings occur when the compiler finds a statement that is 
legitimate but probably not what you intended. Warnings are not 
errors and do not terminate compilation or prevent the compiler 
from generating code. 


<h3>Fatal errors</h3>

Fatal errors immediately terminate compilation. A typical fatal error 
occurs when the compiler runs out of memory. 


<h3>Internal errors</h3>

Internal errors, a class of fatal error, take the following form: 

<pre>
	file/line # 
</pre>

An assertion failure within the compiler generates this type of error. 
The error number is useful only in designating where in the compiler 
code the error occurs. The cause of this message may be an error in 
source code that the compiler cannot handle intelligently or a bug in 
the compiler itself. If your code generates this type of error, report it 
to Digital Mars, even if your code causes the error. Reporting the 
problem enables Digital Mars to improve error reporting in future 
releases. 

<h3>How to report an internal error</h3>

Before reporting an internal error to technical support, try to isolate 
the error in a small program fragment. Use the following procedure: 

<ol>
	<li> Place all included code into the main program body 
	using the -e -l options on the command line. 

	<li> Turn on the -v option for the compiler. This lets you 
	determine which function causes the problem. 

	<li> Find the approximate cause of the error by backtracking 
	and removing excess code to isolate a short program that 
	demonstrates the fault. 

	<li> Use mnemonic names for objects and variables in the 
	sample code. Code containing class Base rather than 
	class Hyperxytrisms59 is much easier for the 
	technical support staff to understand. 

	<li> If applicable, put the offending code in an 
	#ifdef BUG .. #endif block. 

	<li> Write a comment header with the following information: 
	your name, telephone number, address, version of 
	compiler and linker as well as any other software 
	involved, the nature of the problem, and any other 
	relevant details. 
</ol>


A short bug report lets the technical support staff quickly find the 
problem. 

<h3>C and C++ Compiler Error Messages</h3>

This is a list of error messages the compiler may generate. 
Remember, only the C++ compiler generates messages marked C++ 
and only the C compiler generates messages marked C. Only the 
Inline Assembler generates messages marked Inline Assembler. 

<h4>'<i>identifier</i>' is a member of '<i>identifier</i>' and '<i>identifier</i>' </h4>

Inline Assembler. The member appears in more than one struct; 
you need to specify which is correct. 


<h4>'<i>identifier</i>' is a pure virtual function </h4>

C++. The compiler cannot directly call a pure virtual function. 


<h4>'<i>identifier</i>' is already defined </h4>

The object is already declared. 

<h4>'<i>identifier</i>' is a virtual base class of '<i>identifier</i>' </h4>

C++. You cannot convert a pointer to a virtual base class into a 
pointer to a class derived from it. Also, you cannot create a pointer 
to a member of a virtual base class. For example: 

<pre>
	class virtual_class
	{ public: 
	    int x;
	}; 

	class sub_class : virtual public virtual_class { }; 

	void main()
	{   
	    virtual_class *v;
	    sub_class *s; 
	    int virtual_class::*i; 
	    s = (sub_class *) v;	// error
	    i = &sub_class::x; 
	}
</pre>

<h4>'<i>identifier</i>' is far </h4>

C++. A near reference cannot apply to far data. 


<h4>'<i>identifier</i>' is not a class template </h4>

C++. The compiler expects to find the name of a class template but 
doesn't find one. If you are declaring a template member function, 
make sure the function's class name is a template. If you use a type 
of the form foo&lt; bar&gt;, make sure you declare as a template the 
class name before the less-than sign. 


<h4>'<i>identifier</i>' is not a constructor </h4>

C++. You can use a member initialization list only when you're 
defining base constructors and member initializers. For example: 

<pre>
	struct base { base(int); };
	struct other { other(int); }; 

	class sub : base
	{ sub(int); // A constructor. 
	  sub2(int); // Just a method.
	  other o; 
	}; 

	sub::sub(int a) : o(a), base(a) { }// OK
	sub::sub2(int a): o(a), base(a) { }// ERROR 
</pre>

See ARM 12.6.2 for more information. 


<h4>'<i>identifier</i>' is not a correct struct, union or enum tag identifier </h4>

The struct, union, or enum includes invalid characters or is 
already defined. 


<h4>'<i>identifier</i>' is not a member of enum '<i>identifier</i>' </h4>

member identifier is not a member of this enum. Make sure to 
correctly spell the member name and that the member actually 
belongs to the enum with which you're using it. 


<h4>'<i>identifier</i>' is not a member of struct '<i>identifier</i>' </h4>

The member identifier is not a member of this class, struct or 
union. Make sure to correctly spell the member name and that the 
member actually belongs to the struct with which you're using it. 
If the member is for a different struct but you want to use it with 
this struct anyway, cast the struct. Also check for a class 
member function that is forward referenced. For example: 


<pre>
	class X; // Forward reference
	class Y { // Declaration 
	    void g();
	    /* . . . */ 
	}; 
	class Z {
	    friend void X::f();	// ERROR 
	    friend void Y::g();	// OK
	}; 
</pre>

See ARM 11.4 for more information 


<h4>'<i>identifier</i>' is not a member of forward referenced struct '<i>identifier</i>' </h4>

You need to define a struct before referencing its members. 


<h4>'<i>identifier</i>' is not a struct or a class </h4>

C++. You can derive new classes only from a class or a struct. 
It is not possible, for instance, to derive a class from a union. 


<h4>'<i>identifier</i>' is not in function parameter list </h4>

The parameter identifier is not listed as a parameter to the function 
in the function definition. 


<h4>'<i>identifier</i>' is not a variable </h4>

The identifier is not declared as a variable. Make sure you spell the 
name correctly. 


<h4>'<i>identifier</i>' must be a base class </h4>

C++. When naming a member of a base class in a derived class 
declaration, qualify the member with a base class identifier. For 
example: 

<pre>
	class other;
	class base
	{   
	    private: /* . . . */ 
	}; 
	class sub : base
	{   public: 
		other::a; // ERROR: other must be a
		/* ... */ // base class of sub. 
	};
</pre>


<h4>'<i>identifier</i>' must be a class name preceding '::' </h4>

C++. The identifier before the double colon operator must be either 
a class, a struct, or a union. 


<h4>'<i>identifier</i>' must be a public base class of '<i>identifier</i>' </h4>

C++. When you use the syntax p-&gt;class::member, class must be a 
public base class member of the class to which p is referring. For 
example: 

<pre>
	class public_base
	{   public: 
		int x;
	}; 

	class other_class
	{   public: 
		int z;
	}; 

	class sub : public public_base
	{   /* ... */ 
	};

	void main()
	{   
	    sub *s;
	    s-&gt;public_base::x = 1; // OK 
	    s-&gt;other_class::z = 1; // ERROR
	} 
</pre>


<h4>'<i>identifier</i>' previously declared as something else </h4>

You previously declared the identifier as another type. For example, 
you may have used a function without declaring it, so the compiler 
automatically declares it as a function returning an int. Now you 
declare that function to be something else. 


<h4>identifier storage class is illegal in this context </h4>

Check for one of the following: 

<ul>
	<li> You declared a template outside the global scope. 
	<li> You declared a function argument static or extern. 
	<li> You used an auto or register variable with global 
	scope.
</ul> 

<pre>
	register int global;	// ERROR: Can't declare global 
				// variable as register. 
	void f()
	{
	    template&lt;class T&gt; T ave(T* a, int size)
	    {   
		// ERROR: Can't declare template // in a function. 
	    }
	    /* ... */ 
	} 
</pre>

See ARM 14.1 for more information. 


<h4>number actual arguments expected for identifier, had number </h4>

Warning. The compiler expects a different number of arguments for 
the function or template. You may be incorrectly using the function, 
or you may be calling a function with a variable number of 
arguments without including its header file. 


<h4>number exceeds maximum of number parameters </h4>

The compiler does not support macros with more than 251 
parameters. 


<h4>number operands expected for the identifier instruction </h4>

Inline Assembler. The instruction includes an incorrect number of 
operands. 


<h4>':' expected </h4>

The compiler expects a colon after a constant expression in a case 
statement and after the keywords public, private, and 
protected in a class declaration. 


<h4>'::' or '(' expected after class '<i>identifier</i>' </h4>

C++. The compiler expects two colons or an open parenthesis after a 
class name in an expression. Casting, however, does not allow two 
colons. For example: 

<pre>
	class x;
	f= *(x*)y; 
</pre>


<h4>';' expected </h4>

The compiler expects a semicolon at the end of a statement. 


<h4>',' expected </h4>

Make sure parameters are separated by commas. 


<h4>']' expected </h4>

The compiler expects a close bracket at the end of an array 
declaration or reference. 


<h4>'(' expected </h4>

The compiler expects the expression after the if, while, or for 
keywords to be enclosed in parentheses. 


<h4>')' expected </h4>

The compiler expects a set of parentheses to be closed. Check for a 
pair of mismatched parentheses or a bad expression. 


<h4>'{' expected </h4>

The compiler expects an open brace. 


<h4>'}' expected</h4>

The compiler expects a close brace. 


<h4>'{' or tag identifier expected </h4>

The compiler expects a tag name or an open brace to follow the 
keywords struct, class, union, and enum. 


<h4>'=', ';' or ',' expected </h4>

A variable is declared incorrectly. A declaration, must include an 
equals sign, a semicolon, or a comma after the variable name. 


<h4>// comments are not ANSI C </h4>

C. The Enforce ANSI Compatibility option in the IDDE (the -A 
command line option) is on, but the 
program is using C++ style comments. C++-style comments begin 
with two slashes. 


<h4>## cannot appear at beginning or end </h4>

The double-number sign operator cannot appear at the beginning or 
end of a list of tokens. The operator must be between two tokens. 
For example, a ## b. 
<p>

See ANSI 3.8.3.3 for more information. 


<h4># must be followed by a parameter </h4>

The number sign operator must appear only in front of a macro 
parameter. For example, #c. 
<p>

See ANSI 3.8.3.2 for more information. 


<h4>'#else' or '#elif' found without '#if' </h4>

More #else or #elif preprocessor directives appear than 
preceding #if, #ifdef, or #ifndef directives. 


<h4>'#endif' found without '#if'</h4>

More #endif preprocessor directives appear than preceding #if, 
#ifdef, or #ifndef directives. 


<h4>#include &lt;typeinfo.h&gt; in order to use RTTI </h4>

To compile with run-time type identification, you need to include 
the &lt;typeinfo.h&gt; header file. 


<h4>#pragma pack(pop) does not have corresponding push </h4>

Every #pragma pack(pop) directive requires a corresponding 
#pragma pack(push) directive. 


<h4>'&lt;' expected following cast </h4>

C++. A type id enclosed in angle brackets (&lt;&gt;) is expected following 
static_cast, const_cast, reinterpret_cast, or 
dynamic_cast. 
<p>

See ARM 5.2 for more information. 


<h4>'&lt;' expected following '<i>identifier</i>' </h4>

C++. In a class or function template, the argument list must be 
between angle brackets. 
<p>

See ARM 14.1 for more information. 


<h4>'&gt;' expected </h4>

A type id enclosed in angle brackets (&lt;&gt;) is expected following 
static_cast, const_cast, reinterpret_cast, or 
dynamic_cast. 
<p>

See ARM 5.2 for more information. 


<h4>0 expected </h4>

C++. A pure virtual function is declared incorrectly. The following is 
the syntax for a pure virtual function: 


<pre>
	class X
	{   virtual pure_virtual_func() = 0; // OK 
	    /* ... */
	}; 
</pre>


<h4>0 or 1 expected </h4>

Only binary digits can follow the characters 0b. No spaces should be 
between the b and the number. 


<h4>a '...' handler must be the last one for a try-block </h4>

C++. catch(...) must appear as the last catch in a list of catch 
handlers for a try-block. 
<p>

See ARM 15.3 for more information. 


<h4>a catch must follow a try-block </h4>

C++. The syntax for a catch is: 

<pre>
	try { statements } catch (exception-decl) { statements } 
</pre>

See ARM 15.1 for more information. 


<h4>access declaration must be in public or protected section </h4>

C++. A class member's access can change only if that class member 
is in a public or protected section. For example: 


<pre>
	class base
	{   int a; 
	  public:
	    int x; 
	}; 

	class sub : private base
	{   base::a; // ERROR 
	  public:
	    base::x; // OK: x is public 
	}; 
</pre>


<h4>a derived class member has the same name identifier </h4>

C++. A base member's access cannot change when a derived class 
defines a member with the same name. For example: 


<pre>
	class base
	{ public: 
	    int x, y;
	    /* ... */ 
	}; 

	class sub : base
	{ public: 
	  void x();
	  base::x; // ERROR: same name as x() 
	  base::y; // OK
	}; 
</pre>

See ARM 11.3 for more information. 


<h4>alignment must be a power of 2 </h4>

Alignment for structure members must be 1, 2, 4, 8, and so on. 


<h4>alloca() cannot be used in Windows functions </h4>

The alloca() function requires the setup of a special stack frame. 
That frame conflicts with the stack frames that Windows requires. 


<h4>already seen initializer for '<i>identifier</i>' </h4>

C++. Either more than one member-initializer for the identifier exists, 
or more than one initializer for the base class exists. For example: 

<pre>
	class base
	{   int x; 
	    base(int);
	}; 

	class sub : base
	{   base b; 
	    sub(int);
	}; 

	sub::sub(int a) :
		base(a + 1),	// OK
		b(a * 2),	// OK 
		base(a - 2)	// ERROR
	{
	    x = a;
	} 
</pre>


<h4>ambiguous reference to base class '<i>identifier</i>' </h4>

C++. This class has more than one base class, and it is not clear to 
which the program is referring. 
<p>

See ARM 11.3 for more information. 


<h4>ambiguous reference to function </h4>

C++. In calling an overloaded function, more than one definition of 
the function matches the call. For example: 

<pre>
	struct X
	{   X(int); 
	}; 

	struct Y
	{   Y(int); 
	}; 

	void f(X); // f() can take an argument of
	void f(Y); // either type X or type Y. 

	void main()
	{   
	    f(1); // ERROR: Ambiguous,
		  // f(X(1)) or f(Y(1))? 
	    f(X(1)); // OK
	    f(Y(1)); // OK 
	} 
</pre>

<h4>ambiguous type conversion </h4>

C++. The compiler cannot find an unambiguous type conversion. 
For example: 


<pre>
	struct X
	{   operator int(); 
	    operator void*();
	}; 

	void main()
	{   
	    X x; 
	    if (x)
		; // ERROR
	    if ((int) x)
		; // OK 
	    if ((void*) x)
		; // OK
	} 
</pre>


<h4>argument of type '<i>identifier</i>' to copy constructor </h4>

C++. Copy constructors for class X cannot take an argument of type 
X. Instead, use the reference to X. 
<p>

See ARM 12.1 for more information. 


<h4>argument to postfix ++ or --must be int </h4>

C++. Only declarations of the following form can declare overloaded 
functions for the prefix and postfix operators ++ and --: 

<pre>
	operator ++()
	operator ++(int) 
	operator --()
	operator --(int) 
</pre>

See ARM 13.4.7 for more information. 


<h4>array dimension must be &gt; 0 </h4>

A negative number or zero cannot act as an array dimension when 
declaring an array. 
<p>

See ANSI 3.5.4.2 for more information. 


<h4>array of functions is illegal </h4>

An array of pointers to functions, not an array of functions, can be 
declared. For example, instead of this: 

<pre>
	int (x[10])();	// ERROR: an array of functions 
</pre>
			// returning int 
use this: 

<pre>
	int (*x[10])();	// OK: an array of pointers to 
			// functions returning int 
</pre>



<h4>array of functions or refs is illegal </h4>

C++. An array of pointers to functions, not an array of functions, can 
be declared. For example, instead of this: 

<pre>
	int (&x[10])();	// ERROR: an array of functions 
			// returning int 
</pre>

use this: 

<pre>
	int (*x[10])();	// OK: an array of pointers to 
			// functions returning int 
</pre>

See ARM 8.4.3 for more information. 


<h4>array or pointer required before '[ ' </h4>

The brackets operator can only follow an array or pointer identifier. 


<h4>assembler opcode expected </h4>

Inline Assembler. If the ASM keyword is being used, an assembler 
opcode or a label should start each instruction. 




<h4>assignment to 'this' is obsolete, use X::operator new/delete </h4>

Warning. C++. Avoid performing storage management by assigning 
to this. Instead, overload the operators new and delete. Assigning 
to this is not part of the latest definition of C++, and future compilers 
may not support it. 


<h4>at least one parameter must be a class or a class&amp; </h4>

C++. An operator overloaded function that is not a class member 
must have at least one parameter that is a class or class reference. 


<h4>bad -D switch, identifier </h4>

The command line macro definition is invalid. 


<h4>bad file name 'filename' </h4>

The filename is invalid. 


<h4>bad member-initializer for '<i>identifier</i>' </h4>

C++. A syntax error exists in the base class initializer for the class 
identifier. For example: 

<pre>
	struct base
	{   base(int); 
	}; 

	struct sub : base
	{   sub(int); 
	    int var;
	}; 

	sub::sub(int a) : base(a),, var(a) { } // ERROR: Extra comma 
</pre>


<h4>base class 'name' has different ambient memory model </h4>

C++. The base class name is declared as __far, and a subclass of 
name is declared as __near, or visa versa. Change either 
declaration to match the other. 
<p>

The following code will cause this error: 

<pre>
	class __far base { }; 

	class __near sub : public base { }; 
</pre>


<h4>binary exponent part required for hex floating constants </h4>

The exponent is missing from a hexadecimal floating-point constant. 
A hexadecimal floating point constant comprises an optional sign, 
the 0x prefix, a hexadecimal significand, the letter p to indicate the 
start of the exponent, a binary exponent, and an optional type 
specifier. These are valid hexadecimal floating-point constants: 

<pre>
	0x1.FFFFFEp127f
	0x1p-23 
	-0x1.2ACp+10 
</pre>


C++. A bit field cannot occur in an anonymous union. A named 
union can have a bit field. 


<h4>blank arguments are illegal </h4>

Arguments are missing from a macro reference that is defined to take 
them. For example: 

<pre>
	#define TWICE(x) (x + x) 
	TWICE(10) // OK
	TWICE() // ERROR 
</pre>


<h4>'break' is valid only in a loop or switch </h4>

The break statement can occur only within a for, while, 
switch, or do/ while statement. 


<h4>can only delete pointers </h4>

C++. The delete operator works only on pointers. Use delete on 
a pointer to an object and not the object itself. 


<h4>can't assign to const variable </h4>

A new value is assigned to a const variable. Remove the 
assignment or remove the restriction from the variable. 


<h4>can't build filespec 'filename' </h4>

The named file cannot write to disk, probably because the disk is 
full. 


<h4>can't declare member of another class identifier </h4>

C++. In a class declaration, a class name modifies a member function 
name. For example: 

<pre>
	class X
	{   void func_in_X(); 
	};

	class Y
	{ 
	    void X::func_not_in_X(); // ERROR
	    int func_in_Y(); // OK 
	};
</pre>

 
<h4>can't handle constructor in this context </h4>

C++. It is illegal to have a constructor as a default function 
parameter. For example: 

<pre>
	class X
	{ public: 
	    X(int);
	}; 

	void foo(X = X(1));	// ERROR: X(1) is a
				// constructor. 
</pre>

<h4>can't have unnamed bit fields in unions </h4>

It is illegal to use an unnamed bit field in a union. Use a named bit 
field or remove the bit field. 


<h4>can't open response file </h4>

The compiler cannot open the response file specified on the 
command line. Ensure that the file exists and that the correct path is 
specified. 


<h4>can't pass const/volatile object to non-const/volatile member function</h4>
 
C++. An object declared as const or volatile is trying to call a 
member function that is not. Declare the member function const or 
volatile, or remove the restriction from the object. For example: 

<pre>
	struct A
	{   int regular_func(); 
	    int const_func() const;
	}; 

	void main()
	{ 
	    const A const_obj;
	    A regular_obj; 

	    const_obj.regular_func(); // ERROR
	    const_obj.const_func(); // OK 
	    regular_obj.const_func(); // OK
	    regular_obj.regular_func(); // OK 
	}
</pre>

 
<h4>can't return arrays, functions or abstract classes </h4>

C++. A function cannot return an array, function, or abstract class. 
However, a function can return a pointer to an array or a pointer to 
a function. For example: 

<pre>
	typedef char ARRAY[256];
	ARRAY func_returning_array(); // ERROR 
	ARRAY *func_returning_ptr_to_array(); // OK 
</pre>


<h4>can't take address of register, bit field, constant or string </h4>

It is not possible to take the address of a register variable, a bit field 
in a structure, a constant, or a string. Declare the object differently, 
or avoid taking its address. 


<h4>can't take sizeof bit field </h4>

It is illegal to use sizeof to determine the size of a bit field member 
of a struct. 


<h4>cannot convert identifier* to a private base class identifier* </h4>

C++. A pointer to a class X cannot convert to a pointer to a private 
base class Y unless the current function is a member or a friend of 
X. 

<pre>
	class Y { }: 
	class X : Y;

	void f(void) 
	{
	    class X *Px; 
	    class Y *Py;
	    Py = (class Y *) Px; 
</pre>


<h4>cannot create instance of abstract class '<i>identifier</i>' </h4>

C++. An abstract class contains at least one pure virtual function by 
the declaration virtual func() = 0. It is illegal to declare objects 
of such a class. For example: 

<pre>
	class abstract_class
	{   public: 
	    virtual int func() = 0;
	    int x, y; 
	}; 

	class subclass : abstract_class
	{   public: 
	    virtual int func()
	    {   return (x* 2); }
	    int a, b; 
	}; 

	void main()
	{   
	    subclass a; // OK
	    abstract_class b; // ERROR 
	    // ...
	} 
</pre>


<h4>cannot define parameter as extern </h4>

Extern is an illegal storage class for a function parameter. 


<h4>cannot delete pointer to const </h4>

C++. It is illegal to use the delete operator on a const pointer. 
Remove the const casting, or remove the delete. 
<p>

See ARM 8.5.3 for more information. 


<h4>cannot find constructor for class matching </h4>

C++. The compiler cannot find a constructor that matches the current 
initializers. Use different initializers. Coerce some initializers so that 
they match those of a constructor, or define a new constructor. For 
example: 

<pre>
	struct X
	{   X(char *); 
	}; 

	void main()
	{   
	    X a = 1L; // ERROR
	    X b = 3.1e20; // ERROR 
	    X c = "hello"; // OK
	} 
</pre>


<h4>cannot generate identifier for class '<i>identifier</i>' </h4>

C++. The compiler cannot define a copy constructor (X::X(X&amp;)) 
for class X or an assignment operator (X&amp; operator=(X&amp;)) for 
class X for the class. If a class needs these methods, explicitly 
define them. 
<p>

The compiler cannot define an assignment operator if one of these 
conditions is true: 

<ul>
	<li> The class has a const member or base. 
	<li> The class has a reference member. 
	<li> The class has a member that is an object of a class with a 
	private operator=(). 
	<li> The class is derived from a class with a private 
	operator=(). 
</ul>

The compiler cannot generate a copy constructor if one of these 
conditions is true: 

<ul>
	<li> The class has a member that is an object of a class with a 
	private copy constructor. 

	<li> The class is derived from a class with a private copy 
	constructor. 
</ul>

See ARM 12.1 and 12.8 for more information. 


<h4>cannot generate template instance from -XI identifier </h4>

C++. The compiler cannot generate a template instance from the 
specifier on the command line. Include the template definition in the 
program and correctly spell the template instance. 


<h4>cannot have member initializer for '<i>identifier</i>' </h4>

C++. The constructor initializer can initialize only nonstatic members. 

See ARM 8.12.6.2 for more information. 


<h4>cannot implicitly convert </h4>

This expression requires the compiler to perform an illegal implicit 
type conversion. To perform this conversion, explicitly cast the 
expression. 


<h4>cannot mix C++ EH with NT structured EH </h4>

C++. You need to use one scheme or the other; you cannot mix 
them. 



<h4>cannot raise or lower access to base member '<i>identifier</i>' </h4>

C++. Access declarations in a derived class cannot grant or restrict 
access to an otherwise accessible member of a base class. For 
example: 


<pre>
	class base
	{   public: 
	    int a;
	  private: 
	    int b;
	  protected: 
	    int c;
	}; 

	class sub : private base
	{   public: 
	    base::a; // OK
	    base::b; // ERROR: can't make b 
		     // accessible
	  protected: 
	    base::c; // OK
	    base::a; // ERROR: can't make a 
	};	     // inaccessible 
</pre>

See ARM 11.3 for more information. 


<h4>cannot throw object of '<i>identifier</i>' not of ambient memory model </h4>

C++. You cannot throw near classes in large data models; likewise, 
you cannot throw far classes in small data models. 


<h4>case number was already used </h4>

This value already occurs as a case within the switch statement. 


<h4>casts and sizeof are illegal in preprocessor expressions </h4>

An extension to ANSI C allows the use of the sizeof 
operator and performs a cast in preprocessor directives. Turning on 
the Enforce ANSI Compatibility option in the IDDE (the -A 
command line option), disallows use of these expressions in a 
preprocessor directive. 
<p>

See ARM 15.3 for more information. 


<h4>catch type masked by previous catch </h4>

C++. One of the following has occurred: 

<ul>
	<li> The catch type appears more than once. 
	<li> A base class appears before a derived class. 
	<li> A pointer or reference to a base class appears before a 
	pointer or reference to a derived class. 
</ul>


<h4>class name identifier expected after ~ </h4>

C++. A destructor is declared incorrectly. The proper name is 
class::~class(). If the class is named X, its destructor is X::~X(). 


<h4>code segment too large </h4>

The size of the code segment exceeds 64K bytes. 


<h4>comma not allowed in constant expression </h4>

It is illegal to use a comma in a constant expression or to separate 
numbers by commas or spaces. 
<p>

See ANSI 3.4 for more information. 


<h4>comments do not nest </h4>

Warning. Avoid nesting comments; it's easy to nest incorrectly and 
accidentally comment out the wrong code. Instead, use #if 0 and 
#endif to block out sections of code. Avoid crossing existing #if. 
For example, the following statements comment out the enclosed 
code: 

<pre>
	#if
	    ....
	#endif 
</pre>


<h4>compile all files with -EH to support exception handling </h4>

All code that handles exceptions must be compiled with -EH. 


<h4>compile all files with -ER to support RTTI </h4>

To support run-time type identification, compile all files in the 
project with -ER. 


<h4>const or reference '<i>identifier</i>' needs initializer </h4>

Nonextern consts or references must be initialized. 
<p>

See ANSI 3.4 for more information. 


<h4>constant expression does not fit in switch type </h4>

The value of a case is larger than the type of the switch expression. 
This error occurs, for example, if a 100000 was assigned to a 
short value. 




<h4>constant initializer expected </h4>

When initializing a variable being declared, any nonpointer type 
initializer must be either a constant or the address of a previously 
declared static or extern item. For example: 

<pre>
	const float pi = 3.1415;
	float a = 3.0; 
	static float b; 
	float w = a * 2; // ERROR: a isn't const float
	x = pi * pi; // OK: pi declared const 
	float *y = &a; // ERROR: a isn't static
	float *z = &b; // OK: b is static 
</pre>


<h4>'continue' is valid only in a loop </h4>

A continue statement occurs out of context. Use it only within 
for, while, and do/while statements. 


<h4>conversion of int to far or handle pointer </h4>

In this expression, the compiler needs to convert an integer to a far 
or handle pointer. This conversion probably means that a function 
that is not declared as a function returns a pointer. The compiler 
assumes the function returns an integer. For example: 


<pre>
	float __far *f(); 
	void main()
	{ 
	    float __far *a, *b; 
	    a = g();	// ERROR: g() not declared, so
			// compiler assumes it returns 
			// int, not float *.
	    b = f(); 	// OK: f() declared as function
			// returning float * 
	} 
</pre>

If the function is declared a function and the conversion is desired, 
cast the integer to a long integer and then to a pointer, for example: 

<pre>
	float far *ptr;
	int f(); 

	ptr = f();
	float far * // EROR ptr = ()
	f(); // OK 
</pre>


<h4>data or code defined in precompiled header </h4>

Precompiled headers can contain only declarations, not definitions. 


<h4>declarator for 0 sized bit field </h4>

A bit field must have a size. 


<h4>'default:' is already used </h4>

The default: statement appears more than once in a switch 
statement. 


<h4>different configuration for precompiled header </h4>

The precompiled header being used is precompiled with different 
options. Precompile the header again with the current options or 
check the current options for accuracy. 


<h4>divide by 0 </h4>

A constant expression tries to divide by zero or use modulo (%) of 
zero. 


<h4>duplicate direct base class '<i>identifier</i>' </h4>

C++. When declaring a new class, the same class occurs more than 
once in its list of direct base classes. 
<p>

See ARM 10.1 for more information. 


<h4>DS is not equal to DGROUP </h4>

Warning. You have used the -W (Windows target) compiler option 
with the b modifier (assume DS != DGROUP), and a segment fixup 
was made to DGROUP. 


<h4>duplicate file names 'filename'</h4>
 
While compiling files, the compiler tries to open the same list 
(.lst) or dump file (.dmp) in two places. It is illegal to refer to the 
same file in both the command line and source code. It is also illegal 
to use the same file for different outputs, such as .obj, .lst. 


<h4>empty declaration</h4>

A declaration must declare at least a declarator, a tag, or the 
members of an enumeration. 
<p>

See ANSI 3.5 for more information. 


<h4>end of file found before '#endif' </h4>

Missing #endif causes the compiler to reach the end of the file in 
the middle of a conditional compilation statement list. 


<h4>end of file found before end of comment, line number </h4>

A missing */ causes the compiler to reach the end of the file in the 
middle of a comment. 


<h4>end of line expected </h4>

Using the Enforce ANSI Compatibility option in the IDDE (the -A 
command line option) does not allow any text to follow the #endif 
keyword, unless the text is a comment. For example: 

<pre>
	#ifdef DEBUG
	    printf("oops\n"); 
	#endif DEBUG // Not ANSI-compatible 
	#ifdef DEBUG
	    printf("oops\n"); 
	#endif	// DEBUG
		// ANSI-compatible 
</pre>


<h4>error writing output file </h4>

The compiler cannot write an output file, probably because the disk 
is full. 


<h4>exception specifications must match exactly for each declaration of a function </h4>

C++. For example: 

<pre>
	void func() throw(int);
	void func() throw(unsigned); // ERROR 
</pre>

See ARM 15.4 for more information. 


<h4>expected assembler directive PTR to follow assembler cast </h4>

Inline Assembler. An assembler cast requires the word PTR. For 
example: 

<pre>
	unsigned long 1;
	asm { 
		mov AX,word PTR ;OK 
		mov AX, word 1 ;ERR
	} 
</pre>


<h4>expected data def of '<i>identifier</i>', not func def </h4>

It is illegal to declare nested functions in C or C++. For example: 

<pre>
	void f()
	{ 
	    void g() { } // ERROR: Nested
	}		 // function. 
</pre>


<h4>exponent expected </h4>

The compiler cannot find the exponent for the floating point number 
written. Do not put any white space between the e and the 
following exponent. 


<h4>expression expected </h4>

The compiler expects to find an expression but cannot find one. A 
semicolon or a close brace may cause this problem. 


<h4>expression must be a pointer </h4>

C++. The expression: 

<pre>
	dynamic_cast &lt;type-name&gt; (expression) 
</pre>

must be a pointer. 
<p>

See ARM 5.2.6 for more information. 


<h4>expression must be a pointer or reference to a polymorphic type </h4>

C++. This message indicates an invalid use of dynamic_cast. (A 
polymorphic type is a class with at least one virtual function.) 
<p>

See ARM 5.2.6 for more information. 


<h4>external with block scope cannot have initializer </h4>

It is illegal to initialize a variable declared extern. Instead, initialize 
the variable in the file where it is defined. 
<p>

See ANSI 3.5.7 for more information. 


<h4>'_far16' is only valid in -mf memory model </h4>

The _far16 type modifier is only valid when compiling for the 
OS/2 2.0 (Flat) memory model. 


<h4>'_far16' functions can only be extern </h4>

The compiler cannot generate code for a _far16 function body; it 
can only call it. 


<h4>field '<i>identifier</i>' must be of integral type </h4>

An inappropriate type occurs for a member of a bit field structure. 
Use signed/unsigned char, short, int, or long. 


<h4>filespec string expected </h4>

The compiler cannot find the filename string in an #include 
statement. Enclose the filename in double quotes or angle brackets. 


<h4>__finally or __except expected </h4>

C++. For Structured Exception Handling, __finally or __except 
must be part of the syntax for a __try block. 




<h4>forward referenced class '<i>identifier</i>' cannot be a base class </h4>

C++. A class must be declared before it can be used as a base class 
for a new class. A forward declaration is not sufficient. For example: 

<pre>
	class A; // Forward reference for A
	class B { // Declaration of B 
	    int a, b, c;
	    void f(); 
	}; 

	class X : A { /*...*/ };// ERROR: A isn't
				// declared 

	class Y : B { /*...*/ };// OK: B is
				// declared 
</pre>


<h4>function '<i>identifier</i>' can't be in an anonymous union </h4>

C++. An anonymous union cannot have function members. 
<p>

See ARM 9.6 for more information. 


<h4>function member '<i>identifier</i>' has no prototype </h4>

The compiler cannot find a function prototype for this function. The 
C++ compiler requires function prototypes by default. With C, this 
message occurs only when the -r option is selected. 


<h4>function '<i>identifier</i>' is too complicated to inline </h4>

Warning. A function declared as inline is too complex to compile 
inline, so the compiler compiles it as a normal function. 


<h4>function definition must have explicit parameter list </h4>

A function definition requires an explicit parameter list. It cannot 
inherit a parameter list from a typedef. For example, this definition 
does not compile: 

<pre>
	typedef int functype(int q, int r); 
	functype funky	// ERROR: No explicit
	{		// parameter list 
	    return q + r;
	} 
</pre>

See ANSI 3.7.1 for more information. 


<h4>function expected </h4>

The compiler expects to find a function declaration but does not. 
Check for mismatched braces, parentheses not preceded by a 
function name, or a template declaration not followed by a class or 
function declaration. 




<h4>functions can't return arrays or functions </h4>

C. A function cannot return an array or a function. However, a 
function can return a pointer to an array or a pointer to a function. 
For example: 

<pre>
	typedef char ARRAY[256];
	ARRAY func_returning_array(); // ERROR 
	ARRAY *func_returning_ptr_to_array(); // OK 
</pre>


<h4>GetExceptionCode() only valid in exception filter or handler </h4>

C++. GetExceptionCode() is part of Structured Exception 
Handling. 


<h4>GetExceptionInformation() only valid in exception filter </h4>

C++. GetExceptionInformation() is part of Structured 
Exception Handling. 


<h4>global anonymous unions must be static </h4>

C++. Anonymous unions must be extern or static. 
<p>

See ARM 9.5 for more information. 


<h4>hex digit expected </h4>

The compiler expects to find a hexadecimal digit after the characters 
0x. Do not put any white space after the x. 


<h4>identifier expected </h4>

The compiler expects to find an identifier, but finds instead another 
token. 


<h4>identifier found in abstract declarator </h4>

A type in a sizeof expression, typedef statement, or similar 
place incorrectly includes a variable name. For example: 

<pre>
	x = sizeof(int a[3]);	// ERROR: a is a variable 
				// name.
	x = sizeof(int[3]); 	// OK 
</pre>


<h4>identifier is longer than 254 chars </h4>

The maximum size of an identifier is 254 characters. 


<h4>identifier or '(declarator) ' expected </h4>

The compiler expects to find a declaration for a static variable, an 
external variable, or a function. If this error appears in a function, 
check to see if there are more left braces than right braces. 



<h4>illegal addressing mode </h4>

Inline Assembler. An illegal operand, such as [ah], appears. 


<h4>illegal cast </h4>

It is illegal to cast an object to an inappropriate type. For example, 
structs or unions cannot cast to other types but can cast 
numerical values and pointers. 


<h4>illegal character, ascii number decimal </h4>

The source file includes a character, such as @ or $, that is not part 
of the C character set outside a comment or a string. 


<h4>illegal combination of types </h4>

Certain types cannot occur together. For example, you cannot: 

<ul>
	<li> Use near and far in the same declaration. 
	<li> Use a modifier on a reference. 
	<li> Use pascal on a pointer. 
	<li> Have a stack pointer to a function. 
	<li> Declare a variable to be a short long int. 
</ul>

<h4>illegal constuctor or destructor declaration </h4>

C++. A constructor or destructor is incorrectly declared. For example, 
a constructor may be declared as virtual or friend, a destructor 
may be declared as friend, or a return value may be specified for a 
constructor or destructor. 


<h4>illegal operand </h4>

Inline Assembler. The inline assembler cannot evaluate an 
expression, such as when adding two vars: 

<pre>
	dec a + b 
</pre>

Inline assembler operands must be representable in one instruction. 


<h4>illegal operand types </h4>

The operands are of the wrong type, casting the operands to a 
different type. 


<h4>illegal pointer arithmetic </h4>

The only legal operations on pointers are adding or subtracting an 
integer from a pointer; subtracting a pointer from another pointer; 
and comparing two pointers with &lt;, &gt;, ==, &lt;=, or &gt;=. 


<h4>illegal return type for operator-&gt;() </h4>

C++. operator-&gt;() must return one of these: 

<ul>
	<li> A pointer to an object of the class that defines 
	operator-&gt;() 

	<li> A pointer to an object of another class that defines 
	operator-&gt;() 

	<li> A reference to an object of another class that defines 
	operator-&gt;() 

	<li> An object of another class that defines operator-&gt;() 
</ul>

See ARM 13.4.6 for more information. 


<h4>illegal type combination, possible missing ';' after struct </h4>

You may have omitted a semicolon (;) after a struct declaration. 


<h4>illegal type for '<i>identifier</i>' member </h4>

Variables cannot be of type void. 

<pre>
	struct X
	{   void var; // ERROR 
	};
</pre>

 
<h4>illegal type/size of operands for the identifier instruction</h4>

Inline Assembler Warning. An operand for an instruction is specified 
as the wrong size. This can be a warning or an error. The following 
example generates an error; it is illegal because the PUSH instruction 
does not allow for an 8-bit operand: 

<pre>
	char c;
	__asm push c; 
</pre>

On the other hand, this is a warning: 

<pre>
	mov AX, c 
</pre>

It moves 16 bits from c.
<p>
This can also happen for the following FPU instruction format,
which is accepted by other compilers:

<pre>
	fmul st(0)
</pre>

Rewrite it as:

<pre>
	fmul st, st(0)
</pre>


<h4>implied return at closing '}' does not return value </h4>

Warning. A function is declared to return a value, but it returns 
without specifying one. 


<h4>initialization of '<i>identifier</i>' is skipped </h4>

A goto or case statement has resulted in an explicit or implicit 
initialization of a variable being skipped. 
<p>

See ARM 6.7 for more information. 


<h4>initializer for static member must be outside of class def </h4>

C++. Static class members must initialize outside the class definition. 
For example: 

<pre>
	class A
	{ static int a = 5;	// ERROR: Can't initialize static
				// class var in class def. 
	  void f();
	}; 

	class B
	{ static int b; 
	  void f();
	}; 

	int B::b = 6;	// OK: Initialize static class var 
			// outside class def. 
</pre>

See ARM 9.4 for more information. 


<h4>initializer or function body for dllimport not allowed </h4>

Functions or data objects you declare with the dllimport attribute 
must be extern declarations. 


<h4>integer constant expression expected </h4>

An integer constant expression must occur in case statements; array 
size declarations; and the #if, #elif, #exit, and #line 
preprocessor commands. 


<h4>integral expression expected </h4>

An integer type must occur in case statements; in array size 
declarations; and the #if, #elif, #exit, and #line preprocessor 
commands. 


<h4>internal error identifier number </h4>

A compiler error has occurred. Please report this error to Digital Mars. 


<h4>invalid instruction set 'set' for memory model 'model' </h4>

You have specified a 16-bit instruction set for a 32-bit memory 
model. 




<h4>invalid reference initialization </h4>

C++. It is illegal to use invalid reference initialization errors, which 
result from trying to initialize: 

<ul>
	<li> A volatile reference to a const. 
	<li> A const reference to a volatile. 
	<li> A plain reference to a const or volatile. 
</ul>

See ARM 8.4.3 for more information. 


<h4>invalid storage class for friend </h4>

C++. Friend functions cannot be virtual. 


<h4>keyword not supported </h4>

Digital Mars C/C++ recognizes but does not support the keyword. Use 
the int_xxx routines in the function library instead of the 
__interrupt keyword. This is the only instance of this message. 


<h4>last line in file had no \n </h4>

Compiling with the Enforce ANSI Compatibility option in the 
IDDE (the -A command line option) on means that the last line of a 
source file must end with a newline character. A backslash cannot 
precede the newline. 


<h4>__leave must be within a __try block </h4>

C++. For Structured Exception Handling, __leave must be part of 
the syntax for a __try block. 


<h4>line number expected </h4>

The line number in the #line directive must be a constant 
expression. 


<h4>linkage specs are "C", "C++", and "Pascal", not "identifier" </h4>

C++. The compiler supports only the C++, C, and Pascal linkage 
types. 


<h4>local class cannot have static data member '<i>identifier</i>' </h4>

C++. A local class (that is, a class declared within a function) cannot 
have a static data member. For example: 

<pre>
	void f()
	{ 
	    class local_class
	    { int a, b; 
	      static int c;	// ERROR: Can't have void g();
				// static var in 
	    } l1, l2;		// local class 
	    // ...
	} 
</pre>

See ARM 9.4 for more information. 


<h4>long long not supported for ANSI or 16 bit compiles </h4>

64-bit ints are only supported for 32-bit memory models. The long 
long data type is not an ANSI standard data type. 


<h4>lvalue expected </h4>

The compiler expects to assign a value to an expression, such as a 
variable. For example: 

<pre>
	short short_f(void);
	short *pshort_f(void); 

	void function(void)
	{ 
	    short i;
	    short *p = &i;	// Operand of ++ must be an lvalue
	    7++;		// NO 
	    short_f()++;	// NO 
	    pshort_f()++;	// NO 

	    // Left operand of an assignment
	    // must be an lvalue. 
	    A, B = i;		// NO
	    pshort_f() = i;	// NO 
	    *pshort_f() = i;	// OK: Produces an lvalue
	    (*p)++;		// OK 
	    (*pshort_f())++;	// OK
	} 
</pre>


<h4>main(), WinMain(), or LibMain() cannot be static or inline </h4>

C++. It is illegal to declare any of the functions main(), 
WinMain(), or LibMain() as static or inline. 
<p>

See ARM 3.4 for more information. 


<h4>maximum width of number bits exceeded </h4>

This field can contain number bits. For example: 

<pre>
	struct X
	{ char x:9;	// ERROR: char is 8 bits 
	  short y:17;	// ERROR: short is 16 bits
	  long z:33;	// ERROR: long is 32 bits 
	};
</pre>

 
<h4>macro '<i>identifier</i>' can't be #undef'd or #define'd </h4>

It is illegal to redefine or undefine this predefined macro. To 
suppress non-ANSI predefined macros, set the Suppress 
Predefined Macros option in the IDDE (the -u command line 
option). 
<p>

See ANSI 3.8.8 for more information. 


<h4>malformed template declaration </h4>

C++. A template class or function is declared incorrectly. The 
following are correct declarations: 

<pre>
	template&lt;class T, int x&gt; // OK
	class vector
	{ 
	    T v[x];
	  public: 
	    vector();
	    T&amp; operator[](int); 
	    /* ... */
	}; 

	template&lt;class T&gt; // OK
	T ave(T x, T y)
	{ 
	    return ((T)((x + y) / 2));
	} 
</pre>

See ARM 14 for more information. 


<h4>maximum length of macro text exceeded </h4>

The maximum length of a macro replacement text string has been 
exceeded. 


<h4>max of number characters in string exceeded </h4>

This string can contain number characters. 


<h4>member '<i>identifier</i>' can't be same type as struct '<i>identifier</i>' </h4>

A member of a structure with type identifier cannot itself have type 
identifier. 


<h4>member '<i>identifier</i>' is const but there is no constructor </h4>

C++. If a class has a const member, the class must also have a 
constructor. Initialize a const variable only in the constructor, for 
example: 

<pre>
	class A
	{			// ERROR: no constructor
	    const int x;	// to initialize x 
	    int y, z;
	    void f(); 
	};
 
	class B
	{   const int x; 
	    int y, z;
	    void f(); 
	    B();	// OK: x can be
	};		// initialized. 
</pre>



<h4>member '<i>identifier</i>' of class '<i>identifier</i>' is not accessible </h4>

C++. A class member that is private or protected cannot be accessed. 


<h4>member '<i>identifier</i>' of class '<i>identifier</i>' is private </h4>

C++. Only a class function or a derived function of the class can use 
a private member. For example: 

<pre>
	class super
	{ private: 
	    int x;
	    int f(); 
	};
 
	class sub : super
	{
	    int g(); 
	}; 

	int super::f()
	{ 
	    return (x++);	// OK: B::f() is a
	}			// member function 

	int sub::g()
	{ 
	    return (x++);	// ERROR: sub::g() is a
	}			// member function 
				// of a derived class 
	void main()
	{ 
	    super s;
	    s.x = 3;		// ERROR: main() isn't a 
	    return 0;		// member function
	}			// or a friend 
				// function 
</pre>

<!--
<h4>member functions cannot be static </h4>

C++. If you turn on the Enforce ANSI Compatibility option in the 
Source Code dialog box in the IDDE (the -A command line 
option), you cannot declare a member function to be static. 
-->

<h4>missing ', ' between declaration of '<i>identifier</i>' and '<i>identifier</i>' </h4>

You probably wrote something like: 

<pre>
	int x y; 
</pre>

where x was to be a macro. 


<h4>missing decl-specifier-seq for declaration of '<i>identifier</i>' </h4>

You can only omit the decl-specifier-seq (the storage class followed 
by the declaration's type) in function definitions and function 
declarations. 
<p>

See ARM 7 for more information. 


<h4>must be void operator delete(void *[, size_t]); </h4>

C++. The improper prototype occurs when the delete operator for 
a class that uses the C++ model is overloaded. The prototype for an 
operator delete overload must be either: 

<pre>
	void operator delete(void *); // OK 
</pre>

or 

<pre>
	void operator delete(void *, size_t);// OK 
</pre>


<h4>must use delete[] for arrays </h4>

C++. To delete an array a, use this statement: 

<pre>
	delete[] a; // OK 
</pre>

and not 

<pre>
	delete a; // ERROR 
</pre>

See ARM 5.3.4 for more information. 


<h4>need at least one external def </h4>

There must be at least one global symbol defined. 
<p>

See ANSI 3.7 for more information. 


<h4>no constructor allowed for class '<i>identifier</i>' </h4>

C++. The class includes a variable with the same name as the class. 
This prevents the use of a constructor that must have that name. 


<h4>no definition for static '<i>identifier</i>' </h4>

A static is referred to, but no definition is provided. For example: 

<pre>
	static void f();
	void g() { f(); } 
</pre>

See ANSI 3.7 for more information. 


<h4>no identifier for declarator </h4>

An identifier is missing from this declaration. For example: 

<pre>
	void f(char [3]) // ERROR: No identifier
	{ 
	    // ...
	} 

	int [3]; // ERROR: No identifier
	int a[3]; // OK: Identifier is a 
</pre>


<h4>no input file specified </h4>

This command line must include an input file. 


<h4>no instance of class '<i>identifier</i>' </h4>

C++. It is illegal to attempt the following: 

<ul>
	<li> Call a nonstatic member function without using an 
	instance of the class. 

	<li> Access a nonstatic data member without using an instance 
	of the class. 

	<li> Define a nonstatic data member outside a class. 
	However, it is legal to attempt the following: 

	<li> Call a static member function without an object. 

	<li> Access a static data member without an object. 

	<li> Define a static data member outside a class. 
</ul>

For example: 

<pre>
	struct CLASS
	{
	    static void static_func(); 
	    void nonstatic_func(); 
	    static int static_data;
	    int nonstatic_data; 
	};
 
	int CLASS::nonstatic_data = 1; // ERROR
	int CLASS::static_data = 1; // OK 

	void main()
	{ 
	    CLASS object; 
	    int i = CLASS::nonstatic_data;	// ERROR
	    int j = object.nonstatic_data;	// OK 

	    CLASS::nonstatic_func();	// ERROR
	    CLASS::static_func();	// OK 
	    object.nonstatic_func();	// OK
	} 
</pre>


<h4>no instance of class '<i>identifier</i>' for member '<i>identifier</i>' </h4>

C++. You attempted to reference a member of a class without a 
this pointer being available. 


<h4>no match for function '<i>identifier</i>' </h4>

C++. The function is overloaded, and the compiler cannot find a 
function that matches the call. 


<h4>no return value for function '<i>identifier</i>' </h4>

A function has a return type other than void, but it has no return 
statement or has a path by which it doesn't return. For example: 

<pre>
	int f()
	{ 
	    if (x)
		return;
	}
</pre>

See ARM 6.6.3 for more information. 


<h4>no tag name for struct or enum </h4>

Warning. If a struct or an enum does not have a tag name, further 
objects of this type cannot be declared later in the program. Give 
every struct and enum a tag name so that the compiler's type-safe 
linkage system can use it. 


<h4>non-const reference initialized to temporary </h4>

Warning. In most cases, this message means that a temporary 
occurs and the warning initializes the reference to that temporary. 
Since the reference is not const, the referenced temporary may 
change its value. 
<p>

However, this message becomes an error when the Enforce ANSI 
Compatibility option in the IDDE (the -A command line option) is 
set. 
<p>

See ARM 8.4.3 for more information. 


<h4>not a struct or union type </h4>

The type of object preceding the object member operator selector 
(.) or the pointer to object selection (operator -&gt;) is not a class, 
a struct, or a union. 


<h4>not an overloadable operator token </h4>

C++. You cannot overload these operators: 

<pre>
	.	.*	::	?:	sizeof	#	## 
</pre>


<h4>not in a switch statement </h4>

It is illegal to use a case or default statement outside a switch 
statement. 


<h4>number '<i>number</i>' is too large </h4>

The number is too large to be represented in an object with long 
type. 


<h4>number is not representable </h4>

The compiler cannot represent a numeric constant because of the 
constraints listed in the following table: 

<pre>
	You cannot represent	If it is 

	Integer			greater than ULONG_MAX (in limits.h) 

	Floating point number	less than DBL_MIN or greater than DBL_MAX 
	(in float.h) 

	Enumeration constant	greater than INT_MAX 
	(in limits.h) 

	Octal character constant greater than 255 
</pre>


<h4>object has 0 size </h4>

The compiler does not allow objects of zero size. Trying to subtract 
two pointers that point to zero size objects causes division by zero. 


<h4>octal digit expected </h4>

The compiler expects that a number with a leading 0 is an octal 
digit. Using an 8 or 9 is illegal. 


<h4>one argument req'd for member initializer for '<i>identifier</i>' </h4>

C++. Member initializers in which the member lacks a constructor 
must have exactly one parameter because the member is initialized 
by assignment. 


<h4>only classes and functions can be friends </h4>

C++. It is legal to declare other classes or functions friend only 
when declaring a function within a class. 


<h4>only one identifier is allowed to appear in a declaration appearing in a conditional expression </h4>

C++. Pointers and references to references are invalid. 
operator functions -&gt;() and [] must be non-static members 
C++. It is illegal to declare as static these operators: 

<ul>
	<li> The pointer to object selection operator (-&gt;) 
	<li> The function call operator (()) 
	<li> The array operator ([]) 
</ul>

<h4>operator overload must be a function </h4>

C++. It is illegal to declare an overloadable operator as a variable. 
For example: 

<pre>
	struct X
	{ int operator&lt;&lt;; // ERROR 
	};
</pre>


<h4>out of memory </h4>

The compiler is out of memory. Try the following: 

<ul>
	<li> Break the file or function into smaller units. 
	<li> If the error occurs while optimizing a function, turn off 
	optimization for that function. 
	<li> Use a DOS-extended version of the compiler, if 
	applicable. 
</ul>

<h4>overloaded function '<i>identifier</i>' has different access levels </h4>

C++. It is illegal to adjust the access of an overloaded function that 
has different access levels. For example: 

<pre>
	class base
	{
	  public: 
	    void f(int);
	  private: 
	    void f(float);
	}; 

	class sub : base
	{   base::f;	// ERROR: f() is 
	};		// overloaded. 
</pre>

See ARM 11.3 for more information. 


<h4>parameter list is out of context </h4>

Parameters in a function definition are illegal and are discarded. For 
example: 

<pre>
	int f(a, b); // ERROR
	int g(int, int); // OK 
	int h(int a, int b); // OK 
</pre>


<h4>parameter lists do not match for template '<i>identifier</i>' </h4>

C++. The parameter list for the template instantiation does not match 
the formal parameter list for the class definition. 

<pre>
	template&lt;class T, int size&gt; class vector;
	template&lt; class T, unsigned size&gt; class 
	vector; // no {}
	vector&lt;int, 20&gt; x; // OK 
	vector&lt;float, 3.0&gt; // ERROR: 3.0 is not an int. 
</pre>


<h4>pascal string length number is longer than 255 </h4>

This __pascal string's length exceeds 255 characters. 


<h4>pointer required before '-&gt;', '-&gt;*' or after '*' </h4>

C++. These operators can apply only to pointers. The operators -&gt;
and -&gt;* must precede the pointer, and the operator * must follow 
it. 


<h4>pointer required before '-&gt;' or after '*' </h4>

C. These operators can apply to pointers only. The operator -&gt;must 
precede the pointer, and the operator * must follow it. 



<h4>pointer to member expected to right of .* or -&gt;* </h4>

C++. The identifier after . or -&gt;* must be a pointer to a member of 
a class or struct. 


<h4>possible extraneous ';'</h4>
 
Warning. The compiler finds a semicolon immediately after an if, 
switch, or while statement and executes the next statement, 
regardless of whether the test evaluates to true or false. For example: 


<pre>
	int x = 1, y = 0; 
	if (x== y);		// WARNING: Extra
	printf("x == y\n");	// semicolon.
	printf();		// always executed. 
	if (x == y) // OK
	     printf("x == y\n"); 
</pre>

If a semicolon is desired, suppress the warning by putting white 
space, such as a space or a return, between the close parenthesis 
and the semicolon. 

<pre>
	while (fread(file) == unwanted_data)
	    ; // OK: semicolon is intentional 
</pre>


<h4>possible unintended assignment </h4>

Warning. The assignment operator (=) instead of the equality 
operator (==) appears in the test condition of an if or while 
statement. For example: 

<pre>
	if (x = y) {...} // WARNING: x= y is an assignment 
</pre>

instead of 

<pre>
	if (x == y) {...} // OK: x == y is a test 
</pre>

Test the value of the assignment explicitly, like this: 

<pre>
	if ((x = y) != 0) {...} // OK: (x = y) != 0 is a test 
</pre>

The compiler produces identical code for the first and third 
examples. 


<h4>pragma cseg must be at global scope </h4>

A #pragma cseg statement must occur in the global scope and not 
within a function body or type definition. 


<h4>precompiled header compiled with C instead of C++ </h4>

C++. You have included a C precompiled header in a C++ 
compilation. 


<h4>precompiled header compiled with C++ instead of C </h4>

C. You have included a C++ precompiled header in a C compilation. 


<h4>prefix opcode must be followed by an assembler opcode </h4>

The opcode must immediately follow the LOCK, REP, REPE, REPNE, 
or REPZ instruction prefixes. 


<h4>premature end of source file </h4>

A string that is missing a closing quote or a comment that is missing 
a */ causes the compiler to reach the end of the file while 
processing a function. 


<h4>prototype for '<i>identifier</i>' should be identifier </h4>

A function of the form: func(s) short s; { ... } should be 
prototyped as: 

<pre>
	func(int s); 
</pre>

rather than: 

<pre>
	func(short s); 
</pre>

See ANSI 3.5.4.3 for more information. 


<h4>pure function must be virtual </h4>

C++. Pure member functions must be declared as virtual, like this: 

<pre>
	class B
	{ virtual void f() = 0; // OK 
	  void g() = 0;		// ERROR
	}; 
</pre>


<h4>qualifier or type in access declaration </h4>

C++. It is illegal to specify a storage class or type when adjusting the 
access to a member of a base class. For example: 

<pre>
	class base
	{ public: 
	    int b, c, d;
	    int bf(); 
	};
 
	class sub : private base
	{   int e; 
	  public:
	    base::b; // OK 
	    int base::c; // ERROR
	    static base::d; // ERROR 
	};
</pre>

See ARM 11.3 for more information. 

 
<h4>recursive prototype, turn off autoprototyping </h4>

Use the -p compiler option (see Chapter 2) to turn off 
autoprototyping. 


<h4>redefinition of default parameter </h4>

C++. It is illegal to redefine the default argument for a parameter 
even if redefined to the same value. For example: 

<pre>
	// Prototyping the function.
	int f(int, int = 0); 

	// Defining the function.
	int f(int a, int b = 0)	// ERROR: Can't 
	{			// redefine default
	    return g(a, b);	// argument, even to 
	}			// the same value. 
</pre>

The line given for the error is sometimes past the closing brace of 
the body of the function. 


<h4>reference to '<i>identifier</i>' caused a 386 instruction to be generated </h4>

Inline Assembler Warning. This warning occurs when not using 32-
bit compilation when a reference to a variable causes a 32-bit mode 
instruction to generate, such as: 

<pre>
	unsigned long UL;
	ASM { 
	    INC UL // incrementing a long is 32 bit
	} 
</pre>



<h4>reference must refer to same type or be const </h4>

When initializing a reference, the object being used as an initializer 
must be of the same type as the reference, or it must have const 
type. 


<h4>return type cannot be specified for conversion function </h4>

C++. It is illegal to specify the return type of a conversion function. 
For example: 

<pre>
	class X
	{ char* operator char* (); // ERROR 
	  operator char* (); // OK
	}; 
</pre>

See ARM 12.3.2 for more information. 


<h4>returning address of automatic '<i>identifier</i>' </h4>

Warning. This results in an invalid pointer beyond the end of the 
stack. When the function returns, the caller receives an illegal 
address that can cause a general protection fault. 


<h4>segment size is number, exceeding 64KB </h4>

Code and data for 16-bit compilations are output into 64KB 
segments, one of which exceeds 64KB. This can happen when 
declaring objects whose combination is larger than 64KB. For 
example: int a[50000]. Divide the source module into smaller 
pieces, or switch to a 32-bit memory model. 


<h4>should be number parameter(s) for operator </h4>

C++. The incorrect number of arguments appears in a declaration of 
an overloaded operator. The function call operator () is n-ary; it can 
take any number of arguments. 


<h4>size of identifier is not known </h4>

It is illegal to use a struct or an array with an undefined size. For 
example: 

<pre>
	struct x
	{ int a[]; // ERROR 
	  /* ... */
	}; 

	struct y
	{ int a[100]; // OK 
	  /* ... */
	}; 
</pre>



<h4>size of type exceeds 64KB </h4>

Data objects in 16-bit memory models cannot exceed 64KB unless 
declared with the _huge modifier. 


<h4>statement expected </h4>

The compiler expects a statement but does not encounter one. A 
missing comma or semicolon or a label without a statement can 
cause this error. For example: 


<pre>
	while (TRUE)
	{   // ... 
	    if (done)
		goto end1;
	    // ... 
	  end1:
	} // ERROR: No statement after 
	  // label. 

	while (TRUE)
	{ // ... 
	  if (done)
		goto end2;
	  // ... 
	end2: ; // OK: Null statement after label. 
	}
</pre>

 
<h4>static function '<i>identifier</i>' can't be virtual </h4>

You cannot mix static and virtual storage classes for member 
functions. (Note that the operators new() and delete() are static.) 


<h4>static or non-member functions can't be const or volatile </h4>

C++. It is illegal to declare a static class member function or a 
nonmember class function as const or volatile. 


<h4>static variables in inline functions not allowed </h4>

C++. It is illegal to declare a static variable within an inline function. 


<h4>storage class for '<i>identifier</i>' can't be both extern and inline </h4>

C++. It is illegal to use the inline type specifier for a function 
declared external. 


<h4>string expected </h4>

The compiler expects to encounter a string but cannot find one. 
Check for an #ident directive not followed by a string. 


<h4>struct-declaration-list can't be empty </h4>

C. A struct must contain at least one member. 
<p>

See ANSI 3.5.2.1 for more information. 


<h4>template-argument '<i>identifier</i>' must be a type-argument </h4>

C++. In a function template, all template arguments must be type 
arguments. Unlike class templates, function templates cannot have 
expression arguments. For example: 


<pre>
	template &lt;class T, int x&gt; foo(T y)
		// ERROR: x is an expression argument. 
	{ return x + y; 
	} 
</pre>

See ARM 14.4 for more information. 


<h4>template-argument '<i>identifier</i>' not used in function parameter types </h4>

C++. When defining a template, every template argument in the 
template's argument list must appear in the function's argument list. 
For example: 

<pre>
	template &lt;class T1, class T2&gt;
	int bar(T1 x)	// ERROR: T2 isn't in 
	{		// function's
	    T2 y;	// argument list. 
	    // ...
	} 
</pre>

See ARM 14.4 for more information. 


<h4>too many errors </h4>

The compiler has reached its limit of four errors. For the compiler to 
continue past its limit, set the Turn Off Error Maximum option in 
the Compiler Output dialog box in the IDDE (the -x command 
line option). 


<h4>too many initializers </h4>

The item contains too many initializers. For example: 

<pre>
	char a[3]="hello";	// ERROR
	char b[3]="hi!";	// ERROR: No room for 
				// null character
	char c[3]="hi";		// OK 
</pre>


<h4>trailing parameters must have initializers </h4>

C++. Parameters with default initializers must occur at the end of a 
parameter list. For example: 

<pre>
	int f(int, int= 1, int = 0); // OK
	int g(int = 0, int = 1, int); // ERROR 
	int h(int = 0, int, int = 1); // ERROR 
</pre>


<h4>__try only valid for -mn memory model </h4>

Code that uses the __try modifier must be compiled for the 
Windows NT memory model. 


<h4>type conversions must be members </h4>

C++. It is illegal to declare a type conversion function outside a class. 
Declare it inside a class. 


<h4>type is too complex </h4>

C++. The compiler appends information regarding parameter and 
return types to the end of a function name. With this information 
added, the identifier exceeds the compiler's maximum of 254 
characters. 


<h4>type mismatch </h4>

This error is either a syntax error or a warning message. The 
compiler expects to find one data type but finds another. More 
information about which types it expects and what it finds follows 
this message. 


<h4>type must be a pointer or a reference to a defined class or void* </h4>

This message refers to the type specified in a dynamic_cast. 


<h4>type must be void *operator new(size_t [,..]); </h4>

C++. The wrong prototype appears when the new operator for a 
class that uses the C++ model is overloaded. When operator new is 
overloaded, it must have a return type of void * and take a first 
argument of size_t. The compiler automatically sets the value of 
the first argument to be the class size in bytes. 
<p>

See ARM 5.2.6 for more information. 


<h4>type of '<i>identifier</i>' does not match function prototype </h4>

The arguments of the function do not match the prototype 
previously given. 


<h4>types may not appear more than once in an exception specification </h4>

It is illegal to write an exception specification like: 

<pre>
	void func() throw(int, int); 
</pre>

See ARM 15.4 for more information. 


<h4>unable to open input file 'filename' </h4>

The compiler cannot find the file. Correctly spell the name and 
specify the correct folder. 


<h4>unable to open output file 'filename' </h4>

The compiler cannot open the file. Specify a valid file name and 
make sure there is enough disk space. 


<h4>undefined escape sequence </h4>

The compiler recognizes only the following escape sequences in a 
string or character constant: 


<h4>undefined identifier '<i>identifier</i>' </h4>

It is illegal to use an identifier without declaring it. Correctly spell the 
identifier. 


<h4>undefined label '<i>identifier</i>' </h4>

The goto command to go to a label must be defined. Correctly spell 
the label and make sure the label appears in the same function as 
the goto. 


<h4>undefined tag '<i>identifier</i>' </h4>

The structure or union is not defined. 


<h4>undefined use of struct or union </h4>

It is illegal to use operators, such as arithmetic or comparison 
operators, that do not apply to structs, classes, or unions. 


<pre>
	Table 29-1 Defined escape sequences 
	This sequence Represents 
	\' single quote 
	\" double quote 
	\? question mark 
	\\ backslash 
	\a alert (bell) 
	\b backspace 
	\f form feed 
	\n newline 
	\r return 
	\t tab 
	\v vertical tab 
	\xXXX the character specified with the hexadecimal 
	number 
	\000 the character with the octal number 
</pre>


<h4>unknown operand type for this floating point instruction </h4>

Inline Assembler. It is illegal to enter an inappropriate operand, such 
as a numeric constant, on a floating point instruction. For example: 

<pre>
	fdiv 0x50 
</pre>


<h4>union members cannot have ctors or dtors </h4>

C++. A union cannot contain a member that is an object of a class 
with a constructor or a destructor. 


<h4>unrecognized pragma </h4>

Warning. The compiler does not recognize this #pragma directive. 
See Chapter 3, "Digital Mars C++ Language Implementation" for a list of 
valid pragmas. 


<h4>unrecognized parameter '<i>identifier</i>' </h4>

The compiler does not recognize a parameter or option on the 
command line. Command line options are case sensitive. 


<h4>unrecognized preprocessing directive '#identifier' </h4>

The compiler does not support the specified preprocessor directive. 


<h4>unrecognized token </h4>

The compiler does not recognize the token as valid. Check for an 
extra U or L suffix in an integer constant. It is illegal to use $ and @ 
in identifiers. 


<h4>unsupported based type </h4>

C++. Valid based types are: 

<pre>
	__based(__segname("_DATA")) =&gt; __near
	__based(__segname("_STACK")) =&gt; __ss 
	__based(__segname("_CODE")) =&gt; __cs 
</pre>


<h4>unsupported __declspec type </h4>

Supported __declspec types are: 

<pre>
	declspec(dllimport)
	declspec(dllexport) 
	declspec(naked)
	declspec(thread) 
</pre>


<h4>unterminated macro argument </h4>

A macro argument is missing a close quote or parenthesis. 


<h4>unterminated string </h4>

A string is missing a close quote, or a file contains a lone quote 
mark. The compiler found end of line or end of file before the string 
terminator. 
<p>

See ANSI 3.1.3.4 for more information. 


<h4>use delete[] rather than delete[expr], expr ignored </h4>

Warning. C++. This syntax for deleting an array of objects is 
outdated, although the current version of the compiler supports it 
and ignores expr: 

<pre>
	delete [expr] p; // WARNING: obsolete 
</pre>

New code uses this syntax instead: 

<pre>
	delete [] p; // OK 
</pre>


<h4>using operator++() (or --) instead of missing operator++(int) </h4>

Warning. C++. It is illegal to use the postfix increment (or 
decrement) operator on an object of a class, such as x++, without 
overloading the postfix operator for that class. However, the prefix 
operator is overloaded. The compiler uses the prefix version of the 
operator. 
<p>

To overload the postfix increment operator x++, use 
operator++(). To overload the prefix increment operator ++ x, 
use operator++(int). 


<h4>valid memory models are -m[tsmcrzlvfnpx] </h4>

This command line error indicates that the options for memory 
model selection are incorrect. 


<h4>value of expression is not used </h4>

Warning. It is illegal to compute an expression without using its 
value, such as the equality operator (==) instead of the assignment 
operator (=). For example: 

<pre>
	x == y; // WARNING: The value of x
		// doesn't change. 
	x = y;	// OK: x and y have same value. 
</pre>


Failure to assign the result of a computation to a variable can also 
cause this error. For example: 

<pre>
	t - 5;		// WARNING: Result of this
			// computation is lost. 
	x = t - 5;	// OK: x contains the result.
	t -= 5;		// OK: t contains the result. 
</pre>


<h4>variable '<i>identifier</i>' used before set </h4>

Warning. The optimizer discovers that a specified variable appears 
before it is initialized. The program may generate inexplicable 
results. 


<h4>vectors cannot have initializers </h4>

C++. It is illegal to initialize a vector of objects with a constructor that 
has an argument list. 


<h4>very large automatic </h4>

Warning. Large automatic variables can cause stack overflow. 
Dynamically allocate the memory with a function such as 
malloc(). 


<h4>voids have no value </h4>

C. It is illegal to return a value from a function declared void or to 
use the value of a function declared void. 


<h4>voids have no value, ctors and dtors have no return value </h4>

C++. It is illegal to return a value from a constructor, destructor, or 
function declared void or a reference to a void. It is also illegal to 
use the value of a constructor, destructor, or function declared void. 


<h4>'while' expected </h4>

The keyword while is missing from the end of a do/while loop. 
For example: 


<pre>
	do
	{
	    x = f(y); 
	} (x != 0);	// ERROR: missing while. 
	do
	{
	    x = f(y); 
	} while (x != 0); // OK 
</pre>


<br><br><br><br>

</td></table>







<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

