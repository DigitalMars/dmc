
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - 16 Bit Pointer Types and Type Modifiers
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:25:46 2006
</div>
</div>

<!-- Generated by Ddoc from pointers16.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ctg">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>
</center>

    <a href="ctg.html"><b>Compiler & Tools Guide</b></a><br>

<hr><b>Compiling</b><br>

    &#149; <a href="ctgCompilingCode.html">Compiling Code</a><br>
    &#149; <a href="C-Language-Implementation.html">C Implementation</a><br>
    &#149; <a href="CPP-Language-Implementation.html">C++ Implementation</a><br>
    &#149; <a href="ctgLanguageImplementation.html">Language Extensions</a><br>
    &#149; <a href="ctgMixingLanguages.html">Mixing Languages</a><br>
    &#149; <a href="ctgAsm.html">Assembly Language</a><br>
    &#149; <a href="ctgInlineAsm.html">Inline Assembler</a><br>
    &#149; <a href="ctgOptimizer.html">Optimizing Code</a><br>
    &#149; <a href="ctgNumerics.html">Numerics Programming</a><br>
    &#149; <a href="regular.html">Regular Expressions</a><br>
    &#149; <a href="acrtused.html">Acrtused</a><br>
    &#149; <a href="pragmas.html">Pragmas</a><br>
    &#149; <a href="precompiled.html">Precompiled Headers</a><br>
    &#149; <a href="predefined.html">Predefined Macros</a><br>
    &#149; <a href="warnings.html">Warning Messages</a><br>
    &#149; <a href="ctgCompilerErrors.html">Error Messages</a><br>
    &#149; <a href="warnings.html#runtime">Runtime Messages</a><br>
    <br>

<hr><b>Linking</b><br>

    &#149; <a href="optlink.html">Optlink</a><br>
    &#149; <a href="ctgLinkSwitches.html">Switches</a><br>
    &#149; <a href="ctgDefFiles.html">Module Definition Files</a><br>
    &#149; <a href="ctgLinkOps.html">Operation and Design</a><br>
    &#149; <a href="OptlinkErrorMessages.html">Error Messages</a><br>
    <br>

<hr><b>Win32 Programming</b><br>

    &#149; <a href="win32programming.html#win32">Win32 Programming</a><br>
    <br>

<hr><b>DOS and Win16<br>Programming</b><br>

    &#149; <a href="ctgMemoryModel.html">Memory Models</a><br>
    &#149; <a href="pointers16.html">16 Bit Pointer Types<br> and Type Modifiers</a><br>
    &#149; <a href="win32programming.html#handle">Handle Pointers</a><br>
    &#149; <a href="win32programming.html#dos">DOS</a><br>
    &#149; <a href="dos32.html">DOS 32 (DOSX)</a><br>
    &#149; <a href="win32programming.html#win16">Win16</a><br>
    &#149; <a href="win32programming.html#win16dll">Win16 DLLs</a><br>
    &#149; <a href="windowspe.html">Win16 Prolog/Epilog</a><br>
    <br>

<hr><b>C/C++ Extensions</b><br>

    &#149; <a href="contract.html">Contract Programming</a><br>
    &#149; <a href="debugstatement.html">__debug statement</a><br>
    &#149; <a href="debugstatement.html#debugdeclaration">__debug declaration</a><br>
    &#149; <a href="trace.html">Dynamic Profiling</a><br>
    &#149; <a href="html.html">Embedding C in HTML</a><br>
    <br>

<hr><b>Tools</b><br>

    &#149; <a href="bcc.html" title="Convert Borland compiler commands">BCC</a><br>
    &#149; <a href="chmod.html" title="Examine and change file attributes">CHMOD</a><br>
    &#149; <a href="cl.html" title="Convert Microsoft compiler commands">CL</a><br>
    &#149; <a href="coff2omf.html" title="Convert COFF .obj and .lib to OMF">COFF2OMF</a><br>
    &#149; <a href="coffimplib.html" title="Convert COFF import library OMF">COFFIMPLIB</a><br>
    &#149; <a href="sc.html" title="Compiler command">DMC</a><br>
    &#149; <a href="diff.html" title="Compare files">DIFF</a><br>
    &#149; <a href="diffdir.html" title="Compare directories">DIFFDIR</a><br>
    &#149; <a href="dump.html" title="Dump files in hex">DUMP</a><br>
    &#149; <a href="dumpobj.html" title="Dump object files in hex">DUMPOBJ</a><br>
    &#149; <a href="dumpexe.html" title="Dump exe files">DUMPEXE</a><br>
    &#149; <a href="exe2bin.html" title="Create .com files">EXE2BIN</a><br>
    &#149; <a href="flpyimg.html" title="Read/Write Floppy Image">FLPYIMG</a><br>
    &#149; <a href="grep.html" title="Search files for string">GREP</a><br>
    &#149; <a href="ctgHelp.html" title="Creating Help Tools">HC</a><br>
    &#149; <a href="implib.html" title="Build import libraries">IMPLIB</a><br>
    &#149; <a href="lib.html" title="Object file librarian">LIB</a><br>
    &#149; <a href="libunres.html" title="Analyze library and object files">LIBUNRES</a><br>
    &#149; <a href="make.html" title="Simple make utility">MAKE</a><br>
    &#149; <a href="makedep.html" title="Update makefile dependencies">MAKEDEP</a><br>
    &#149; <a href="me.html" title="MicroEmacs Text Editor">ME</a><br>
    &#149; <a href="obj2asm.html" title="Object file disassembler">OBJ2ASM</a><br>
    &#149; <a href="patchobj.html" title="Patch object files">PATCHOBJ</a><br>
    &#149; <a href="ctgRC.html" title="Microsoft Resource compiler">RC</a><br>
    &#149; <a href="rcc.html" title="Digital Mars Resource compiler">RCC</a><br>
    &#149; <a href="sc.html" title="Compiler command">SC</a><br>
    &#149; <a href="shell.html" title="Shell scripts">SHELL</a><br>
    &#149; <a href="smake.html" title="Manage complex projects">SMAKE</a><br>
    &#149; <a href="touch.html" title="Set file timestamps">TOUCH</a><br>
    &#149; <a href="unmangle.html" title="Format C++ mangled names">UNMANGLE</a><br>
    &#149; <a href="whereis.html" title="Search for files">WHEREIS</a><br>
    <br>

<hr><b>Porting to DMC++</b><br>

    &#149; <a href="switchtodigitalmars.html">Switching to DMC++</a><br>
    &#149; <a href="switchtodigitalmars.html#microsoft">from Microsoft</a><br>
    &#149; <a href="switchtodigitalmars.html#borland">from Borland</a><br>
    &#149; <a href="ctgPorting.html">Porting Guide</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>16 Bit Pointer Types and Type Modifiers</h1>

Digital Mars C++ provides the following keywords to modify pointer types:

<pre>
	__cs, __far,
	__handle, __huge,
	__near, __ss,
	__interrupt 
</pre>

These keywords provide support for mixed language programming 
and for mixed memory models. Although they are not necessary for 
all applications, their judicious use can significantly enhance 
program performance. 
<p>
<b>Note:</b> 
	The keywords __far, __interrupt, __handle, 
	__loadds, and __huge are ignored by default in 
	compilations using the Win32 (-mn) memory model. 
	Ignore these keywords 
	in any compilation by specifying the -NF compiler 
	option. 


<h3>__handle</h3>

This extension to the normal pointer type allows access to memory 
that can only be accessed through indirection (a handle). It is used 
for the implementation of simulated virtual memory. 
<p>

As with other pointer modifiers, __handle is placed immediately 
before the * in a pointer type description. For example: 

<pre>
	int __handle *ptr; 
</pre>

For more information, see <a href="win32programming.html#handle">Using Handle Pointers</a>. 


<h3>__huge</h3>

Huge pointers are supported through the __huge keyword. They 
are identical to __far pointers, except that they allow access to data 
objects larger than 64KB. To accomplish access to large data objects, 
the compiler inserts extra code so that __huge pointers will not roll 
over when a segment boundary is reached. 
<p>


<b>Note:</b> 
	Digital Mars C++ does not support the Huge memory model. 
<p>

For more information see
<a href="ctgMemoryModel.html">Choosing a Memory Model</a>. 


<h3>Using __near and __far with pointers</h3>

Override the default pointer type for data pointers by using 
the __near or __far keywords. For example: 

<pre>
	int __far *p;	// p is a &lt;far pointer to&gt;&lt;int&gt; 
	int * __far *p;	// p is a &lt;far pointer to&gt;&lt;pointer to&gt;&lt; int&gt; 
</pre>

The __near and __far keywords are right-associative. In other 
words, they associate with the * on their right. Remember that 
&lt;pointer to&gt; becomes &lt;near pointer to&gt; for the Tiny, Small, Medium, 
DOSX, and Phar Lap models, and a &lt;far pointer to&gt; for the Compact, 
and Large models. 


<h3>Converting between near and far pointers</h3>

Convert a far pointer to a near pointer as follows: 

<pre>
	#include &lt;dos.h&gt;
	char __near *np, __far *fp; 
	np = (char __near *) fp; 
</pre>

<b>Note:</b> 
	FP_SEG(fp) must equal DS! 
<p>

Convert a near pointer to far pointer as follows: 

<pre>
	#include &lt;dos.h&gt;
	char __near *np, __far *fp; 
	fp = MK_FP(getDS(), (unsigned)np); 
</pre>

Notice how the value of DS is obtained for constructing the __far 
pointer. 


<h3>Using Extended Keywords with const and volatile </h3>


ANSI C has introduced the const and volatile keywords as type 
modifiers. Unfortunately, their syntax is different from that of the 
extended keywords— const and volatile bind to the left, while 
the extended keywords bind to the right. This is an historical 
accident and cannot be changed. Some examples of the difference 
include: 

<pre>
	int * const p; // const pointer to int
	int __handle * p; // handle pointer to int 
	int * const *p; // pointer to a const pointer to int 
	int * __far *p; // far pointer to a pointer to int 
</pre>

A declaration with the specifier volatile tells the compiler that the 
declared object changes in an undetectable way. These objects are 
not optimized. 
<p>

ARM p. 110, Gray p. 521 

<h3>__far, __near, __ss, and __cs</h3>

These keywords support mixed memory model programming. They 
are generally used with pointer types to let the programmer access 
data that would normally be inaccessible in the memory model in 
use. They are also used to provide greater efficiency. The __near 
and __far keywords can also be used to qualify functions and 
__far may be used with data. 
<p>

The sizes of these pointer types are different and will depend on the 
memory model in use. For more information, see the section "Sizes 
and Addressability of Pointers" later in this chapter. 
<p>

For more information see
<a href="ctgMemoryModel.html">Choosing a Memory Model</a>. 

<h3>__loadds</h3>

This keyword aid those programming Microsoft Windows. 
__loadds causes the compiler to load DS from DGROUP on entry 
to the function and to restore DS on exit. The -mu compiler option 
applies __loadds to all functions. 
<p>

<h3>Interrupt Functions</h3>

Digital Mars C++ supports a very specialized function type called an 
interrupt function. It is used for creating interrupt handlers. 
Declare an interrupt function with the __interrupt keyword. 
Using the __cdecl, __far, or __loadds keywords is redundant 
when declaring an interrupt function; using the __near or 
__pascal keywords is an error. 
<p>

Interrupt functions should not be inline or non-static member 
functions. 
<p>

An interrupt function saves all the registers on the stack, reloads DS 
from DGROUP (so that global variables in the data segment can be 
accessed), and enables interrupts. At the end of the function, the 
registers are restored and an IRET instruction is executed. 
<p>

An interrupt function is normally declared as: 

<pre>
	void __interrupt isr(void); 
</pre>

or: 

<pre>
	void __interrupt isr( unsigned es, 
	unsigned ds, unsigned di, 
	unsigned si, unsigned bp, 
	unsigned sp, unsigned bx, 
	unsigned dx, unsigned cx, 
	unsigned ax, unsigned ip, 
	unsigned cs, unsigned flags); 
</pre>

The second form allows access to the values the flags and registers 
had when the interrupt occurred. 
<p>

Modifying these variables causes the corresponding register to have 
the modified value upon returning from the function. Be very sure of 
what you are doing if you modify the bp, sp, ip, cs or flags registers. 
<p>

The SS, FS and GS registers are not saved; if they need to be, use the 
inline assembler to save and restore them. The floating-point 
registers on the numeric coprocessor are not saved automatically 
either. 
<p>

Since an interrupt function sets the values of the registers upon 
function exit, using a: 

<pre>
	return exp; 
</pre>

statement will not have the expected effect. To return a value, set the 
appropriate register( s) to the value. 
<p>

Do not call an interrupt function and pass parameters to it. To pass 
values to it, place the values into registers with the inline assembler, 
and then access the register values from within the interrupt function 
using the second form of the declaration above. If you do pass 
parameters, they will appear after the "flags" parameter. 
<p>

If the interrupt function will be using a significant amount of stack, it 
may be necessary to switch to a separate stack of a known size. This 
can be done with the inline assembler. Note also that in small and 
medium model programs, SS will not be the same as DS inside the 
interrupt function. 
<p>

Some guidelines for writing interrupt functions: 

<ul>
<li> Minimize the amount of time spent in the function. Do as 
little as possible and return. 

<li> If the function is not reentrant, take great care to insure 
that it does not get called again before the first call has 
returned. 

<li> Be very careful about stack consumption. 

<li> Avoid calling runtime library functions, because they are 
not all reentrant, and may assume that SS == DS. 

<li> Digital Mars' floating-point emulator is reentrant. If a 
numeric coprocessor is installed, and floating point will 
be used in the interrupt function, save and restore the 
numeric coprocessor's state. 

<li> The interrupt function prolog modifies AX, DS and BP. 
The original values can be found in the parameters. 
</ul>

Alternatively, you can write an interrupt handler using the interrupt 
package in the run-time library. This package has the advantage of 
allowing you to designate a stack for the handler, and sets the stack 
correctly for small and medium model programs. 

<h3>Portability of Extended Keywords</h3>

Except for __ss and __handle, the extended keywords are 
portable to other 16 bit compilers for MS-DOS and Windows. One useful 
method of ensuring portability to other systems is by 
conditionally defining the extended keywords as empty: 

<pre>
	// Remove extended keywords for non Digital Mars
	// compilers 

	#if !defined(__DMC__)
	#define __far 
	#define __near
	#define __cs 
	#define __ss 
	#define __handle
	#endif 
</pre>

<h3>Sizes and Addressability of Pointers</h3>

Digital Mars C++ supports the development of both 16-bit and 32-bit 
applications. In 16-bit applications, __near and __ss pointers are 
16-bit, whereas __far and __handle pointers are 32-bit. In 32-bit 
applications, __near and __ss pointers are 32-bit, whereas __far 
and __handle pointers are 48-bit. Digital Mars C++ allows an int to 
be cast directly to a near pointer. Casting an int to a far pointer is 
not allowed and generates a syntax error. If you need to cast an int 
to a far pointer, you should first cast the int to a long and then 
cast the long to a far pointer. 
<p>

For information on using different pointer types, see 
<a href="ctgMemoryModel.html">Choosing a Memory Model</a>. 


<h3>__near pointers</h3>

In 16-bit memory models (Tiny, Small, Compact, Medium, and Large 
memory models), near pointers consist of a 16-bit offset and can be 
used to access any location within a 64KB segment. Because they 
require only two bytes of storage to hold the offset, near pointers are 
more efficient than far pointers. Near pointers also require less time 
for access. 
<p>

For near references to be correct when the processor is in real mode, 
the segment register DS must contain the correct segment value for 
data pointers. When the processor is in protected mode, the segment 
register must contain the correct selector value. CS contains the 
segment value for function pointers. 
<p>

Near pointers are used for function pointers in the Tiny, Small, and 
compact models. Near pointers are the default in the Tiny, Small, 
and Medium memory models for data pointers. 
<p>

In the 32-bit memory models (NT, DOSX, and Phar Lap), near 
pointers can be used to access any location within a 4GB segment. 
Each near pointer requires four bytes of storage to hold the offset. 
For near references to be correct, the segment register DS must 
contain the correct selector for data pointers. For function pointers, 
CS must contain the selector, rather than DS. Near pointers are the 
default for both code and data in 32-bit memory models. 


<h3>__far pointers</h3>

In 16-bit memory models, far pointers require four bytes of storage. 
Two of the four bytes contain the segment value in real mode, or the 
selector value in protected mode. The other two bytes contain the 
offset. The segment is a base address that will be put into the correct 
segment register. The offset provides an index relative to the base 
address. When a far pointer is dereferenced, the ES register is loaded 
with the segment value. Far pointers are the default for data pointers 
in the Compact, and Large models and for function pointers in the 
Medium and Large models. 
<p>

In 32-bit memory models, far pointers require six bytes: a two-byte 
selector and a four-byte offset. The selector is an index into the 
Global Descriptor Table. This index is put into the appropriate 
segment register. The offset provides an offset within the selected 
memory segment. In 32-bit programming, far pointers are only useful 
when working at operating system level. 
<p>

<b>Note:</b> 
	Never use far pointers when compiling with the NT 
	(-mn) memory model. 


<h3>__ss pointers</h3>

Digital Mars C++ provides an additional pointer type to allow the 
programmer to produce pointers to objects contained on the stack. 
Stack (__ss) pointers are offsets into the stack segment. In the Tiny, 
Small, Compact, Medium, and Large memory models this is a 16-bit 
offset, while in the DOSX, Phar Lap, and NT memory models it is a 
32-bit offset. The value in SS contains the segment value in real 
mode and the selector value in protected mode. 
<p>

When applied to a pointer, the __ss keyword is used exactly the 
same way as the __near keyword. However, the compiler 
generates code to ensure that the current segment address is set to 
the stack segment rather than the data segment. Consequently, __ss 
pointers are relative to the SS segment register as opposed to near 
pointers, which are relative to DS. If SS == DS, as in the Tiny, Small, 
Medium, DOSX, and Phar Lap models, then there is no difference 
between __ss pointers and near pointers, except for type checking. 
In the Compact and Large models, or if SS != DS, then __ss pointers 
can be used only to point to parameters and automatic variables. 
Under the same conditions, near pointers can point only to static and 
global data. (SS==CS==DS==ES at all times for programs compiled 
for the NT memory model.) 
<p>

Some specialized applications require use of the Small or Medium 
memory models but also require that SS != DS. Similarly, SS != DS in 
applications which are put into ROM, Microsoft Windows 
applications, or routines for OS/ 2 dynamic link libraries, even when 
the Small and Medium memory models are used. 
<p>

Force SS!=DS by appending a w to the -mmodel compiler 
option, for instance -msw. The __ss pointer then becomes quite 
important as auto variables can be accessed via two-byte __ss 
pointers rather than four-byte far pointers. 

<h3>Pointer examples</h3>

An example using the Compact and Large models: 

<pre>
	void func()
	{   
	    static int darray[10];// array in data seg
	    int __near *pd; // pointer into data seg 
	    int sarray[10]; // array in stack seg
	    int __ss *ps; // pointer into stack seg 

	    ps = sarray;
	    for (pd = darray; pd &darray[10]; pd++, ps++)
		*ps = *pd; 
	    pd = sarray; // Error: near pointer cannot access stack 
	    ps = darray; // Error: vice versa
	} 
</pre>


Far pointers are useful in accessing specific memory locations in the 
computer. The video display memory from the Small model is one 
example: 


<pre>
	#include &lt;dos.h&gt; 
	unsigned short __far *pvideo;
	int i; 

	/* Point into mono display ram */
	pvideo = (unsigned short __far *) MK_FP(0xB000,0); 

	/* Clear screen */
	for (i = 0; i&lt; 25 * 80; i++) 
	    pvideo[i] = 0x0700 + ' '; 
</pre>

<h3>Pointers to Functions</h3>

A near pointer to a near function returning int is 
declared with: 

<pre>
	int (__near *fp)(); 
</pre>

A far pointer to a far Pascal function returning char is declared with: 

<pre>
	char (__far __pascal *fp)(); 
</pre>

Due to limitations of this syntax, it is impossible to declare constructs 
such as a near pointer to a far function or a far pointer to a near 
function. The compiler always selects the function type according to 
the type of pointer. This compiler selection cannot be overridden. 
<p>

For more information on mixing pointer types, see
<a href="ctgMixingLanguages.html">Mixing Languages</a>. 


<br><br><br><br>

</td></table>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

