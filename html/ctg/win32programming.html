
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - Win32 Programming Guidelines
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:25:46 2006
</div>
</div>

<!-- Generated by Ddoc from win32programming.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ctg">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>
</center>

    <a href="ctg.html"><b>Compiler & Tools Guide</b></a><br>

<hr><b>Compiling</b><br>

    &#149; <a href="ctgCompilingCode.html">Compiling Code</a><br>
    &#149; <a href="C-Language-Implementation.html">C Implementation</a><br>
    &#149; <a href="CPP-Language-Implementation.html">C++ Implementation</a><br>
    &#149; <a href="ctgLanguageImplementation.html">Language Extensions</a><br>
    &#149; <a href="ctgMixingLanguages.html">Mixing Languages</a><br>
    &#149; <a href="ctgAsm.html">Assembly Language</a><br>
    &#149; <a href="ctgInlineAsm.html">Inline Assembler</a><br>
    &#149; <a href="ctgOptimizer.html">Optimizing Code</a><br>
    &#149; <a href="ctgNumerics.html">Numerics Programming</a><br>
    &#149; <a href="regular.html">Regular Expressions</a><br>
    &#149; <a href="acrtused.html">Acrtused</a><br>
    &#149; <a href="pragmas.html">Pragmas</a><br>
    &#149; <a href="precompiled.html">Precompiled Headers</a><br>
    &#149; <a href="predefined.html">Predefined Macros</a><br>
    &#149; <a href="warnings.html">Warning Messages</a><br>
    &#149; <a href="ctgCompilerErrors.html">Error Messages</a><br>
    &#149; <a href="warnings.html#runtime">Runtime Messages</a><br>
    <br>

<hr><b>Linking</b><br>

    &#149; <a href="optlink.html">Optlink</a><br>
    &#149; <a href="ctgLinkSwitches.html">Switches</a><br>
    &#149; <a href="ctgDefFiles.html">Module Definition Files</a><br>
    &#149; <a href="ctgLinkOps.html">Operation and Design</a><br>
    &#149; <a href="OptlinkErrorMessages.html">Error Messages</a><br>
    <br>

<hr><b>Win32 Programming</b><br>

    &#149; <a href="win32programming.html#win32">Win32 Programming</a><br>
    <br>

<hr><b>DOS and Win16<br>Programming</b><br>

    &#149; <a href="ctgMemoryModel.html">Memory Models</a><br>
    &#149; <a href="pointers16.html">16 Bit Pointer Types<br> and Type Modifiers</a><br>
    &#149; <a href="win32programming.html#handle">Handle Pointers</a><br>
    &#149; <a href="win32programming.html#dos">DOS</a><br>
    &#149; <a href="dos32.html">DOS 32 (DOSX)</a><br>
    &#149; <a href="win32programming.html#win16">Win16</a><br>
    &#149; <a href="win32programming.html#win16dll">Win16 DLLs</a><br>
    &#149; <a href="windowspe.html">Win16 Prolog/Epilog</a><br>
    <br>

<hr><b>C/C++ Extensions</b><br>

    &#149; <a href="contract.html">Contract Programming</a><br>
    &#149; <a href="debugstatement.html">__debug statement</a><br>
    &#149; <a href="debugstatement.html#debugdeclaration">__debug declaration</a><br>
    &#149; <a href="trace.html">Dynamic Profiling</a><br>
    &#149; <a href="html.html">Embedding C in HTML</a><br>
    <br>

<hr><b>Tools</b><br>

    &#149; <a href="bcc.html" title="Convert Borland compiler commands">BCC</a><br>
    &#149; <a href="chmod.html" title="Examine and change file attributes">CHMOD</a><br>
    &#149; <a href="cl.html" title="Convert Microsoft compiler commands">CL</a><br>
    &#149; <a href="coff2omf.html" title="Convert COFF .obj and .lib to OMF">COFF2OMF</a><br>
    &#149; <a href="coffimplib.html" title="Convert COFF import library OMF">COFFIMPLIB</a><br>
    &#149; <a href="sc.html" title="Compiler command">DMC</a><br>
    &#149; <a href="diff.html" title="Compare files">DIFF</a><br>
    &#149; <a href="diffdir.html" title="Compare directories">DIFFDIR</a><br>
    &#149; <a href="dump.html" title="Dump files in hex">DUMP</a><br>
    &#149; <a href="dumpobj.html" title="Dump object files in hex">DUMPOBJ</a><br>
    &#149; <a href="dumpexe.html" title="Dump exe files">DUMPEXE</a><br>
    &#149; <a href="exe2bin.html" title="Create .com files">EXE2BIN</a><br>
    &#149; <a href="flpyimg.html" title="Read/Write Floppy Image">FLPYIMG</a><br>
    &#149; <a href="grep.html" title="Search files for string">GREP</a><br>
    &#149; <a href="ctgHelp.html" title="Creating Help Tools">HC</a><br>
    &#149; <a href="implib.html" title="Build import libraries">IMPLIB</a><br>
    &#149; <a href="lib.html" title="Object file librarian">LIB</a><br>
    &#149; <a href="libunres.html" title="Analyze library and object files">LIBUNRES</a><br>
    &#149; <a href="make.html" title="Simple make utility">MAKE</a><br>
    &#149; <a href="makedep.html" title="Update makefile dependencies">MAKEDEP</a><br>
    &#149; <a href="me.html" title="MicroEmacs Text Editor">ME</a><br>
    &#149; <a href="obj2asm.html" title="Object file disassembler">OBJ2ASM</a><br>
    &#149; <a href="patchobj.html" title="Patch object files">PATCHOBJ</a><br>
    &#149; <a href="ctgRC.html" title="Microsoft Resource compiler">RC</a><br>
    &#149; <a href="rcc.html" title="Digital Mars Resource compiler">RCC</a><br>
    &#149; <a href="sc.html" title="Compiler command">SC</a><br>
    &#149; <a href="shell.html" title="Shell scripts">SHELL</a><br>
    &#149; <a href="smake.html" title="Manage complex projects">SMAKE</a><br>
    &#149; <a href="touch.html" title="Set file timestamps">TOUCH</a><br>
    &#149; <a href="unmangle.html" title="Format C++ mangled names">UNMANGLE</a><br>
    &#149; <a href="whereis.html" title="Search for files">WHEREIS</a><br>
    <br>

<hr><b>Porting to DMC++</b><br>

    &#149; <a href="switchtodigitalmars.html">Switching to DMC++</a><br>
    &#149; <a href="switchtodigitalmars.html#microsoft">from Microsoft</a><br>
    &#149; <a href="switchtodigitalmars.html#borland">from Borland</a><br>
    &#149; <a href="ctgPorting.html">Porting Guide</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<a name="win32">
<h1>Win32 Programming Guidelines</h1>
</a>

This chapter describes how to use the compiler to create
Win32 and Win32s applications. For information about: 

<ul>
	<li> Creating 16-bit Windows programs, see Chapter 17, 
"Win16 Programming Guidelines." 

	<li> Using the IDDE to create applications, see
	The User's Guide and Reference. 

	<li> The Win32s API, see the included Microsoft documentation.
</ul>

<h3>What's in This Chapter</h3>

<ul>
	<li> How creating 32-bit Windows applications differs from 
	creating 16-bit Windows applications. 

	<li> The distinctions between 32-and 16-bit graphical 
	environments and Digital Mars' support for Win32, Win32s 
	and development tools. 

	<li> How to compile and link various Win32 applications, 
	including applications that use MFC. 

	<li> How to compile and link Win32s applications. 

	<li> How to recompile and relink 16-bit applications to be 32-bit 
	Windows applications. 
</ul>

<h3>Some Basic Information</h3>

The following will help you understand the information in this 
chapter. 

<ul>
	<li> Windows 3.1 is a 16-bit graphical environment that runs 
on DOS, which is a 16-bit operating system. For 
simplicity, Windows 3.1 (and 3.0) will be referred to as 
Win16. 

	<li> Windows 95 and Windows NT (Windows New 
Technology) are 32-bit operating systems. For simplicity, 
Windows 95 and Windows NT will be referred to as 
Win32. 

	<li> Win32s is an NT emulator, or operating system extension, 
that allows you to run Win32 applications on a Win16 
host. 

	<li> 32-bit applications for Windows are referred to as Win32 
applications. 16-bit applications for Windows are referred 
to as Win16 applications. 

	<li> The Win32 Applications Programming Interface (API), the 
graphical environment for Windows 95 and NT, is very 
similar to the Windows 3 graphical environment. 
</ul>

For machines based on the Intel 80x86 architecture, a 32-bit 
operating system improves the performance of data manipulation 
and calculations because it avoids the overhead of loading segment 
registers. Applications that are data-, memory-, or calculation-intensive 
may perform significantly better in 32-bit mode. 


<h3>About Win32s</h3>

Win32s is an NT emulator or operating system extension that allows 
you to run Win32 applications on a Windows 3.1 host. The "s" in 
Win32s stands for Win32 subset: Win32s supports almost all Win32 
API features. 
<p>

<b>Note:</b> 
	Win32s applications built with C++ 
	Version 7 will only run on version 1.15 and above 
	of Win32s. 

<h3>Advantages of Win32s over Win16</h3> 

Win32s, included with Digital Mars C++, gives you the following 
advantages over conventional Win16 applications: 

<ul>
	<li> The ability to run 32-bit programs under Windows 3.1. 

	<li> The ability to manipulate data and perform calculations in 
	32-bit mode, which improves the performance of 
	applications that are data-, memory-or calculation 
	intensive, such as spreadsheets, simulation packages, 
	desktop publishing and CAD packages. 

	<li> Features previously unavailable in Windows 3.1, such as 
	sparse memory. 
</ul>

Win32s lets your Win32 applications make 32-bit calls to Windows 
3.1, where graphics and windowing operations are performed. 
Win32s consists of a virtual device driver (VxD) and a set of dynamic 
link libraries (DLLs) that extend Windows to support 32-bit 
applications. 


<h3>Key Win32s features</h3> 

Many features are available through the Win32s Applications 
Programming Interface (API), such as: 

<ul>
	<li> Complete window interface 

	<li> All graphics functions (GDI) 

	<li> Object linking and embedding (OLE), version 1.0 

	<li> Memory-mapped files (backed by disk image) 

	<li> Network support, such as Netbios and named pipes 

	<li> Common dialogs 

	<li> Named shared memory 
</ul>

<h3>Building Win32 and Win32s Applications</h3>

Digital Mars C++ includes a set of tools that make it easy to create and 
debug Win32 and Win32s applications from either the command line 
or within the integrated environment. By setting switches, all the 
tools— compiler, linker, resource compiler, and resource editors— 
generate the correct type of 32-bit application. 
The following is basic information useful for building Win32 and 
Win32s applications: 

<ul>
	<li> The compiler generates
Microsoft OMF object files. OPTLINK 
does not use Microsoft COFF files. 

	<li> In order to compile with the correct startup code, Win32 
and Win32s executables need to contain a WinMain() 
entry point. This causes the compiler to generate a 
reference to the _acrtused startup function. 

	<li> Use a module definition file to define explicitly as many 
criteria as possible. To establish the proper executable for 
NT, for example, place EXETYPE NT in your module 
definition file, and use the SUBSYSTEM[ WINDOWS] 
keyword. For further information on Win32 .def files, 
see Chapter 11, "Definition File Directives." 

	<li> The -mn switch is the memory model switch for Win32 
applications available from the command line interface. 
This is the 32-bit flat model, essentially a "small model" 
with 4GB addressing. 

	<li> Creating a resource file for a Win32 application is no 
different from creating one for a Win16 application. The 
resource compiler takes a resource definition file and 
produces a 32-bit .res file. Having 16-bit compatibility 
with the .res files helps you build Win32 applications 
from Win16 applications. 

	<li> When creating Win32 applications, OPTLINK provides 
transparent linking and binding of .res files to an .exe 
file. 16-bit .res files are converted to 32-bit during the 
link process. 

</ul>

The OPTLINK linker does not support COFF format .lib 
or .obj files produced by Microsoft tools. 
<p>

<b>Note:</b>
	To developers using NT: OPTLINK (the linker) does not 
	accept COFF resource files, but does accept 
	standard Microsoft resources files. 


<h3>Compiling Win32 Executables</h3>

This section explains how to create various 
kinds of Win32 executables. 

<h3>Compiling with MFC 3.x</h3>

If your Win32 application uses MFC 3.x libraries, see the "READ ME" 
file included with the distribution for a list of the options, libraries, 
and #defines you need to build various targets with the latest MFC 
release. Note that, for all MFC 3.x libraries, you need to compile with 
the NT (-mn) memory model. 


<h3>Compiling Win32 DLLs</h3>

To compile Win32 DLLs, use these compiler options: 

<pre>
	-mn -WD 
</pre>

To write a Win32 DLL, you need to specify the entry point 
DllMain(). When the compiler detects a call to DllMain() in a 
32-bit compilation, it generates a reference to the _acrtused_ dll 
startup function, and links with the appropriate startup code. 
<p>

Unlike previous versions of C++, this startup code calls 
static constructors and performs other initialization steps before 
calling DllMain(). 


<h3>Converting older Win32 DLLs</h3> 

To convert Win32 DLLs built with previous versions of 
C++ to work with this version, make the changes listed below: 

<ul>
	<li> Remove any references to #pragma startaddress. 

	<li> Provide a reference to DllMain(). 

	<li> If the entry point routine was not DllMain(), write a 
	new DllMain() stub that calls the entry point routine 
	upon process_attach(). 

	<li> If you need to write code that is called prior to static 
	construction, check the source for the run-time library to 
	determine what calls are necessary to initialize the library. 
	Then use #pragma startaddress to specify the entry 
	point, and call the initialization routines as needed. 

</ul>

<b>Note:</b> 
	Win32 DLLs compiled with previous versions of 
	C++, in which the entry point is specified 
	with #pragma startaddress, need to be 
	rewritten to call DllMain() instead. Otherwise 
	any static constructors will not be called, and any 
	run-time library calls will not work as expected 
	because proper initialization has not taken place. 


<h3>Building Console Applications</h3>

A console application is a character mode application that runs 
under Windows 95 or NT. Digital Mars C++ supports console mode 
applications. 
<p>

To compile console applications, use the -mn compiler option, and 
specify the SUBSYSTEM CONSOLE directive in the .def file. 


<h3>Startup code for console applications</h3> 

When the compiler detects a call to main() in a 32-bit compilation, 
it generates a reference to the _acrtused_ con startup function, 
and links with the appropriate startup code. You no longer need to 
explicitly link in cc.obj, as with previous versions of
C++; it is now part of snn.lib. 


<h3>Compiling Win32s Executables</h3>

To compile Win32s executables, use the -mn and -WA compiler 
options. 


<b>Note:</b> 
	HP Dashboard does not support Win32s. If you try 
	to debug a Win32s application under Dashboard, 
	the debugger receives a GPF message from the 
	application being debugged. 


<h3>Compiling Win32s DLLs</h3>

To compile Win32s executables, use the -mn and -WA compiler 
options. 
<p>
<b>Note:</b> 
	To create libraries from Windows NT System DLLs 
	(kernel32.dll, for example), use the IMPLIB 
	utility and specify the /system switch. IMPLIB is 
	available only from the command line, not via the 
	IDDE. 


<h3>Win32 Definition File Directives</h3>

This section lists the directives used in definition files for Win32 
programs. For descriptions of these directives see Chapter 11, 
"Definition File Directives." 

<pre>
	NAME name [BASE=number] 

	LIBRARY name [ BASE= number | PROCESSINIT |
		PROCESSTERM | THREADINIT | 
		THREADTERM ] 

	DESCRIPTION 'descriptive line' 

	EXETYPE NT 

	HEAPSIZE [number, commit] 

	STACKSIZE [number, commit] 

	STUB 'filespec' 

	SUBSYSTEM [ NATIVE | WINDOWS | CONSOLE | POSIX ] 

	VERSION number[. number] 

	CODE [READ] [WRITE] [EXECUTE ] [SHARED] 

	DATA [READ] [WRITE] [EXECUTE] [SHARED] 

	SEGMENTS
	{   name [CLASS 'class'] 
		[READ] [WRITE] 
		[EXECUTE] [SHARED]
	} 


	IMPORTS { [internal=] externalfile. func } 

	EXPORTS { parms [=intname] [@number [NONAME]] 
		[CONSTANT]} 
</pre>

<h3>Recompiling Win16 Applications for Win32</h3>

To convert to a Win32 or Win32s application to a Win16 application 
created with the C/C++ compilers, try these suggestions: 

<ul>
	<li> In order for Win32 to interpret handles properly, declare 
	all handles as HANDLE, HINSTANCE, or similarly. Win32 
	will not properly interpret handles that use int or WORD. 
	The sample program ZOOM illustrates how to declare 
	handles correctly. 

	<li> When you compile with the -mn or -mf memory models, 
	the following keywords are ignored: __far, __huge, 
	__interrupt, __loadds, and __handle. 

	<li> In all Windows NT code, SS==DS==ES at all times; 
	otherwise the NT API functions themselves can fail. When 
	using the -mn or -mf memory models, SS==DS==ES 
	automatically for all functions, including run-time 
	library functions. 

	<li> Some Win16 API functions are not supported by Win32. 
	For example, replace calls to MoveTo() with 
	MoveToEx() calls. 

	<li> Replace all machine-specific code with non-machine 
	specific C or C++ functions to make your code as portable 
	as possible. For example, Use time() and 
	localtime() instead of calling int86(). 

	<li> For message passing and other functions that use 
	wParam, declare parameters with WPARAM type. This is 
	especially true for message passing between windows, 
	such as with SendMessage(). Using the WPARAM type 
	allows the parameter to be interpreted as a 16-bit value 
	for Win16 and 32-bit value for Win32. Functions declared 
	as lParam are dwords in both implementations. 

	<li> Win32s executables that call 16-bit DLLs need to use the 
	Universal Thunk mechanism to communicate. 

	<li> For mixed model programs, perform these steps: 
	<ol>
	<li> Select the Large memory model. 
	<li> Rebuild the project as a Win16 application. 
	<li> If the project builds and runs correctly, convert it to 
	Win32, but first make any of the adjustments previously 
	mentioned. 
	</ol>
</ul>

<b>Note:</b> 
	For more tips on how to solve specific problems 
	that might occur when porting 16-bit code to 
	Win32, see Chapter A, "Porting Guidelines." 


<h3>Converting Non-Digital Mars Win16 Applications to Win32 Applications</h3> 

The following information will help you convert 16-bit programs 
developed with other programming tools to be 
Win32 or Win32s applications. 
<p>

Start with a bug-free Win16 application. Be sure your Win16 
application compiles and runs without any compiler or linker errors 
or warnings. 
<p>

Convert the application to be a Win16 application. For 
instructions on porting code from Borland or Microsoft, see Chapter 
22, "Switching to Digital Mars C++." Be sure the converted program 
compiles and runs with Digital Mars C++ without any errors or 
warnings. 
<p>

Save the original source code and makefile, preferably in another 
project directory. Now that the application is a Digital Mars Win16 
application, convert it to Win32, following the hints above. 
<p>

Finally, after a clean build, preferably with no warnings, test the 
application. 
<p>

If you are targeting both Win32 and Win32s, you should test these 
applications thoroughly in both environments, as there are a number 
of significant differences between Win32 and Win32s. 


<hr>
<a name="win16">
<h1>Win16 Programming Guidelines</h1>
</a>

This chapter describes how to use the compiler and linker to create
Windows 3.x applications and DLLs. For the compiler, it explains how to
choose memory models, and select the entry and exit code (if any) you want
to generate for functions. For the linker, 
it describes switches and definition (.def) file statements for linking 
Windows objects. 
<p>
For information about: 

<ul>
	<li> Creating Windows DLLs, see Chapter 19, "Building and 
	Using Windows DLLs." 

	<li> Using the IDDE to create Windows applications and DLLs, 
	see The User's Guide and Reference. 

	<li> Win32s and Win32 programming, see Chapter 16, "Win32 
	Programming Guidelines." 

	<li> Using the WINIO library, see the Run-Time Library 
	Reference. 
</ul>

<h3>What's in This Chapter</h3>

<ul>
	<li> Choosing a memory model and prolog/ epilog code for a 
	Windows program. 

	<li> Recompiling MFC 2.5 code for Digital Mars C++. 

	<li> SC and CL options for Windows programming. 

	<li> Definition file directives for Win16 programs. 
</ul>

<h3>Compiling Windows Programs</h3>

This section describes how to choose memory models and use 
prolog and epilog code when compiling Windows programs with 
C++. 


<h3>Choosing a memory model</h3>

You can use these memory models in Windows programs: 
<ul>
	<li> Small 
	<li> Medium 
	<li> Compact 
	<li> Large 
</ul>

We recommend compiling Windows applications with the 
Large model, as this minimizes the problems associated with mixed-model 
programming. Windows 3.0 and later eliminate any advantage 
to using the Medium memory model. It is especially important to use 
the Large model when compiling DLLs, since some functions in 
the run-time library work correctly only in DLLs that are 
compiled with the large model. Also, Digital Mars C++ only supports 
MFC in the Large model. 
<p>

In general, if in doubt about what model to use, use the 
Large model. Specify the Large model with the -ml compiler option 
(see Chapter 2, "Compiling Code"), or use the Memory Models 
subpage on the Build page of the IDDE's Project Settings dialog 
box. (The compiler will use the Small model unless you specify 
otherwise.) 
<p>

<b>Note:</b> 
	You cannot compile Windows 3.x programs with 
	the Tiny, DOSX, Phar Lap, or NT memory models. 
<p>
Windows applications usually consist of several source files. Always 
compile all the files in a Windows application with the same 
(preferably Large) memory model if possible, or explicitly declare a 
type for each pointer in a function prototype. If you are mixing near 
and far data references, make sure that all declarations match their 
corresponding definitions, or hard-to-find bugs can result. 
<p>

For more information, see the section "Fine-Tuning with Mixed 
Model Programming" in Chapter 7, "Choosing a Memory Model." 

<h3>Choosing entry and exit (prolog/epilog) code</h3>

C++ generates different types of entry code (the prolog) 
and exit code (the epilog) for functions in Windows applications. 
Different types of prolog/epilog code yield different instructions in 
the generated code and affect the size of the executable. 
<p>

You can choose the type of entry/ exit code you need from the 
Windows Prolog/ Epilog subpage on the Build page of the IDDE's 
Project Settings dialog box, or with the -W command line option. 
See "-W Compile for Microsoft Windows" in Chapter 2, "Compiling 
Code," for details about the -W option and modifiers. 
<p>

When you select the No Prolog/ Epilog option (-W-or -W0), the 
compiler does not generate any prolog or epilog code. 
<p>

<b>Note:</b> 
	For compatibility with Microsoft C and C++, 
	Digital Mars C++ supports the extension 
	__declspec(naked), which tells the compiler 
	not to generate prolog/ epilog code for individual 
	functions. For information see Chapter 3, "Digital Mars 
	C++ Language Implementation." 
<p>

When you select the Full Prolog/ Epilog for all far Functions option 
(-W or -W1), the compiler generates one type of prolog and epilog 
for all far functions. 
<p>

When you select the Reduced Prolog/ Epilog for non-exported far 
Functions option (-W2), two types of prolog and epilog result. All 
exported far functions have the prolog and epilog shown for the Full 
Prolog/ Epilog option. 
<p>

When you select the Smart Callbacks -Load DS from SS for far 
Functions option (-W3), the compiler compiles far functions with a 
smart prolog and epilog that loads the data segment from the stack 
segment. 
<p>

For more information on Windows entry and exit 
code, see Chapters 7 and 19 in Programming Windows 3.1 by Charles 
Petzold (3rd Ed.). 
<p>

<b>Warning:</b>
	Only use the "Smart Callbacks" option with 
	applications in which the data segment is the same 
	as the stack segment (DS== SS). Do not use it with 
	DLLs. 
<p>

When you select the Windows Protected Mode Executable option 
(-WA), the compiler generates a protected mode Windows 
application with callback functions marked with __export. 
<p>

When you select the Windows Protected Mode DLL option (-WD), 
the compiler generates a protected mode Windows DLL with 
callback and exported functions marked with __export. 


<h3>Recommendations for using the prolog/ epilog options</h3>

The following combinations of options are recommended: 

<ul>
	<li> To get a program working, just use -W. 

	<li> For maximum program speed and compactness, use -WA 
	or -WD. 

	<li> When you are using -WA or -WD and want to debug the 
	resulting executable, use the m (generate INC BP / DEC 
	BP to mark far stack frames) modifier also. This enables 
	many debuggers (including the Digital Mars debuggers) to 
	distinguish between near and far call frames. 

	<li> Use the -2 (optimize for 80286 CPU) compiler option in 
	combination with -W1 when compiling applications or 
	DLLs that will run in protected mode only. You can also 
	consider using -3 or -4, provided you specify that the 
	application will only run in enhanced mode. 
</ul>

You should avoid these combinations of options: 

<ul>
	<li> Don't use -W3 or -WA for code that will be part of a DLL. 

	<li> Don't use -Ws (smart callbacks) for code that will be part 
	of a DLL. 

	<li> When using -W2, -WA, or -WD, make sure you mark all 
	callback functions and exported functions as __export. 

	<li> Don't use -WA or -WD on code to be run in Windows real 
	mode. 
</ul>

If your program defines a virtual member function that you need to 
call from a DLL: 

<ul>
	<li> If _loadds (or -mu) is not used for the function, DS will 
	probably not have the correct value in it when the 
	function is called. 

	<li> If _loadds (or -mu) is used, DS will have the correct 
	value in it as long as there is only one instance of the 
	program running. A second instance will have DS set to 
	the value for the first instance. 
</ul>

A virtual function is a callback function. Callback functions cannot 
be called directly from a program; they can only be called via a 
pointer returned by the Windows API function 
MakeProcInstance(). They also must be compiled with a 
Windows prolog/ epilog (-W), which is impractical for virtual 
functions. Therefore, do not reference static or global data in a 
virtual function meant to be called from a DLL, or else use near 
pointers. 


<h3>Using the -Wb option</h3>

The -Wb option (assume DS != DGROUP) causes the compiler to 
issue a warning whenever a segment fixup is done to DGROUP. -Wb 
does not affect code generation; it only reports when a DGROUP 
segment fixup is generated. If your program is using an alternate 
data segment, a segment fixup to DGROUP could be a program bug. 
<p>

In Large model code, DGROUP fixup can be triggered by constructs 
like this: 

<pre>
	static int x;
	static int *px = &x; /* DGROUP fixup */ 
	static char *p = "abc"; /* DGROUP fixup */ 
</pre>

To eliminate the fixup, make the pointers near pointers: 

<pre>
	static int __near *px = (int __near *)&x;
	static char __near *p = "abc"; 
</pre>

Using near pointers will result in DGROUP relative fixups, not 
DGROUP segment fixups. Alternatively, the pointers can be initialized 
at run time, as the compiler generates code that uses DS to initialize 
segment values. 
<p>

Eliminating DGROUP segment fixups is useful for: 

<ul>
	<li> Special purpose code, where the data segment needs to 
be relocatable. 

	<li> Embedded systems, where the data segment will be 
initialized from a ROM-based image. 

	<li> 16-bit Windows DLLs, where the DLL was made to be 
multi-instanced by creating multiple copies of DGROUP at 
run time. 
</ul>

The -Wb option can be useful in tracking down hard to find bugs in 
the kinds of programs listed above. 
<p>

<b>Note:</b> 
	-Wb will cause the compiler to generate errors if 
	you are using __loadds (because DS is reloaded 
	from DGROUP), or if you are using -Wd (load DS 
	from DGROUP) for Windows prologs. 


<h3>Compatibility with Microsoft</h3>

The table below list Microsoft C Version 7 and Visual C++ options for 
generating prolog/ epilog code, and their Digital Mars C++ equivalents: 


<pre>
	Table 17-1 VC++ options and SC++ equivalents 

	Microsoft Digital Mars Result

	-Gw -W	Full Windows prolog/ epilog for far functions. 
	-Au -mwu Assume DS!= SS and load DS on entry to each function. 
	-Aw -mw Assume DS!= SS. 
	-GA -WA Optimized protected mode Windows application. 
	-GD -WD Optimized protected mode Windows DLL. 
	-GEa -Wa Load DS from AX. 
	-GEd -Wd Load DS from DGROUP. 
	-GEe -We Emit EXPDEF records for all exported functions. 
	-GEf -W-r Create prolog/ epilog code for all far functions. 
	-GEm -Wm Add inc BP/ dec BP to prolog/ epilog for far functions. 
	-GEr -W2V Real mode, reduced prolog for non-exported functions. 
	-GEs -Ws Load DS from SS. 
	-Gq -Wtxme Reduced prolog/ epilog. Equivalent to 
		-GW for MSC V6. (Digital Mars C/C++ 
		generates a full prolog/ epilog for 
		__far __export functions; MSC V6 
		does not.) 
	-GW -Wtxmev -D_ WINDOWS
		Reduced prolog/ epilog for real mode 
		Windows functions. 
</pre>


<h3>Recompiling MFC 2.5 Code for Digital Mars C++</h3>

When recompiling MFC 2.5 code for Digital Mars C++, use the 
compiler options listed below for the libraries linked with: 


<pre>
	Table 17-2 Compiler options for MFC 2.5 compilations 
	Use these options... With these libraries...

	-WA -ml lafxcw 
	-WA -ml -D_DEBUG lafxcwd 
	-WD-r -ml -D_USRDLL lafxdw 
	-WD-r -ml -D_DEBUG -D_USRDLL lafxdwd 
	-WA-r -ml -D_DEBUG -D_AFXDLL smfc25d (for Windows application) 
	-WD-r -ml -D_DEBUG -D_AFXDLL smfc25d (for Windows DLL) 
	-WA-r -ml -D_AFXDLL smfc25 (for Windows application) 
	-WD-r -ml -D_AFXDLL smfc25 (for Windows DLL) 
	-WA-r -ml -D_DEBUG -D_AFXDLL smfco25d, mfco250d (for Windows application) 
	-WD-r -ml -D_DEBUG -D_AFXDLL smfco25d, mfco250d (for Windows DLL) 
	-WA-r -ml -D_AFXDLL smfco25 (for Windows application) 
	-WD-r -ml -D_AFXDLL smfco25 (for Windows DLL) 
	-WA-r -ml -D_AFXDLL smfcd25 (for Windows application) 
	-WD-r -ml -D_ AFXDLL smfcd25 (for Windows DLL) 
	-WA-r -ml -D_ DEBUG -D_ AFXDLL smfcd25d (for Windows application) 
	-WD-r -ml -D_ DEBUG -D_ AFXDLL smfcd25d (for Windows DLL) 
</pre>


You might also need the following options: 

<ul>
	<li> Use the -gf compiler option if you are linking with these 
libraries: smfc25d. lib and mfc250d. lib. In general, 
use -gf when using the DLL form of MFC. 

	<li> Use the -g compiler option if you are linking with these 
libraries: lafxcwd. lib and lafcdwd. lib. 
</ul>

<b>Note:</b> 
	The following libraries are only necessary if your 
	application or DLL is using the DLL version of MFC 
	and uses the OLE 2.0 and ODBC MFC classes: 
	smfcd25[d].lib 
	smfco25[d].lib 
	mfco250[d].lib 
	mfcd250[d].lib 
<p>

For more information on the using the MFC 2.5 libraries, see the 
"read me" file SRC\MFC16\mfcsrc.txt in the distribution. 


<h3>Win16 Definition File Directives</h3>

This section describes the directives you use in definition files for 
Win16 programs. For descriptions of these directives see Chapter 11, 
"Definition File Directives." 

<pre>
	NAME name[ WINDOWAPI| WINDOWCOMPAT| NOTWINDOWCOMPAT ] [ NEWFILES ] 

	LIBRARY name [ INITGLOBAL | INITINSTANCE ] 

	DESCRIPTION 'descriptive line' 

	EXETYPE [WINDOWS 3.00 | WINDOWS 3.10 | DOS4 | DOS | UNKNOWN] 

	HEAPSIZE [number | MAXVAL] 

	NEWFILES 

	PROTMODE 

	REALMODE 

	STACKSIZE number 

	STUB 'filespec' 

	CODE [PRELOAD | LOADONCALL] [EXECUTEONLY | EXECUTEREAD] 
		[MOVEABLE | FIXED ] [IOPL | NOIOPL] 
		[CONFORMING | NONCONFORMING] [DISCARDABLE | NONDISCARDABLE] 
		[SHARED | NONSHARED] 

	DATA [NONE | SINGLE | MULTIPLE] [PRELOAD | LOADONCALL] 
		[MOVEABLE | FIXED ] [READONLY | READWRITE] 
		[IOPL | NOIOPL] [SHARED | NONSHARED] 

	SEGMENTS
	{   name [CLASS 'class'] 
		[PRELOAD | LOADONCALL] [EXECUTEONLY | EXECUTEREAD] 
		[MOVEABLE | FIXED ] [READONLY | READWRITE] 
		[DISCARDABLE | NONDISCARDABLE] [IOPL | NOIOPL] 
		[NONCONFORMING | CONFORMING] [SHARED | NONSHARED] } 

	IMPORTS { [internal=] externalfile.func } 

	EXPORTS { extname [= intname] [@ number [RESIDENTNAME | NONAME]] 
		[parms] [NODATA] } 
</pre>

<hr>
<a name="dos">
<h1>DOS Programming Guidelines</h1>
</a>

This chapter describes how to use the compiler and linker to
create DOS programs. For the compiler, it explains how to choose a
memory model. For the linker, it describes switches and definition
(.def) file syntax for linking DOS objects. 
<p>
For information about: 

<ul>
	<li> Using the IDDE to create DOS applications, see the User's 
Guide and Reference. 

	<li> Creating WINIO applications, see the Run-Time Library 
Reference. 

	<li> Creating Windows 3. 1 applications and DLLs, see Chapter 
17, "Win16 Programming Guidelines." 

	<li> Win32 and Win32s programming, see Chapter 16, "Win32 
Programming Guidelines." 
</ul>

<h3>What's in This Chapter</h3>

<ul>
	<li> An overview of how to choose a memory model for a 
DOS program. 

	<li> Definition file directives for DOS programs. 
</ul>

<h3>Choosing a Memory Model for DOS Programs</h3>

This section provides an overview of how to choose a memory 
model when compiling DOS programs.
<p>
For a detailed description of all the memory models 
and guidelines for when to use each one, see Chapter 7, "Choosing a 
Memory Model." 


<h3>Real mode memory models</h3>

You can use these memory models for real mode DOS programs: 

<ul>
	<li> Tiny (-mt compiler option) 
	<li> Small (-ms compiler option) 
	<li> Medium (-mm compiler option) 
	<li> Compact (-mc compiler option) 
	<li> Large (-ml compiler option) 
</ul>

<b>Note:</b> 
	The Virtual memory model (-mv) and the Virtual Code 
	Management system are no longer supported. 


<h3>32-bit protected mode memory models</h3>

If your compilation will run in 32-bit protected mode, you can use 
either of these two models: 

<ul>
	<li> DOSX (-mx compiler option) 
	<li> Phar Lap (-mp compiler option) 
</ul>

The DOSX memory model (-mx) is compatible with the DOSX 386 
DOS extender, available from Flashtek. The Phar Lap memory model 
(-mp) is compatible with the Phar Lap 32-bit DOS extender, 
available from Phar Lap. 
<p>

Always try to compile all the files in a DOS application with the 
same memory model or explicitly declare a type for each pointer in a 
function prototype. If you are mixing near and far data references, 
make sure that all declarations match their corresponding definitions, 
or hard-to-find bugs can result. 
<p>

For more information, see Chapter 7, "Choosing a Memory Model." 

<h3>Definition File Directives</h3>

You use the following directives in definition files for DOS and 
DOSX programs. For information on these directives see Chapter 11, 
"Definition File Directives." 

<pre>
	EXETYPE [DOSX | DOS] 
	REALMODE 
	STACKSIZE number 
</pre>

<hr>
<a name="win16dll">
<h1>Building and Using Windows DLLs</h1> 
</a>

Dynamic linked libraries (DLLs) are a powerful part of Windows.
They let multiple programs use a single copy of the same library
at run-time, thus saving both memory and storage space. DLLs also
improve performance since the program is no longer linking on the 
fly. 
<p>

This chapter describes how to write and compile DLLs under 
Windows 3.1, and call a DLL function from another program. For 
information on compiling Win32 DLLs, see Chapter 16, "Win32 
Programming Guidelines." 


<h3>What's in This Chapter</h3>

<ul>
	<li> How to initialize a DLL. 
	<li> How to use WEP. 
	<li> How to export functions. 
	<li> Compiling a DLL. 
	<li> Using a DLL in an application. 
	<li> Using a C++ DLL in a C application. 
</ul>

<h3>Writing a DLL</h3>

This section describes the three steps for creating a Windows 
dynamic linked library (DLL): 

<ul>
	<li> Writing the source code 
	<li> Writing the definition file 
	<li> Compiling the DLL 
</ul>

It also discusses how to avoid problems if you use standard library 
functions in your DLL. 


<h3>Initializing the DLL</h3>

Your DLL must include an initialization function named 
LibMain(), which is called when the DLL is first used. You can 
perform any initialization the DLL needs in this routine. 
<p>

<b>Note:</b> 
	When you compile a DLL, the compiler 
	automatically includes some start-up code in it. 
	When you use the DLL, Windows calls that start-up 
	code, which, in turn, calls your LibMain() 
	function. 
<p>

The following example shows a typical skeleton for LibMain(): 

<pre>
	int FAR PASCAL LibMain(HANDLE hInstance,
		WORD wDataSeg, WORD wHeapSize, 
		LPSTR lpsxCmdLine )
	{ 
	    /*
	     * Perform any initialization here. 
	     * ...
	     */ 

	    /*
	     * Unlock the DLL data segment if it's 
	     * moveable.
	     */ 
	    if (wHeapSize &gt; 0)
		UnlockData(0); 

	    /*
	     * Return 1 if LibMain() is successful. 
	     */
	    return 1; 
	} 
</pre>

LibMain() must be declared FAR PASCAL. It has four arguments, 
described in Table 19-1. 

<pre>
	Table 19-1 Arguments to LibMain() 

	Argument Description

	hinst The DLL's instance handle. 
	wDataSeg The value of the Data Segment (DS) register. 
	cbHeapSize The DLL's heap size, as set in its definition file. 
	lpszCmdLine Command line information. It's rarely used. 
</pre>


The start-up code that the compiler adds to your DLL locks 
the data segment into memory. If you want the DLL's data segment 
to be re-locatable, you must unlock it with UnlockData(). 
<p>

If LibMain() successfully initializes your DLL, return 1. Otherwise, 
return zero, and Windows unloads the DLL from memory. 


<h3>Using WEP when the DLL is terminated</h3>

The run-time library provides a default Windows Exit 
Procedure (WEP()), which is called when a DLL is terminated or 
Windows exits. This function calls static destructors, calls 
atexit(), and performs other typical cleanup services. 
<p>

Before calling static destructors, WEP calls the function _WEP. The 
run-time library provides a _WEP that does nothing. If your DLL 
needs to perform any special cleanup (such things as setting values 
upon exit, or displaying messages) before Windows unloads it, 
include a _WEP termination function. 
<p>

To allow your DLL to use the default WEP, write EXPORT WEP in the 
DLL's module definition file. For related information, see the section 
"Writing the definition file" later in this chapter. 
<p>

<b>Note:</b> 
	In C++ Version 6, users were required to 
	provide their own WEP. A default WEP is now 
	provided for compatibility with Microsoft C++. If 
	you export your own WEP function, it automatically 
	overrides the default WEP. However, your code is 
	then responsible for all cleanup. 
<p>

<h3>Declaring functions to export</h3>

Functions that other applications or libraries call must be declared as 
FAR, because they will not be in the same segment as the code that 
calls them. You may also want to declare them as PASCAL, because 
Pascal linkage is more efficient than C linkage. The following 
function definition is declared implicitly as residing in a far code 
segment, via the commonly used CALLBACK macro; just as functions 
shown in all previous examples, it can be called by other 
applications or libraries: 

<pre>
	int CALLBACK AddTwo(int x)
	{ 
	    return (x + 2);
	} 
</pre>

Read more about declaring functions to export in the 
section "Writing the definition file" later in this chapter. 


<h3>The DS and SS registers</h3>

Unlike an application, a DLL does not have its own stack. Instead, 
the DLL uses the stack of the application that called it, so the data 
segment DS and stack segment SS registers are not the same. As in 
Large and Compact memory models, DS does not equal SS; this is 
the default situation for DLLs. (For more information, see Chapter 2, 
"Compiling Code.") The difference can cause problems if you use 
code that expects the DS and SS registers to be the same, and you 
compile your DLL in a memory model that uses near pointers (the 
Small and Medium memory models). For example, the
standard libraries for the Small and Medium memory models expect 
the DS and SS registers to be the same. 
<p>

For more information on 
memory models, see 
Chapter 7, "Choosing a 
Memory Model." 
<p>

Suppose this function is in a DLL:

<pre>
	void myDLLFunc()
	{ 
	    char *from="hello there", to[25]; 
	    strcpy(to, from);
	} 
</pre>


If you compile your program with the Small or Medium memory 
model, the compiler will raise an error. strcpy() expects 
its arguments to be near pointers, so it expects the pointers to be 
relative to the data segment. However, the pointers from and to are 
relative to the calling application's SS. 
<p>

With most functions, you can avoid this problem two ways. One way 
is to compile the DLL with the Large memory model, which uses far 
pointers. The other way is to declare the variable you pass to be 
static or global; this stores it in the DLL's data segment. For example, 
the previous function would look like this: 

<pre>
	void myDLLFunc()
	{ 
	    static char *from="hello there", to[25]; 
	    strcpy(to, from);
	} 
</pre>


Some functions in the standard library will work correctly 
only in DLLs that are compiled with the Large memory model. For 
example, file I/ O functions such as fprintf() call several internal 
functions with their own local variables. When you compile your 
DLL in the Medium or Small memory model, the internal functions 
that the file I/ O functions call expect their pointer arguments to be 
relative to the data segment. But the arguments are relative to the 
calling application's stack segment. The application will cause a 
general protection fault because it looks for the data in the data 
segment instead of in the stack segment. 
<p>

When you write a function that DLL functions may call, be sure your 
function's pointer arguments are far pointers. 


<h3>Compiling a DLL</h3>

Once you've written a DLL, the next step is to compile it. Several 
considerations must be kept in mind, beginning with writing the 
module definition file. 


<h3>Writing the definition file</h3>

You must write a module definition file for your DLL that lists all the 
functions that other applications or libraries may use. The following 
shows an example of a module definition file for a DLL that exports 
AddTwo() and uses the termination routine WEP(): 

<pre>
	LIBRARY MyDLL
	DESCRIPTION 'MyDLL --The DLL I Wrote' 
	EXETYPE WINDOWS
	CODE MOVEABLE DISCARDABLE 
	DATA SINGLE MOVEABLE
	HEAPSIZE 0 
	EXPORTS
		_AddTwo @1 
		_TimesTen @2
		WEP @3 RESIDENTNAME 
</pre>

For more information on 
writing definition files for 
DLLs, see Chapter 16, 
"Win32 Programming 
Guidelines." 
<p>

The LIBRARY statement is mandatory and specifies that this is a 
dynamic-linked library, not an application. The name of the library, 
MyDLL, follows the keyword. It is a good idea to use the same name 
in this statement and in the name of the .dll file. 
<p>

The DESCRIPTION statement is optional and can contain a 
maximum of 128 characters for describing the DLL. 
<p>

The EXETYPE statement is mandatory and specifies what kind of 
executable this is. For a Windows DLL, you must specify WINDOWS. 
<p>

The DATA statement is mandatory and specifies the attributes for the 
DLL's data segment. You must include SINGLE. It specifies that 
there can be only one instance of a library in memory no matter how 
many applications access it. You can include other keywords to 
specify more attributes. For example, including MOVEABLE allows 
the memory manager to move the segment if necessary. 
<p>

The HEAPSIZE statement is optional and specifies the minimum 
amount of space for the DLL's local heap. Use LocalAlloc() to 
allocate local memory. Since this DLL doesn't use the local heap, it 
specifies zero as the minimum heap size. Don't use a STACKSIZE 
statement, since a DLL doesn't have a stack. It uses the calling 
application's stack. 
<p>

Functions that your DLL provides must be exported explicitly. There 
are two ways: the EXPORTS statement and the _exports keyword. 
<p>

The EXPORTS statement lists the functions that other applications 
and libraries can call. If your DLL uses WEP(), you must list it here. 
All exported functions must follow the name mangling scheme as 
specified in the section "Name Mangling in Digital Mars C++" in 
Chapter 4, "Mixing Languages." Following the exported mangled 
name is an optional cardinal entry value. This cardinal is an index 
that allows for faster lookup times than searching by name allows. A 
cardinal is an integer proceeded by an @ and is separated from the 
function name by a space. Optionally, the exported name can be 
wrapped in double quotes, eliminating the need for intermediate 
spaces. The following shows the EXPORTS used both ways: 

<pre>
	EXPORTS ?TimesTwo@@ZCHH@Z @2 
</pre>

or 

<pre>
	EXPORTS "?TimesTwo@@ZCHH@Z" @2 
</pre>

<h3>Alternative export method</h3>

The other way to export functions is to use the _export keyword 
in your C or C++ function declaration statement. This keyword 
causes the compiler to notify the linker that this is an exported 
function and is typically used within Windows programs in place of 
the definition file's EXPORTS statement. With the EXPORTS 
statement, you had to contend with name mangling; the advantage 
of using the _export keyword is that you do not. 
<p>

See "__export and 
__loadds" in Chapter 3, 
"Digital Mars C++ Language 
Implementation" for more 
information. 
<p>

Consider the following example: 

<pre>
	int _export TimesTwo(int x)
	{ 
	    return (x * 2);
	} 
</pre>

<h3>Exporting C++ functions</h3>

If the DLL is written in C++, you must use the mangled name of its 
functions in the EXPORTS statement of the DLL's module definition 
file. To find the mangled name, you can do one of two things: link 
to create a map file for your DLL, and look for your functions in the 
section "Publics by Name"; or run the utility LIBUNRES with the -p 
switch on the .obj files that comprise your DLL. Both methods give 
you a listing of mangled names. For more information, see the 
section "Name Mangling in Digital Mars C++" in Chapter 4, "Mixing 
Languages." For information on LIBUNRES see Chapter 14, "Using 
Digital Mars C++ Utilities." 
<p>

For example, suppose you have a C++ DLL named CPPDLL that has 
one module called cppdll.cpp, and a function called 
TimesTwo(). Compile the source module as follows: 

<pre>
	<a href="sc.html">dmc</a> -c -WD cppdll.cpp 
</pre>

Now run the LIBUNRES utility as follows: 

<pre>
	libunres -p cppdll.obj 
</pre>

This will list all public symbols in cppdll.obj. One of them will 
be the mangled version of TimesTwo(), and might look something 
like this: 

<pre>
	?TimesTwo@@ZCHH@Z 
</pre>

You can usually tell at first glance if this is the symbol you are 
looking for, but if in doubt, run the UNMANGLE utility on the 
mangled name. 
<p>

Finally, edit your module definition file, cppdll. def, so that the 
EXPORTS statement contains the mangled name: 

<pre>
	EXPORTS ?TimesTwo@@ZCHH@Z 
</pre>

When you use the DLL with an application, be sure to use the 
function's mangled name in the IMPORTS statement of the 
application's module definition file. However, when you call the DLL 
function in the application, use the unmangled name and call it just 
as you would any other function. For example, to call TimesTwo() 
from an application, use this: 

<pre>
	a = TimesTwo(b); 
</pre>

<h3>Building the DLL</h3>

When you compile a DLL in the IDDE, be sure to do the following: 

<ul>
	<li> Select Windows DLL in the Projects Options dialog box. 

	<li> Turn off the SS Equals DS option in the Memory Model 
Options dialog box, to specify that the data segment and 
stack segment are different. 


When you compile a DLL at the command line, be sure to do the 
following: 

	<li> Append w to your -m memory model option to specify 
that the data segment and stack segment are different. 

	<li> Use the -W switch to specify that this is a Windows 
executable. 

	<li> Use the -c switch to compile the DLL, but not link it. 
</ul>

Assuming you have already provided source and a definition file. 
mydll. dll is the name of the DLL, two ways to build and link a 
DLL: 

<pre>
	<a href="sc.html">dmc</a> -c -W -msw mydll.c link mydll,mydll.dll,,,mydll.def 
</pre>

and 

<pre>
	<a href="sc.html">dmc</a> -WD mydll.c
</pre>
 
This last method launches the linker for you and assumes the .def 
file has the same name as the source file. 


<h3>Prolog and epilog</h3>

Different types of prologs and epilogs are generated 
depending on the setting of the -W compiler option. 
<p>

For information on 
choosing prolog and epilog 
code, see Chapter 16, 
"Win32 Programming 
Guidelines." 

<h3>Using DLLs in an Application</h3>

Three ways that an executable can link and use the functions in a 
DLL are: 

<ul>
	<li> Explicitly, by using the IMPORTS statement in the .def 
file 

	<li> Implicitly, by linking an import library 

	<li> Explicitly, by dynamically loading the DLL with 
LoadLibrary() and linking to the function with 
GetProcAddress() 
</ul>

This section describes how to use each of these methods. 


<h3>Explicitly with an IMPORTS statement</h3>

To import a function explicitly when you link your application, use 
an IMPORTS statement in the application's module definition file to 
list the names of the DLL functions that it uses. This method is useful 
if you know what DLL functions the application needs when you 
link the application. 
<p>

For example, if you have a DLL written in C called mydll. dll that 
contains AddTwo(), the IMPORTS section might look like this: 

<pre>
	IMPORTS MYDLL._AddTwo
</pre>

Notice the underscore before AddTwo; this results from C-style 
mangling for functions with C linkage. When specifying the DLL 
function to import, you must follow the name mangling conventions 
as specified in "Name Mangling in Digital Mars C++" in Chapter 4, 
"Mixing Languages." 
<p>

If the DLL assigned a cardinal entry value to one of its exported 
functions, you can use that cardinal in the IMPORTS statement to 
help Windows find the function more quickly. If MyDLL assigned 
AddTwo() a cardinal entry value of 1, the IMPORTS statement 
would look like this: 

<pre>
	IMPORTS _AddTwo= MYDLL.1
</pre>
 
<h3>Implicitly with an import library</h3>

If you want to import a function implicitly when you link an 
application, you can create an import library, then link it in with 
your application. An import library contains no code; it is a symbol 
table that the linker uses to define the locations of the DLL functions. 
This method is useful if when you link the application, you know 
what DLL functions it needs. 
<p>

Create an import library with the IMPLIB command line utility. 
It takes two arguments: the name for the import library and the name 
of the DLL's module definition file. For example, this command line 
creates an import library for mydll.dll: 

<pre>
	implib mydll.lib mydll.def
</pre>

IMPLIB finds a .DLL file that has the same name as its first 
argument and creates an import library for it. When you link your 
application, list the import library along with the other libraries that it 
uses. 
<p>

Here is an example of a function that is linked implicitly: 

<pre>
	extern... FAR AddTwo();

		int x, y = 3; 
		x = AddTwo(y); 
</pre>


<h3>Dynamically with LoadLibrary()</h3>

If you want to dynamically import a function when you run your 
application, load its DLL with LoadLibrary(). This method is 
useful if you won't know what functions the application needs until 
it's running. For example, each option in the Windows Control Panel 
is a DLL that the Windows Control Panel loads dynamically each 
time you run it. The Windows Control Panel doesn't know until it's 
running what options are available. 
<p>

For example, to load mydll.dll and call the function AddTwo(), 
use this: 

<pre>
	HINSTANCE hLib;
	FARPROC func; 
	int x, y = 3;
 
	hLib = LoadLibrary("MYDLL.DLL");
	if (hLib &gt;= 32) { 
	    func = GetProcAddress(hLib, "_AddTwo");
	    if (func != (FARPROC) NULL) 
		x = (* func)(y);
	} 
	FreeLibrary(hLib);
</pre>


In the previous example, when you call GetProcAddress(), 
Windows creates a Thunk layer and Thunk calls the function. In this 
case, the DLL function must have Pascal linkage in order to use the 
load library. See Programming Windows by Charles Petzold for more 
information on Thunk layers. 
<p>

LoadLibrary() loads the library and returns a pointer to it. 
GetProcAddress() looks up the function by name in the library 
and returns a pointer to the function. The expression (* func)(y) 
dereferences the function pointer and calls AddTwo() with y as its 
argument. FreeLibrary() lets Windows know that you are no 
longer using the DLL and Windows can unload the library if nothing 
else is using it. 
<p>

To look up the function by its ordinal entry value instead 
of by name, you need to change the call to GetProcAddress(). 
Suppose MyDLL assigned AddTwo() the number 1. Get the 
function's address with this statement: 

<pre>
	func = GetProcAddress(hLib, MAKEINTRESOURCE(1)); 
</pre>


<h3>Using a C++ DLL with a C program</h3>

Avoid using a C++ DLL with a C application. Since C and C++ differ 
in how they pass parameters and handle function names, it is not 
easy to call a C++ function from a C program. 
<p>

However, if you must, you can use a C++ DLL with a C program. 
The easiest way is to recompile the C application as a C++ source 
file, and to use the extern "C" construct to give the application's 
functions C linkage and use the extern "C++" construct to give the 
DLL's functions C++ linkage. For example, this code gives three 
application functions C linkage and one DLL function C++ linkage: 

<pre>
	extern "C" {
	    void old_app_function1(); 
	    void old_app_function2();
	    extern "C++" { 
		int cplusplus_DLL_func();
	    }; 
	    void old_ app_ function3();
	}; 
</pre>

<hr>
<a name="handle">
<h1>Using Handle Pointers</h1>
</a>

Handle pointers are a special data type that support virtual memory
management in 16-bit compilations. They let a data structure use as
much as 16KB of memory and your program use as much as 16MB. Handle
pointers are an alternative to DOS extenders that you can 
use in code for all members of the Intel 8088 family of processors. 
<p>
Handle pointers are a Digital Mars C++ extension 
to the normal far pointer type. __handle pointers provide access to 
memory that can be accessed only through indirection (a handle). 
Currently, handle pointers support the use of expanded (EMS or 
LIMS) memory. A handle pointer differs from a standard far pointer 
in that it is assumed to contain handle information in its segment 
address as well as a normal pointer offset. When memory is accessed 
through a handle pointer, the handle is automatically dereferenced 
to ensure that the information is obtained from the correct place. In 
the case of expanded memory, any page mapping that may be 
required is carried out automatically. 
<p>

For information about other pointer types, see Chapter 4, "Mixing 
Languages" and Chapter 2, "Compiling Code." 


<h3>What's in This Chapter</h3>

<ul>
	<li> How handle pointers work. 
	<li> The handle format. 
	<li> Declaring handle pointers. 
	<li> Creating handles to dynamically allocated memory. 
	<li> Dereferencing handles. 
	<li> Tips on porting and debugging code that contains 
handles. 
</ul>

<h3>About Handle Pointers</h3>

Handle pointers are instances of a type called a handle. You use a 
handle instead of an ordinary pointer to refer to a data structure. 
Handle pointers point to data in some external memory area, such as 
expanded memory, extended memory, or disk. 
<p>

When your program needs the data, the handle is dereferenced (that 
is, converted into an ordinary pointer), and the data it points to is 
read into conventional memory. 
<p>

Features of the handle pointer include:

<ul>
	<li> It is built into the compilers, so you 
don't need to call functions to access handles, lock or 
unlock pages, or initialize the virtual memory system. 

	<li> It uses expanded memory if available and is compatible 
with LIMS EMS versions 3.2 and 4.0. 

	<li> It lets you easily port code to operating systems with 
virtual memory (such as UNIX and OS/2). The program 
runs as efficiently as if it used conventional memory. 

	<li> It works with both C and C++ and is a compatible 
extension to ANSI C. 

	<li> It uses the same code in the DOSX and Phar Lap memory 
models. The compiler treats handle pointers as far 
pointers in these models. 
</ul>

<b>Note:</b> 
	The keyword __handle is ignored in compilations 
	using the NT (-mn) and OS/2 2.0 (-mf) memory 
	models. 


<h3>How handle pointers work</h3>

Handle pointers work by storing data outside the DOS memory area 
and reading it into conventional memory only when it is needed. 
When you declare a handle, the compiler stores the object it refers to 
in a page. In order of preference pages are stored in expanded 
memory, extended memory, or disk. There is a maximum of four 
pages, and each can hold 16KB. A single page can hold several 
different variables. 
<p>

When you access a handle's data, your program reads the page that 
contains the data into conventional memory. For example, suppose 
a, b, c, i, j, and k are handles, and n1 and n2 are ordinary 
pointers. If you refer to i, the program swaps its page into 
conventional memory (see Figure 21-1) and converts i to a far 
pointer. If the page is stored on disk, your program automatically 
reads it in. The page that contains i is now called a physical page 
since it is in conventional memory. The other page is called a logical 
page since it is not currently loaded into conventional memory. With 
our compilers, the conversion is performed automatically; 
you don't need to call a function. 

<pre>
	Figure 21-1 Accessing the handle i 

	Conventionl Memory	Handle Space (on disk or expanded memory)
	Physical page 2		Logical page 1
	*i: 89.32 		*a: 100 
	*j: 78.29 		*b: 3.5E12 
	*k: 102.14 		*c: "Hello\n" 

	Data Segment
	n1: "John" 
	n2: "Maria" 
</pre>


When you refer to a handle in another page, your program swaps 
that page into memory, swapping the other page out if necessary. In 
the above example, when your code references c, the program 
swaps i's page to disk and swaps c's page into memory. The result 
is illustrated in Figure 21-2. 


<pre>
	Figure 21-2 Accessing the handle c 

	Conventionl Memory	Handle Space (on disk or expanded memory)
	Physical page 1		Logical page 2
	*a: 100 		*i: 89.32
	*b: 3.5E12 		*j: 78.29
	*c: "Hello\n" 		*k: 102.14

	Data Segment
	n1: "John" 
	n2: "Maria" 
</pre>


<h3>The handle format</h3>

The handle type is a 32-bit type in 16-bit compilations. The high 16 
bits point to the page and the low 16 bits point to an offset in the 
page. To convert a handle to a far pointer, the offset is added to the 
address of the physical page. Handles are unique; no two handles 
can refer to the same location in handle space. 
<p>

To distinguish between a handle that holds an actual handle and one 
that holds a converted far pointer, the compiler reserves 
the values 0xFE00 to 0xFFFF as page addresses. Since those are 
the segment addresses for the ROM BIOS, it is unlikely any program 
would store data there. The compiler treats a far pointer with a 
segment address less than 0xFE00 as an ordinary far pointer. It 
treats a far pointer whose segment address is greater than 0xFE00 
as a handle pointing to logical page (segment -0xFE00). However, 
a variable explicitly declared as a far pointer that has a segment 
address greater than 0xFE00 is still treated as a far pointer and can 
access the ROM BIOS area. 


<h3>Using Handles</h3>

Declaring a handle pointer is like declaring a far pointer. To declare 
a handle pointer, use the __handle keyword. For example, this 
statement declares h to be a handle to an integer: 

<pre>
	int __handle *h; 
</pre>

Use a handle as any other pointer. For example: 

<pre>
	*h = 3;
	printf(" h=% d\ n", *h); 
</pre>

Your program doesn't need to perform any special initialization to 
use handles. The compiler adds initialization code (in 
c.asm) automatically. You must be sure your program frees 
memory when it exits; otherwise, it will be unavailable to other 
programs until the machine is re-booted. To free up the memory 
your program uses, be sure to call exit() at all the places where 
your program could end. Handles use extended memory, which 
DOS does not automatically free up. You might want to use special 
C++ error handling to make sure that exit() is called even when 
your program terminates abnormally (due to a system error or 
pressing Control-C, for example). 
<p>

In comparisons and arithmetic operations, handles are treated like 
far pointers. In all arithmetic and the comparisons &lt;, &lt;=, &gt;=, and &gt;, 
the compiler uses only the 16-bit offset into the page. 
When testing for equality or inequality (== or !=), the compilers use 
the full 32-bit value. 


<h3>Dynamically allocating memory</h3>

If you want to create a handle that refers to dynamically allocated 
memory, use the functions in handle.h, such as 
handle_malloc(), handle_realloc(), and handle_free(). 
When you try to allocate memory, these functions check a table 
stored in physical memory to see if there is space available in an 
existing page. If there is not enough expanded memory available, or 
if you try to allocate a block larger than 16KB, the handle functions 
attempt to allocate the memory from conventional memory. 


<h3>Dereferencing handles</h3>

Handles are converted to far pointers whenever you dereference a 
handle or cast a handle to a far pointer. The compiler 
performs the conversion with a library routine, which swaps the 
logical page into memory and returns a far pointer into the page. For 
example, the following operations all convert a handle to a far 
pointer: 

<pre>
	int __handle *h;
	struct A __handle *h2; 
	int far *f;
	int i; 
	extern void func(int far *pi); 

	/*
	 * These operations convert 
	 * handles to far pointers.
	 */ 
	f = h;
	*h = i; 
	h[3] = *f;
	i = *(h + 6); 
	h2-&gt;b = i;
	func(h); 
	h = (int far *) h; 

	/*
	 * This operation performs no conversion. 
	 */
	h = f; 
</pre>

The compiler avoids converting a handle when it can use a previous 
conversion. In the following code, for example, h needs to be 
converted only once: 

<pre>
	struct { int a, b; } __handle *h;
	h-&gt;a = 1; 
	h-&gt;b = 2; 
</pre>

The compiler converts the code to: 

<pre>
	struct { int a, b; } __handle *h, far *p;
	p = h; 
	p-&gt;a = 1;
	p-&gt;b = 2; 
</pre>

The compiler can't use the result of a previous conversion if: 

<ul>
	<li> The handle's value might have changed. 

	<li> Your code dereferenced another handle in the interim. 
Referencing a handle may cause another handle's page to 
be swapped out. 

	<li> You called a function. Since a function might dereference 
another handle, the converted handle's page might be 
swapped out. 
</ul>

<h3>Optimizing handle code</h3>

If you dereference a handle and then call a function that you know 
does not dereference handles, you can make sure the handle isn't 
converted unnecessarily by optimizing your code yourself. This 
code, for example, converts h twice: 

<pre>
	int __handle *h;
	*h = 1;		/* Convert h once  */ 
	func();		/* A function call */
	*h = 2;		/* Convert h twice */ 
</pre>


This optimized code dereferences h only once: 

<pre>
	int __handle *h, far *f;
	f = h;		/* Convert h once */ 
	*f = 1;
	func();		/* A function call */ 
	*f = 2; 
</pre>


Make sure you don't use more than four dereferenced handles at 
once. The handle implementation use a maximum of four pages. For 
more information, see the section "Debugging programs that use 
handles" later in this chapter.

 
<h3>Tips for Using Handle Pointers Efficiently</h3>

Although using handles gives you access to a large amount of 
memory, it can also make your program slower and larger. Your 
program may frequently swap pages in and out of memory and it 
will contain additional code to dereference handles. Here are some 
suggestions for making your program more efficient: 

<ul>
	<li> Use handles for data structures that your program 
accesses infrequently. Your program will read and write 
memory less often and will contain less code for 
dereferencing. 

	<li> Choose handle pointers for data structures that emphasize 
fast access over those that emphasize compactness. 

	<li> Keep related data structures on the same page by 
allocating or declaring them together. 

	<li> Use expanded memory conventionally (for example, via 
the EMM library routines) in the same program where you 
use handles. But if you don't keep the two uses 
independent, the results could be unpredictable. 

	<li> Perform a search over a large database by trying to put 
the access structures in conventional memory and the 
data in handle space. Look-up is fast and nothing is read 
from disk until the search data is found. 
</ul>

<h3>Porting code with handles</h3>

To port code that uses handles to a compiler that doesn't implement 
handles, define __handle to be nothing, like this: 

<pre>
	#define __handle 
</pre>

All handles become regular pointers. 
<p>

If you use the dynamic allocation functions in handle. h, define 
NO_HANDLE to be 1 before you #include handle.h, like this: 

<pre>
	#define NO_HANDLE 1
	#include <handle.h> 
</pre>


The functions in handle.h will call their equivalents in the 
standard library, such as malloc(), realloc(), and free().


<h3>Debugging programs that use handles</h3>

Here is a list of points to watch out for: 

<ul>
	<li> Beware of having a stray pointer into a page that has 
been swapped out of memory. This problem rarely 
exhibits symptoms. 

	<li> Don't use more than four dereferenced handles at a time. 
This problem shows up only if they fall on different 
logical pages. 

	<li> Beware of function calls that could dereference handles. 

	<li> In converting code from using malloc() to 
handle_malloc, be sure to convert 
(char *) malloc(x) to 
(char __handle *) handle_malloc(x). Using 
(char *) handle_malloc(x) dereferences the 
handle and stores a far pointer in h. 
</ul>

Here are some techniques to deal with the problems outlined above: 

<ul>
	<li> If your program uses the dynamic allocation functions in 
handle. h, define NO_HANDLE to be 1 so the functions 
don't use handles. If you no longer have problems after 
redefining NO_HANDLE, you can be sure that handles 
caused your bugs. 

	<li> Encapsulate data structures that use handles in C++ 
classes. This confines the code that dereferences handles 
to a few places and isolates handle problems to a class 
definition. 

	<li> Look carefully for simultaneous accesses to logical pages. 
Make sure you don't dereference more than four handles 
at a time. 

	<li> Program defensively. Assume that all function calls 
invalidate previously dereferenced handles. 
</ul>


<br><br><br><br>

</td></table>







<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

