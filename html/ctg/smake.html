
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - smake
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:25:45 2006
</div>
</div>

<!-- Generated by Ddoc from smake.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ctg">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>
</center>

    <a href="ctg.html"><b>Compiler & Tools Guide</b></a><br>

<hr><b>Compiling</b><br>

    &#149; <a href="ctgCompilingCode.html">Compiling Code</a><br>
    &#149; <a href="C-Language-Implementation.html">C Implementation</a><br>
    &#149; <a href="CPP-Language-Implementation.html">C++ Implementation</a><br>
    &#149; <a href="ctgLanguageImplementation.html">Language Extensions</a><br>
    &#149; <a href="ctgMixingLanguages.html">Mixing Languages</a><br>
    &#149; <a href="ctgAsm.html">Assembly Language</a><br>
    &#149; <a href="ctgInlineAsm.html">Inline Assembler</a><br>
    &#149; <a href="ctgOptimizer.html">Optimizing Code</a><br>
    &#149; <a href="ctgNumerics.html">Numerics Programming</a><br>
    &#149; <a href="regular.html">Regular Expressions</a><br>
    &#149; <a href="acrtused.html">Acrtused</a><br>
    &#149; <a href="pragmas.html">Pragmas</a><br>
    &#149; <a href="precompiled.html">Precompiled Headers</a><br>
    &#149; <a href="predefined.html">Predefined Macros</a><br>
    &#149; <a href="warnings.html">Warning Messages</a><br>
    &#149; <a href="ctgCompilerErrors.html">Error Messages</a><br>
    &#149; <a href="warnings.html#runtime">Runtime Messages</a><br>
    <br>

<hr><b>Linking</b><br>

    &#149; <a href="optlink.html">Optlink</a><br>
    &#149; <a href="ctgLinkSwitches.html">Switches</a><br>
    &#149; <a href="ctgDefFiles.html">Module Definition Files</a><br>
    &#149; <a href="ctgLinkOps.html">Operation and Design</a><br>
    &#149; <a href="OptlinkErrorMessages.html">Error Messages</a><br>
    <br>

<hr><b>Win32 Programming</b><br>

    &#149; <a href="win32programming.html#win32">Win32 Programming</a><br>
    <br>

<hr><b>DOS and Win16<br>Programming</b><br>

    &#149; <a href="ctgMemoryModel.html">Memory Models</a><br>
    &#149; <a href="pointers16.html">16 Bit Pointer Types<br> and Type Modifiers</a><br>
    &#149; <a href="win32programming.html#handle">Handle Pointers</a><br>
    &#149; <a href="win32programming.html#dos">DOS</a><br>
    &#149; <a href="dos32.html">DOS 32 (DOSX)</a><br>
    &#149; <a href="win32programming.html#win16">Win16</a><br>
    &#149; <a href="win32programming.html#win16dll">Win16 DLLs</a><br>
    &#149; <a href="windowspe.html">Win16 Prolog/Epilog</a><br>
    <br>

<hr><b>C/C++ Extensions</b><br>

    &#149; <a href="contract.html">Contract Programming</a><br>
    &#149; <a href="debugstatement.html">__debug statement</a><br>
    &#149; <a href="debugstatement.html#debugdeclaration">__debug declaration</a><br>
    &#149; <a href="trace.html">Dynamic Profiling</a><br>
    &#149; <a href="html.html">Embedding C in HTML</a><br>
    <br>

<hr><b>Tools</b><br>

    &#149; <a href="bcc.html" title="Convert Borland compiler commands">BCC</a><br>
    &#149; <a href="chmod.html" title="Examine and change file attributes">CHMOD</a><br>
    &#149; <a href="cl.html" title="Convert Microsoft compiler commands">CL</a><br>
    &#149; <a href="coff2omf.html" title="Convert COFF .obj and .lib to OMF">COFF2OMF</a><br>
    &#149; <a href="coffimplib.html" title="Convert COFF import library OMF">COFFIMPLIB</a><br>
    &#149; <a href="sc.html" title="Compiler command">DMC</a><br>
    &#149; <a href="diff.html" title="Compare files">DIFF</a><br>
    &#149; <a href="diffdir.html" title="Compare directories">DIFFDIR</a><br>
    &#149; <a href="dump.html" title="Dump files in hex">DUMP</a><br>
    &#149; <a href="dumpobj.html" title="Dump object files in hex">DUMPOBJ</a><br>
    &#149; <a href="dumpexe.html" title="Dump exe files">DUMPEXE</a><br>
    &#149; <a href="exe2bin.html" title="Create .com files">EXE2BIN</a><br>
    &#149; <a href="flpyimg.html" title="Read/Write Floppy Image">FLPYIMG</a><br>
    &#149; <a href="grep.html" title="Search files for string">GREP</a><br>
    &#149; <a href="ctgHelp.html" title="Creating Help Tools">HC</a><br>
    &#149; <a href="implib.html" title="Build import libraries">IMPLIB</a><br>
    &#149; <a href="lib.html" title="Object file librarian">LIB</a><br>
    &#149; <a href="libunres.html" title="Analyze library and object files">LIBUNRES</a><br>
    &#149; <a href="make.html" title="Simple make utility">MAKE</a><br>
    &#149; <a href="makedep.html" title="Update makefile dependencies">MAKEDEP</a><br>
    &#149; <a href="me.html" title="MicroEmacs Text Editor">ME</a><br>
    &#149; <a href="obj2asm.html" title="Object file disassembler">OBJ2ASM</a><br>
    &#149; <a href="patchobj.html" title="Patch object files">PATCHOBJ</a><br>
    &#149; <a href="ctgRC.html" title="Microsoft Resource compiler">RC</a><br>
    &#149; <a href="rcc.html" title="Digital Mars Resource compiler">RCC</a><br>
    &#149; <a href="sc.html" title="Compiler command">SC</a><br>
    &#149; <a href="shell.html" title="Shell scripts">SHELL</a><br>
    &#149; <a href="smake.html" title="Manage complex projects">SMAKE</a><br>
    &#149; <a href="touch.html" title="Set file timestamps">TOUCH</a><br>
    &#149; <a href="unmangle.html" title="Format C++ mangled names">UNMANGLE</a><br>
    &#149; <a href="whereis.html" title="Search for files">WHEREIS</a><br>
    <br>

<hr><b>Porting to DMC++</b><br>

    &#149; <a href="switchtodigitalmars.html">Switching to DMC++</a><br>
    &#149; <a href="switchtodigitalmars.html#microsoft">from Microsoft</a><br>
    &#149; <a href="switchtodigitalmars.html#borland">from Borland</a><br>
    &#149; <a href="ctgPorting.html">Porting Guide</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">

<h1>Managing Code with <b>smake</b></h1>

<a href="http://www.digitalmars.com/" target="_top">Digital Mars</a>
<b>smake</b> is a command processor for maintaining and updating
project files. <b>smake</b> is compatible with Microsoft NMAKE. This chapter
describes how <b>smake</b> builds a new version of a program by compiling
only the files that have changed. 

For information on Digital Mars C++'s build system and source control 
system, see the
<a href="../ugr/ugr.html" target="_top"><i>User's Guide and Reference</i></a>. 


<h3>This chapter discusses:</h3>

<ul>
	<li> Overview of <b>smake</b> and how it works. 
	<li> Components of makefiles. 
	<li> Command line syntax and command options. 
	<li> Rules for how <b>smake</b> chooses dependency files. 
	<li> Using operating system commands in makefiles. 
	<li> Using macros in makefiles. 
	<li> <a href="#inference">Inference rules</a>. 
	<li> Preprocessing directives. 
	<li> Using the <a href="makedep.html">MAKEDEP</a> utility
	<li> Using the <a href="touch.html">TOUCH</a> utility
	<li> Using <a href="#tools"><tt>tools.ini</tt></a>
	<li> Using <a href="#response">response files</a>
	<li> <a href="#errorMessages">Error messages</a>
</ul>

<h3>What is <b>smake</b>?</h3>

<b>smake</b> automates program maintenance, instead of typing in 
commands to compile and <a href="optlink.html">link</a> your program. A makefile 
describes how all the files in a project depend on each 
other and how to update a file (such as an object file) when the files 
it depends on (such as source files) change. 
<p>

<b>smake</b> is particularly useful for programs that have many source 
files, since it recompiles only those source files that have changed. It 
does this by looking at the date and time stamp of each relevant file 
before performing any tasks. 
<p>

	<b>Note</b>: When using <b>smake</b>, always be sure your PC 
	displays the correct date and time. Be especially 
	careful when logging on to networks that change 
	the time on the local machine, in case the network 
	time is incorrect. 
<p>

<b>smake</b> differs from a batch file in that it performs only the 
commands required to rebuild your program, while a batch file 
executes all tasks, whether or not they are necessary. 


<h3>Writing Makefiles</h3>

A <i>makefile</i> is a text file that tells <b>smake</b> how to build your program. 
By default, <b>smake</b> expects the makefile to be named <tt>makefile</tt>, 
with no extension. Any extension can be used, though <tt>.mak</tt>
is commonly used.
<p>

The makefile contains one or more dependence lines, each followed 
by one or more command lines. Each dependence line specifies a 
target (upon which the associated command lines act), followed by a 
colon and a (possibly empty) list of dependent files (files needed to 
create the target). For example, this dependence line: 
<pre>
	app.exe : app.obj app.re app.def 
</pre>
tells <b>smake</b> to perform the commands that follow if any of 
app.obj, app.res, or app.def have a more recent date and time 
than app.exe.
<p>
Command lines tell <b>smake</b> how to create the target. Command lines 
must begin with a tab or space character. For example: 
<pre>
	app.exe : app.obj app.res app.def
		<a href="optlink.html">link</a> app,,NULL,lib,app 
		<a href="rcc.html">rcc</a> app.res app.exe 
</pre>
tells <b>smake</b> to run the linker and the resource compiler. 
<p>

A makefile can also contain comments, macros, preprocessing 
directives, operating system commands, and <a href="#inverence">inference rules</a>. 


<h3>Example of a simple makefile</h3>

This makefile creates a program that has only one source file. 
<pre>
	hello.exe: hello.obj     # Dependence line 1
		<a href="optlink.html">link</a> hello.obj   # Command line 1 

	hello.obj: hello.cpp     # Dependence line 2
		<a href="sc.html">dmc</a> -c hello.cpp  # Command line 2 
</pre>

<b>Note:</b> 
	A makefile 
	comment begins with the # character and continues 
	until the end of the line. 
<p>
The first dependence line indicates that hello.exe depends on 
hello.obj. The first command line specifies how to make 
hello.exe by executing <a href="optlink.html">link</a> hello.obj. 
<p>
The second dependence line indicates that hello.obj depends on 
hello.cpp. The second command line specifies how to make 
hello.obj by executing <a href="sc.html">dmc</a> -c hello.cpp. 
<p>
Suppose you just finished editing hello.cpp and typed smake to 
create a new version of your program. <b>smake</b> reads the dependence 
lines from the makefile. It determines that hello.cpp is newer than 
hello.obj, so it re-creates hello.obj by executing 
<a href="sc.html">dmc</a> -c hello.cpp. Then it determines that hello.obj is now newer 
than hello.exe. It re-creates hello.exe by executing 
<a href="optlink.html">link</a> hello.obj. 


<h3>Makefile syntax</h3>

The syntax for a basic makefile is: 
<pre>
	target-file : dependent-file1 dependent-file2 ...
		command 1 
		command 2
		... 
</pre>

<b>smake</b> assumes that if a target file is older than any of the files 
needed to create it, then it must re-create the target file by executing 
the command lines that follow the dependence line. 
<p>

Target files are typically executable files or libraries, but they can 
also be labels for sets of commands (like all:); these are often 
called pseudo-targets. Similarly, a dependent file is usually a C or 
C++ source file, but can be a pseudo-target. For more information 
see "Specifying targets" below. 
<p>

<b>Note:</b> 
	<b>smake</b> reads all the dependence lines in a makefile 
	before executing any of the associated commands. 
	It then compares the date and time of the 
	dependents to the target and executes the 
	commands for any target that is out of date. It also 
	checks to see if that target has other dependents 
	that might be more recent. 


<h3>Dependence line syntax</h3>

The name of the target file must be the first thing on the dependence 
line, with no white space preceding it. The target and subsequent 
dependents are separated by a single colon, which can optionally be 
preceded by tabs or spaces. A dependence line can span multiple 
lines; all lines to be continued must end with a backslash (\) 
character. 


<h3>Specifying targets</h3>

The dependence line can contain one or more target names 
separated by one or more spaces. Each target can be a fully qualified 
path and file name, or just a label. However, if the last target has a 
single character name (with no extension), at least one space is 
required before the colon to distinguish it from a drive letter. 
<p>
To build a complicated target that requires more than one set of 
dependence lines and commands, use double colons (::) to separate 
it from the dependents in each case. For example: 

<pre>
	app.exe :: app.obj app.def
		<a href="optlink.html">link</a> app,,NULL,lib,app 

	app.exe :: app.res
		rc app.res app.exe 
</pre>

If the same target, followed by a single colon, appears on two 
consecutive lines, and commands follow only one of those instances, 
<b>smake</b> interprets this as a single, cumulatively combined 
dependence line. For example: 
<pre>
	target.exe : file_1.obj
	target.exe : file_2.obj 
	# is interpreted as
	# target.exe : file_1.obj file_2.obj 
</pre>

If the same target, followed by a single colon, appears on two 
different lines in various places in the makefile, and commands 
follow only one of those instances, <b>smake</b> interprets this as if the 
dependence lines were adjacent. This means that <b>smake</b> does not 
apply an <a href="#inference">inference rule</a> to the instance 
without commands. Use double colons (::) after the target to avoid 
this side effect. 
<p>

If a target is not specified on the <b>smake</b> command line, <b>smake</b> uses 
the first target it encounters in the makefile. <b>smake</b> always interprets 
a label used as a target name as being out of date; this is useful to 
avoid having to pass several targets on the command line. For 
example: 
<pre>
	all: app.exe app2.exe app3.exe 
</pre>

<h3>Specifying dependent files</h3>

The names of zero or more dependents can follow the target on the 
dependence line. As with targets, a dependent can be a fully 
qualified path name or a label, although it is usually a file that is 
used to build the target. Multiple dependents must be separated by 
one or more spaces or tabs. 
<p>
A search path can precede a dependent file; enclose the path in 
curly braces ({}) and separate the directories with semicolons (;). 
<b>smake</b> will search the specified directories in order for the 
dependent. (The search path applies only to the dependent it 
proceeds.) For example: 
<pre>
	app.exe : app.obj app.res \
		{c:\project; c:\default} app.def 
</pre>

<h3>Special characters in makefiles</h3>

<b>smake</b> accepts the special characters listed below in makefiles. 
These characters have special meaning depending on their context. 
For any of these characters to be interpreted literally in a makefile, 
you must precede it with a caret (^) character. If ^ appears in front 
of a character that does not have special meaning to <b>smake</b>, it is 
interpreted literally. 
<p>

<b>Note:</b> 
	A ^ at the end of a line includes the 
	carriage return/line feed sequence in a macro or 
	string. 

<h4>Table 13-1 Special characters in makefiles</h4>

<ul><dl>
<dt><b>:</b>	<dd>Separates target from rest of dependence line. 
<dt><b>#</b>	<dd>All characters following a # on a line are
		interpreted as a comment and ignored. 
<dt><b>()</b>	<dd>Encloses the value string of a macro to be expanded. 
<dt><b>$</b>	<dd>Precedes an instance of a macro to be expanded. 
<dt><b>^</b>	<dd>The next character is interpreted as a literal character. 
<dt><b>\</b>	<dd>Continues a line on the next line. 
<dt><b>{}</b>	<dd>On a dependence line, encloses a path name 
		associated with a dependant. 
<dt><b>!</b>	<dd>As the first character on a line, recognized as the start 
		of a preprocessing directive. On a dependence line, 
		acts as a command modifier. 
<dt><b>@</b>	<dd>On a dependence line, acts as a command modifier. 
<dt><b>-</b>	<dd>On a dependence line, acts as a command modifier. 
</dl></ul>

<h3>Using % and $ in commands</h3>
 
<b>smake</b> interprets a percent sign (%) as the beginning of a file name 
specifier. To place a percent sign in a command, use two percent 
signs (%%). Similarly, to use a dollar ($) sign in a command, specify 
two consecutive dollar signs ($$). You can also specify multiple 
literal % and $ characters this way. For example, <b>smake</b> interprets 
$$$$ in a command as two consecutive dollar signs. 
<p>

<b>Note:</b> 
	<b>smake</b> interprets the $ and @ symbols as special 
	characters, do not use 
	these symbols in file or directory names that will be 
	processed by <b>smake</b>. 

<h3>Comments in makefiles</h3>

<b>smake</b> interprets all characters following a # on a line as comment 
characters, and ignores them. Comments need not start at the 
beginning of a line; they can appear almost anywhere, including at 
the ends of lines defining macros, dependence lines, and
<a href="#inference">inference rules</a>.
Comment are also permitted in command blocks, but cannot 
be on the same line as the command itself, even if the command 
spans multiple lines. 


<h3>Running <b>smake</b></h3>

When you run <b>smake</b> (from an operating system command 
prompt), it prints your commands as it executes them. If you run 
<b>smake</b> and it doesn't need to update your files, it lets you know like 
this: 
<pre>
	Target is up to date 
</pre>
To redirect the output of <b>smake</b> to a file, use the greater-than sign:
<pre>
	<b>smake</b> &gt; log
</pre>

<b>Note:</b> 
	When <b>smake</b> calls another program, it redirects 
	that program's output to the log file only if that 
	program writes to stdout. The tools that come 
	with Digital Mars C++, such as <a href="sc.html">dmc</a>
	and <a href="optlink.html">optlink</a>, write 
	to stdout. 


<h3><b>smake</b> command line syntax</h3>

The syntax for the <b>smake</b> command is: 
<pre>
	<b>smake</b> <i>{options} {macros} {targets}</i>
</pre>
where:

<dl><dl>
<dt><i>options</i>
	<dd>Zero or more command line options used to 
	control the current <b>smake</b> session. If no options 
	are specified, <b>smake</b> uses the options specified in 
	the tools. ini file. If a required option is not 
	specified, <b>smake</b> uses the default value for that 
	option specified in <tt>tools.ini</tt>. 

<dt><i>macros</i>
	<dd>One or more macros of the form <i>macro=text</i>.
	A macro defined on the command line overrides any 
	corresponding macro definition in the makefile. 

<dt><i>targets</i>
	<dd>The targets to build. 
</dl></dl>


<h3>Command line options</h3>

<b>smake</b> options are preceded by either a dash (-) or slash (/). Case is 
irrelevant when specifying options. If a required option is not 
specified, <b>smake</b> uses the default value for that option specified in 
<code>tools.ini</code>. The following options are valid: 


<dl><dl>
<dt><b>/A</b>
	<dd>Rebuilds all targets, including targets that are not out of 
	date with respect to their dependents. Unrelated targets 
	will not be rebuilt. 
	See also /B, below. 

<dt><b>/B</b>
	<dd>Rebuilds a target if its date and time are identical to the 
	date and time of the dependent. Because most 
	operating systems assign file date and time stamps to a 
	resolution of two seconds, commands that execute very 
	quickly might not result in a different date and time 
	between a target and its dependent. Therefore, <b>smake</b> 
	might conclude that a target is current when it is not. 
	Though this option can result in unnecessary build 
	steps, it is recommended for use on very fast systems. 
	See also /A, above. 

<dt><b>/C</b>
	<dd>Suppresses the default <b>smake</b> output, which includes 
	any nonfatal error messages, warning messages, date 
	and time information, as well as the <b>smake</b> copyright 
	message. If both the /C and the /K options are 
	specified, /C suppresses the warnings issued by the /K 
	option. 
	See also /K. 

<dt><b>/D</b>
	<dd>Displays extra information during the <b>smake</b> session. 
	<b>smake</b> displays the date and time of each target and its 
	dependent when they are evaluated during the build, 
	and outputs a message when a target does not yet exist. 
	The names of the dependents for a target precede the 
	target itself, and are indented. The /D, /N, and /P 
	options are useful for debugging makefiles. 
	See also /N, /P. 

<dt><b>/E</b>
	<dd>Causes the settings for environment variables to 
	override the macro definitions within the makefile. 

<dt><b>/F</b> <i>filename</i>
	<dd>Specifies <i>filename</i> as the name of the makefile to be 
	used. White space consisting of zero or more spaces or 
	tabs can precede the <i>filename</i>. Using a dash (-) instead 
	of a <i>filename</i> causes <b>smake</b> to get the makefile input 
	from the standard input device. Keyboard input is then 
	ended by typing either F6 or Ctrl-Z. <b>smake</b> can accept 
	more than one makefile; use a separate /F specifier for 
	each makefile. If /F is omitted, <b>smake</b> obtains its input 
	from the file MAKEFILE. 

<dt><b>/HELP</b> 
<dt><b>/?</b>
	<dd>Displays a brief summary of the <b>smake</b> command line 
	syntax. 

<dt><b>/I</b>
	<dd>Ignores exit codes from all commands processed by 
	<b>smake</b>. To ignore errors for unrelated parts of the 
	build, use the /K option; /I overrides /K if both are 
	specified. 
	See also .IGNORE, /K. 

<dt><b>/K</b>
	<dd>Continues building unrelated parts of the dependencies, 
	even if a command terminates with an error. <b>smake</b> 
	normally stops processing if any command returns a 
	non-zero exit code. /K allows <b>smake</b> to continue 
	processing any unrelated targets (those which do not 
	depend on the results of the current command). If an 
	error is encountered, <b>smake</b> returns an error code of 1, 
	unlike the /I option which ignores all exit codes. /I 
	overrides /K if both options are specified. Also, /C 
	suppresses the warnings issued by /K. 
	See also /C, /I. 

<dt><b>/N</b>
	<dd>Displays but does not execute the commands that 
	<b>smake</b> would have executed. However, any 
	preprocessing commands (. directive, !directive) are 
	executed. Use /N to determine which targets are out of 
	date. The /N, /D, and /P options are useful in 
	debugging makefiles. Note that /N does not 
	automatically recurse to subsequent calls to <b>smake</b>. 
	See also /D, /P. 

<dt><b>/NOLOGO</b>
	<dd>Suppresses the <b>smake</b> copyright message. 

<dt><b>/P</b>
	<dd>Displays <b>smake</b> information to the standard output 
	device before processing begins. This includes all 
	macro definitions, <a href="#inference">inference rules</a>,
	and target 
	descriptions, as well as the .SUFFIXES list. Specifying /P 
	without a makefile or command line target causes 
	<b>smake</b> to display its information without issuing an 
	error. The /P, /D and /N options are useful for 
	debugging makefiles. 
	See also /D, /N. 

<dt><b>/Q</b>
	<dd>Checks the dates and times of targets that <b>smake</b> 
	would haveupdated, but does not update any files; only 
	the preprocessing commands (.directive, !directive) are 
	executed. A non-zero exit code is returned if any target 
	is not up to date. Note that /Q does not automatically 
	recurse to subsequent calls to <b>smake</b>. 

<dt><b>/R</b>
	<dd>Clears the .SUFFIXES list and ignores the default 
	<code>tools.ini</code> settings. 

<dt><b>/S</b>
	<dd>Suppresses the display of all commands executed by 
	<b>smake</b>. 
	See also .SILENT, @. 

<dt><b>/T</b>
	<dd>Changes the dates and times of the command line 
	targets to the current date and time and executes the 
	preprocessing commands, but does not process the 
	normal target commands. If a command line target is 
	not passed, <b>smake</b> changes the date and time of the 
	first target in the makefile. The contents of the target 
	files are not changed, only the date and time stamp is 
	updated. 

<dt><b>/X</b> <i>filename</i>
	<dd>Sends all <b>smake</b> error output to <i>filename</i>. This can be 
	either a file or a device. White space consisting of zero 
	or more spaces or tabs can precede <i>filename</i>. Using a 
	dash (-) instead of a <i>filename</i> causes <b>smake</b> to send 
	the error messages to the standard output device. 
	<b>smake</b> normally sends any error messages to the 
	standard error device. This option only affects the 
	<b>smake</b> output, and not the output of any command 
	executed by <b>smake</b>. 

<dt><b>@</b><i>command</i>
	<dd>A command file can be used to pass command line 
	options to <b>smake</b>. <b>smake</b> first attempts to interpret 
	command as an environment variable. If it does not 
	exist, <b>smake</b> attempts to open a linker response file 
	with that name. 
	<br>
	The command file name must be preceded by the @ 
	character, with no white space separating the @ 
	character from the file name. Use of a command file 
	also permits a command sequence longer than the 128 
	character limit imposed by DOS. The command file 
	options can be placed on a single line separated by 
	white space, or on multiple lines. If multiple lines are 
	used, carriage return/ line feed sequences are replaced 
	by spaces when the lines are concatenated into a full 
	command. Macro definitions can be continued on 
	multiple lines by putting a backspace (\) character at 
	the end of the lines that are to be continued. 
</dl></dl>


<b>Note:</b> 
	Any command line option except 
	/F, /HELP, /?, or /NOLOGO can be changed from within a makefile 
	with the !CMDSWITCHES directive. 


<h3>Specifying what targets to build</h3>

Usually <b>smake</b> creates the first target that it finds in your makefile. 
However, if you specify a target on the command line, <b>smake</b> 
creates that target instead. 
For example, this makefile creates several utility programs: 
<pre>
	all: count.exe write.exe read.exe 

	count.exe: count.c
		<a href="sc.html">dmc</a> count.c 

	write.exe: write.c
		<a href="sc.html">dmc</a> write.c 

	read.exe: read.c
		<a href="sc.html">dmc</a> read.c
</pre>
To create all the targets, don't specify a target on the 
command line. In the example above, <b>smake</b> encounters the target 
all first. Since the dependency list for all contains the executables 
for all the utilities, <b>smake</b> creates all the utilities. 
<p>
To create just some targets, specify them on the 
command line. For example, this command creates the programs 
write.exe and read.exe: 
<pre>
	smake write.exe read.exe makefile 
</pre>
To build a target only when you specify the 
target on the command line, make sure that target has no 
dependencies and is not the first target in the makefile. Such a target 
can delete files you no longer need or install software you just 
created. For example, suppose the makefile above ends with this 
target: 
<pre>
	clean:
		del *.obj 
</pre>
If you type only <b>smake</b>, <b>smake</b> does not perform this target's 
command. But if you type <b>smake</b> clean, <b>smake</b> performs only 
this target's command and exits. 


<h3>Choosing Dependency Files</h3>

Since you use dependency files to create the target file, the names of 
the dependency files usually appear in the command lines that 
follow the dependence line. But if an object file depends on a source 
file and that source file includes a header file, the object file depends 
on that header file. If that header file changes, you must recompile 
the source file to create a new object file. It can be useful to include 
these kinds of files in dependency lists. 
<p>
Suppose that hello.cpp includes the file hello.h. The 
dependence line for hello.obj looks like this:
<pre>
	hello.obj : hello.cpp hello.h
</pre>
If a header file isn't likely to change, omit it from the dependency 
list. For example, system header files are unlikely to change. System 
header files include header files for standard libraries, such as 
stdio.h, and header files for operating system functions, such as 
windows.h. 
<p>

Dependencies can be automatically generated with <a
href="makedep.html">MAKEDEP</a>.

<h3>Including files</h3>

To textually include files in makefiles:
<pre>
	!include filespec 
</pre>
The !include statement lets one makefile support several 
configurations of a program. Use SET commands to set 
environment variables for executed programs in the included file. 


<h3>Defining Macros</h3>

<b>smake</b> lets you define macros - identifiers that are replaced with 
text you specify. By combining the macros in a makefile with macros 
in tools. ini (see "Customizing <b>smake</b> Sessions with <tt>tools.ini</tt>" 
below), you can use a single makefile for multiple projects. Macros 
are useful for specifying compiler options, paths for targets, 
dependents, and <a href="#inference">inference rules</a>. 
<p>
Define a macro by putting a line with the following syntax in 
the makefile, in <tt>tools.ini</tt>, or on the <b>smake</b> command line: 
<pre>
	<i>macro</i>=<i>text</i> 
</pre>
<i>macro</i> is a case sensitive combination of up to 1024 letters, digits, 
and underscore (_) characters. If a <i>macro</i> is to be used as a 
command, it cannot be null or undefined. 
<p>
The <i>text</i> can be any sequence of characters, including no 
characters, or white space (interpreted as a null string). It includes all 
the text between the equals sign and the end of the line. Note that a 
<i>macro</i> defined as a null string is not equivalent to an undefined 
macro; it is still defined in relation to directives like !IFDEF and 
!IFNDEF. 
<p>
To specify an instance of a macro that is to be expanded, enclose the 
macro name in parentheses and put a dollar sign in front of it, like 
this: 
<pre>
	 
</pre>
If a macro name is only a single character, the parentheses are not 
required. 

<h3>Examples of when to use macros</h3>

Macros are especially useful for defining frequently repeated text. 
For example, if you need to make sure that all your source files are 
compiled with the same compiler options, define a macro that 
contains those options, like this: 
<pre>
	FLAGS=-c -g -DDEBUG=1 -ml 

	file1.obj: file1.cpp file2.h
		<a href="sc.html">dmc</a>  file1.cpp 

	file2.obj: file2.cpp
		<a href="sc.html">dmc</a>  file2.cpp 
</pre>
If you need to refer frequently to the same directory path, put the 
path in a macro, like this: 
<pre>
	MYLIB=c:\dev\lib 

	prog.exe: prog.obj \mylib.lib
		<a href="sc.html">dmc</a> prog.obj \mylib.lib 
</pre>

<h3>Comments in macros</h3>

A hash character (#) on a line that defines a macro starts a comment. 
To use a # as part of a macro name, precede it with a caret (^). To 
continue a macro definition on another line, end the first line with a 
backslash (\). To specify a literal backslash at the end of a line, as 
for a directory name, precede the \ with a caret. To use a 
carriage return as part of a macro name, precede the carriage 
return with a ^; this also continues the macro on the next line. 


<h3>Specifying text to be substituted</h3>

Specify text to be substituted when an instance of a macro 
is expanded by including a colon (:) followed by the string to be 
substituted for, an equal sign (=), and the string to substitute. For 
example: 
<pre>
	MODEL=L		# defines macro
		# instance to be expanded 
		# expands 'L' to 'S' 
</pre>
The substitution applies only to the current instance, not to the 
original macro definition. Do not put white space characters before 
the colon; white space after the colon is interpreted as part of the 
string to be substituted. The text to be substituted is case sensitive. 

<h3>Overriding macros on the command line</h3>

Override the macros defined in a makefile or <tt>tools.ini</tt> 
by specifying a new definition on the <b>smake</b> command line. For 
example, to override the definition of MYLIB in the example above, 
enter a command like this: 
<pre>
	smake MYLIB=c:\dev\test\lib 
</pre>
Refer to macros defined in the environment with 
the operating system command SET. For example, define 
temp with this command: 

<pre>
	set temp=c:\dos 
</pre>

and refer to it like this: 

<pre>
	test.obj: test.cpp
		<a href="sc.html">dmc</a> -cod\test.cod test.cpp 
</pre>


If you define a macro in more than one place, <b>smake</b> chooses 
definitions in this order of priority: 
<ol>
	<li> Definitions on the command line 
	<li> Definitions in the makefile 
	<li> Definitions in the environment (specified using the SET 
	command) 
</ol>

<b>Note:</b> 
	If a macro is to be passed on the command line, 
	double quotation marks (") must surround any part 
	of its definition that contain spaces. This is true not 
	only for spaces that are part of the macro's value 
	string, or even for spaces that appear on either side 
	of the equal sign (=) that separates the macro's 
	name from its value string. 


<h3>Recursively defined macros</h3>

Ordinarily, macros are defined only for the current <b>smake</b> session or 
iteration. The only macros that are defined recursively in calls to 
<b>smake</b> from within a makefile are: 

<ul>
	<li> Macros specified on the command line 
	<li> Macros predefined by environment variables 
	<li> One of the macros MAKE, MAKEDIR, or MAKEFLAG 
</ul>

<h3>Predefined macros</h3>

<b>smake</b> supports the following predefined macros, which you can 
use in your makefile: 
<p>
	Macro	Description 
<dl><dl>
	<dt>MAKE
		<dd> The name of the executable specified on the 
		<b>smake</b> command line. The default is <b>smake</b>. 

	<dt>MAKEDIR
		<dd> The current directory when <b>smake</b> was called. 

	<dt>MAKEFLAG
		<dd> The current <b>smake</b> options (you can change 
		these with the !CMDSWITCHES directive). 

	<dt>$?
		<dd> Lists dependencies that are newer than the target. 

	<dt>$**
		<dd> Full list of dependents of the current target. 

	<dt>$*
		<dd> Current target's name and path, without the extension. 

	<dt>$&lt;
		<dd> The dependent file that is newer than the target. This macro 
		is only valid within commands in <a href="#inference">inference rules</a>. 

	<dt>$@
		<dd> The current target's fully qualified path name. 

	<dt>$$@
		<dd> The current target's fully qualified path name. This macro is 
		valid only for specifying a dependent on a dependence line. 

	<dt>$$
		<dd> Expands to $. 
</dl></dl>


<h3>Modifiers for predefined macros</h3>

Use the following filename modifiers in combination with 
the predefined macros listed above: 
<p>
	Table 13-5 Filename modifiers for use with predefined macros 
<p>

	<table border=1 cellspacing=0 cellpadding=5>
	<tr>
	<th>Modifier <th>Description 
	<tr>
	<td>B <td>Base file name 
	<tr>
	<td>D <td>Drive and directory 
	<tr>
	<td>F <td>Base name and extension 
	<tr>
	<td>R <td>Drive, directory, and base name 
	</table>
<p>

For example, for the file c:\project\app.exe: 
<pre>
	$(@D) refers to c:\project
	$(@F) refers to app.exe 
	$(@B) refers to app 
	$(@R) refers to c:\project\app 
</pre>

<h3>Predefined command and option macros</h3>

<tt>tools.ini</tt> predefines macros that correspond to commands and 
command options. The option macros are undefined by default. 
Define these macros to expand to the commands and options 
to pass to the compiler and tools. (See <tt>tools.ini</tt> for a 
list of definitions.) 
<p>

	Table 13-6 Predefined command and option macros 
<p>

	<table border=1 cellspacing=0 cellpadding=5>
	<tr>
	<th>Macro <th>Description 
	<tr>
	<td>AS <td>Command to run the Microsoft Macro Assembler 
	<tr>
	<td>CC <td>Command to run the Digital Mars C Compiler 
	<tr>
	<td>CPP <td>Command to run the Digital Mars C++ Compiler 
	<tr>
	<td>CXX <td>Command to run the Digital Mars C++ Compiler 
	<tr>
	<td>RC <td>Command to run the Digital Mars Resource Compiler 
	<tr>
	<td>AFLAGS <td>Options for the Microsoft Macro Assembler 
	<tr>
	<td>CFLAGS <td>Options for the Digital Mars C Compiler 
	<tr>
	<td>CPPFLAGS <td>Options for the Digital Mars C++ Compiler 
	<tr>
	<td>CXXFLAGS <td>Options for the Digital Mars C++ Compiler 
	<tr>
	<td>RFLAGS <td>Options for the Digital Mars Resource Compiler 
	</table>

<h3>Macros for predefined environment variables</h3>

In addition to the predefined macros listed above, every 
environment variable that is defined when <b>smake</b> starts up is 
equivalent to a predefined macro. This can cause unexpected results 
if the value of an environment variable used as a macro contains a $ 
character, because <b>smake</b> interprets $ as the beginning of a macro 
invocation. 


<h3>Macro precedence</h3>

The order of precedence for macros in <b>smake</b> sessions is: 

<ol>
	<li> Macros defined on the command line 
	<li> Macros defined in a makefile or include file 
	<li> Macros that correspond to predefined environment 
	variables 
	<li> Macros defined in <tt>tools.ini</tt> 
	<li> Macros that correspond to commands or command 
	options, like CPP or CPPFLAGS 
</ol>

<h3>Using Operating System Commands</h3>

Command lines that follow dependence lines, as well as
<a href="#inference">inference rules</a>,
can contain any command that is valid on the command line. 
<b>smake</b> runs these commands when a target is out of date.
Specify multiple commands by putting each command on its own 
line. If there are no commands following a dependence line, the 
dependency is checked against the <a href="#inference">inference rules</a>. 
<p>
A command line must begin with one or more spaces or tabs, and 
must immediately follow the dependence line. No blank lines can 
separate them; however, a line containing only white space can be 
used to specify a null command. Blank lines can appear within a list 
of commands. Continue commands by ending the line to be 
continued with a backslash (\). If any characters, including spaces or 
tabs, follow the backslash, <b>smake</b> interprets them literally.
Place single commands at the end of a dependence line by 
separating the dependency from the command with a semicolon (;). 
<p>
To let <b>smake</b> know how to execute a command line, precede a 
command with any of the following modifiers. More than one 
modifier can be used with a command: 
<pre>
	Table 13-7 Modifiers for <b>smake</b> commands 
	Modifier Description 

	-	Tells <b>smake</b> to ignore the exit status from a command; 
		processing continues no matter what value the command 
		returns. Otherwise, <b>smake</b> stops executing if a command 
		returns an error. 

	-N	Tells <b>smake</b> to halt execution only if the exit status a 
		command returns is greater than the number N (even if 
		.IGNORE or /I are not being used). Otherwise <b>smake</b> 
		halts when a command returns a non-zero exit code. 

	@	Tells <b>smake</b> not to display a command when it is 
		executed, even if /S or .SILENT are not specified. 
		Otherwise, <b>smake</b> displays commands as they are 
		executed. 

	!	Executes a command for each of the dependents in the 
		dependency list. The command must use one of the file 
		name macros $** or $?, or the ! prefix is ignored. $** 
		causes the command to be executed for all of the 
		dependent files. $? causes the command to be executed 
		only for those dependent files which are more recent 
		than the target. 

	*	Allows <b>smake</b> to accept long command lines. Causes all 
		arguments to be assigned to the temporary variable 
		$MAKE$, and all arguments to be replaced with 
		@$MAKE$. 

	&lt;&lt;file	Specified after a command. If file is specified it must 
		appear immediately after the angle brackets (&lt;&lt;), with no 
		white space. If file is not specified, <b>smake</b> uses a unique 
		filename. 

		Tells <b>smake</b> to use inline files when processing a 
		command. The file is created from the literal text 
		beginning on the line immediately following the angle 
		brackets. End the inline file by beginning a line with 
		&lt;&lt;. Optionally, you can write one of the modifiers KEEP 
		or NOKEEP immediately after the closing &lt;&lt;. NOKEEP 
		(the default) tells <b>smake</b> to delete file at the end of the 
		session. KEEP tells <b>smake</b> not to delete file at the end of 
		the session (though file will be overwritten each time it is 
		used). 
</pre>
For example, in the makefile fragment below, <b>smake</b> continues 
even if the RM command returns an error, and <b>smake</b> executes the 
PROG command with command. com so you can use I/O redirection 
(with the greater than symbol &gt; in this case): 
<pre>
	install:
		-rm \bin\prog 
</pre>
<b>smake</b> always executes the commands in the table below by calling 
the operating system. The + modifier is not necessary with them.
<pre>
	break cd chdir cls copy 
	ctty date del dir echo 
	erase exit if md mkdir 
	pause rd rem rmdir ren 
	rename time type verify vol 
</pre>

<b>Note:</b> 
	<b>smake</b> handles del commands itself, unless they 
	are followed by a file specification containing 
	wildcard characters. This allows you to specify a 
	command like:
<pre>
		del  
</pre>
	where OBJS is a macro that expands to a list of file 
	names. 


<h3>Preprocessing Directives</h3>

Preprocessing directives are commands for <b>smake</b>. <b>smake</b> 
processes these directives before it processes dependency lines and 
commands. Preprocessing directives go in makefiles or 
in <tt>tools.ini</tt>. 
<p>
There are two types of preprocessing directives: 

<ul>
<li> Directives that begin with an exclamation point (!) work 
like C preprocessing directives. The ! must be the first 
character the line; it can be followed by white space. ! 
directives are not case sensitive. 

<li> Directives that begin with a period (.) and end with a 
colon (:) cannot appear among dependency lines and 
commands. They must begin the line on which they 
appear, and are case sensitive. 
</ul>

<b>smake</b> supports these ! preprocessing directives: 
<pre>
	Table 13-8 ! preprocessing directives 
	Directive Description 

	!CMDSWITCHES{+/-} opt 
		Turns on or off one or more command line 
		options with the exception of /F, /HELP, 
		/NOLOGO, /X, or /?. In the makefile, only the 
		/D, /I, /N, and /S options are valid, though 
		<tt>tools.ini</tt> can contain the others. 

	!ELSE	If the preceding !IF, !IFDEF or !IFNDEF 
		evaluated to zero, the statements between the 
		!ELSE and the next !ENDIF are processed. An 
		additional IF, IFDEF or IFNDEF can be 
		combined on the same line. 

	!ELSEIF	Equivalent to the !ELSE IF directives. 

	!ELSEIFDEF Equivalent to the !ELSE IFDEF directives. 

	!ELSEIFNDEF Equivalent to the !ELSE IFNDEF directives. 

	!ENDIF	Marks the end of a block beginning with an !IF, 
		!IFDEF, or !IFNDEF directive. 

	!ERROR text
		Stops the <b>smake</b> session with a fatal error, 
		followed by the text. This directive will stop the 
		session even if other options, directives or 
		command modifiers, such as 
		/K, /I, .IGNORE, or -, are being used. 

	!IF expression
		If the expression evaluates to other than zero, the 
		statements between the !IF and the next !ELSE 
		or !ENDIF are processed. See "Expressions in 
		preprocessing directives" below for information. 

	!IFDEF macro
		If the macro is defined, even with a null value, 
		the statements between the !IFDEF and the next 
		!ELSE or !ENDIF are processed. 

	!IFNDEF macro
		If the macro is not defined, the statements 
		between the !IFDEF and the next !ELSE or 
		!ENDIF are processed. 

	!INCLUDE &lt;filename&gt; 
		Reads and evaluates the filename and continues 
		the <b>smake</b> session. If angle brackets (&lt;&gt;) are 
		used, the directories in the INCLUDE macro is 
		searched to locate the filename. If angle brackets 
		are not used, the current directory or the 
		specified path is searched to locate the filename. 

		For compatibility with NMAKE and Digital Mars 
		MAKE, you can specify this directive without the 
		! prefix. 

	!MESSAGE text
		Writes the text to the standard output and 
		continues the <b>smake</b> session. 

	!UNDEF macro
		Removes the macro from the <b>smake</b> symbol 
		table. 
</pre>
<b>smake</b> supports these . preprocessing directives: 
<pre>
	Table 13-9 . preprocessing directives 

	Directives Description 

	.IGNORE	Directs <b>smake</b> to ignore exit codes from all the 
		commands it processes from this point to the 
		end of the file. You can also use 
		!CMDSWITCHES+/I. 
		See also /I, -, -number. 

	.LONGCOMMANDLINE: tools 
		Permits longer command lines. tools is a list of 
		one or more executable program names, with no 
		path or extension. Multiple occurrences of 
		.LONGCOMMANDLINE are cumulative. If tools is 
		not specified, the current list is cleared. Any tool 
		on the tools list whose name appears in the 
		makefile has its command line arguments passed 
		in a temporary environment variable. For 
		example: 
		.LONGCOMMANDLINE: dmc link lib 

	.PRECIOUS : targets 
		Tells <b>smake</b> not to delete the target if the 
		command to make it is interrupted. If a 
		command is interrupted with a CTRL+C or 
		CTRL+BREAK, <b>smake</b> deletes the target by 
		default. Making a target .PRECIOUS: will make 
		the target immune to deletion across the entire 
		makefile, not just a portion of it. 

	.SILENT Disables the display of command lines before 
		they are executed. You can also use 
		!CMDSWITCHES/S. 
		See also /S, @. 

	.SUFFIXES : lis
		Provides a list of file name suffixes for <b>smake</b> to 
		use when applying <a href="#inference">inference rules</a>. The 
		predefined list (as defined in <tt>tools.ini</tt>) 
		contains: .exe .obj .asm .c .cpp .cxx .res 
		.rc. 

		Additional suffixes can be added by using 
		.SUFFIX; separate each suffix in the list with 
		white space, one or more spaces, or tabs. To 
		clear the suffix list, specify .SUFFIX without any 
		suffixes. 
		See also /P. 
</pre>

<h3>Expressions in preprocessing directives</h3>

The !IF and !ELSE IF directives use the result of an expression, which 
is evaluated when these directives are encountered. This expression 
can consist of any combination of string constants, integer constants, 
or the names of external programs to be run. 
<p>
Group subexpressions by enclosing them in parentheses. 
Any constant string in an expression must be enclosed in double 
quotation marks (""), even if it is a macro. Quoted strings can be 
compared using the equality (==) or inequality (!=) operators. 
<p>
Numeric values are treated as signed long integers. Numbers are 
assumed to be decimal values. Octal values must start with 0; 
hexadecimal values must start with 0x. Constant expressions can use 
any binary operators (see below); the integer constants can also use 
the unary operators. 
<p>
An expression can also consist of the name of an external program, 
enclosed in square brackets ([]). The program will be executed 
during the preprocessing phase of makefile processing, and that 
portion of the expression will be replaced by an integer value equal 
to the error level returned by the executed program. 


<h3>Operators</h3>

Use the following operators in expressions: 
<pre>
	Table 13-10 Operators used in <b>smake</b> expressions 

	Operator Description 

	DEFINED(macro) 
		Unary operator that evaluates to TRUE if the macro 
		is defined. The expression !IF DEFINED( macro) is 
		equivalent to the expression !IFDEF macro. 

	EXIST(path)
		Unary operator that evaluates to TRUE if the path 
		exists. Some operating systems allow spaces within 
		the path name. If a space is used, the path must be 
		surrounded by double quotation marks ("). 

	+	Addition 
	-	Subtraction 
	*	Multiplication 
	/	Division 
	==	 Equality 
	!=	Inequality 
	&gt;	Greater than 
	&gt;=	Greater than or equal to 
	&lt;	Less than 
	&lt;=	Less than or equal to 
	&amp;	Bitwise AND 
	|	Bitwise OR 
	^	Bitwise XOR 
	&amp;&amp;	Logical AND 
	||	Logical OR 
	&lt;&lt;	Left shift 
	&gt;&gt;	Right shift 
	%	Modulus 
</pre>

<h3>Running programs with preprocessing directives</h3>

When you run a program with a <b>smake</b> preprocessing directive, you 
typically obtain and test its exit code and execute other commands 
based on the result. For example: 
<pre>
	!if [c:\mydir\myprog] == 0
	# continue processing 
	!else
	# do something else 
	!endif 
</pre>
Command line macros are expanded before <b>smake</b> executes the makefile.

<h2><a name="inference">Inference Rules</a></h2>

Inference rules tell <b>smake</b> how to automatically create 
certain types of files. For example, to define rules that tell 
<b>smake</b> how to create an object file (.obj) from a C++ source file 
(.cpp) and how to create an executable file (.exe) from an object 
file (.obj). Inference rules reduce the number of actions needing
to be typed in.
<p>
<b>smake</b> interprets inference rules as templates for creating a target 
from dependent files, based on the extensions of the files involved. 
Use predefined inference rules or write your own; they can 
be specified in the makefile or in <tt>tools.ini</tt>. 
<p>
To determine priorities for applying inference rules, <b>smake</b> uses the 
list associated with the .SUFFIXES directive. 


<h3>When <b>smake</b> applies inference rules</h3>

<b>smake</b> applies inference rules when: 

<ul>
<li> A dependence line does not contain any dependents or is 
not followed by any commands 

<li> A target is specified that does not exist in the makefile (or 
the makefile does not exist). 

<li> A dependent file does not exist and is not itself a target. 
</ul>

<h3>Inference rule syntax</h3>

The dependence line for an inference rule contains the source file 
extension, the destination file extension, and a colon. Inference rules 
have the following syntax: 
<pre>
	{dependent_path}.dependent_ext{target_path}target_ext: 
		commands
</pre>
where dependent_path is the path for the dependent file and 
dependent_ext its extension, and target_path is the path for the 
target and target_ext its extension. If no paths are specified, <b>smake</b> 
looks for the files in the current directory. commands are the steps 
<b>smake</b> will take if the dependent file is out of date. 
<p>
Use macros for paths and extensions. Use the macros in 
Table 13-4 to specify the arguments. Do not use white space in an 
inference rule. 
<p>
For example, this rule builds an object file from a C++ file: 

<pre>
	.cpp.obj :
		<a href="sc.html">dmc</a> -c $*	# $* contains the name of 
				# the target file without
				# an extension 
</pre>

A simple makefile can use inference rules to create a program from 
two source files, such as: 

<pre>
	.cpp.obj
		<a href="sc.html">dmc</a> -c $* 

	.obj.exe
		<a href="sc.html">dmc</a> $** 

	test.exe: test.obj util.obj 
	test.obj: test.cpp util.h
	util.obj: util.cpp 
</pre>

<h3>Levels of inference rules</h3>

<b>smake</b> can interpret no more than one level of inference rules. For 
example, this makefile does not produce an executable: 

<pre>
	.c.obj: ;<a href="sc.html">dmc</a> -c $
	.obj.exe: ;<a href="sc.html">dmc</a> $ 
	hello.exe: hello.c # ERROR 
</pre>

<h3>How inference rules work</h3>

Inference rules work on targets and dependents with the same file 
name and different extensions; they do not match multiple files. For 
example, you can specify an inference rule to build myprog.obj 
from myprog.cpp, but not yourprog.obj from myprog.cpp. 
For example, given this inference rule: 

<pre>
	.cpp.obj:   $&lt; 
</pre>

<b>smake</b> will apply this rule to any pair of target/dependency files in 
the current directory (or on the specified path) that have the same 
name, where one has the extension .cpp and the other .obj. 
<b>smake</b> will expand the predefined macros and run the resulting 
commands on those dependents that are newer than their 
corresponding targets (as specified by $&lt;). 
<p>
If the target specified has a .exe extension, <b>smake</b> searches for a 
file with the same base name and an extension that is in the 
 .SUFFIXES list to find which inference rule to use. 
<p>
If the dependence line is followed by commands but does not list 
dependents, <b>smake</b> will use the inference rules and the .SUFFIXES 
list to determine the dependent file and then apply the commands 
specified in the makefile for the target. 


<h3>Order of precedence for inference rules</h3>

<b>smake</b> determines the precedence of inference rules as follows: 
<p>

	<table border=1 cellspacing=0 cellpadding=5>
	<tr>
	<th>Order
	<th>Inference Rule
	<tr>
	<td>1
	<td>Defined in a makefile; the latest defined 
	inference rule applies. 
	<tr>
	<td>2
	<td>Defined in the <tt>tools.ini</tt> file. 
	<tr>
	<td>3
	<td>Predefined inference rule. 
	</table>


<h3>Predefined inference rules</h3>

The following inference rules are predefined in <tt>tools.ini</tt>: 
<p>
	Table 13-11 Predefined inference rules 
<p>

	<table border=1 cellspacing=0 cellpadding=5>
	<tr>
	<th>Inference rule <th>Command 
	<tr>
	<td>.asm.exe	<td>  $*.asm 
	<tr>
	<td>.asm.obj	<td>  /c $*.asm 
	<tr>
	<td>.c.exe	<td>  $*.c 
	<tr>
	<td>.c.obj	<td>  /c $*.c 
	<tr>
	<td>.cpp.exe	<td>  $*.cpp 
	<tr>
	<td>.cpp.obj	<td>  /c $*.cpp 
	<tr>
	<td>.cxx.exe	<td>  $*.cxx 
	<tr>
	<td>.cxx.obj	<td>  /c $*.cxx 
	<tr>
	<td>.rc.res	<td>  /r $* 
	</table>


<a name="tools">
<h3>Customizing <b>smake</b> Sessions with <tt>tools.ini</tt></h3>
</a>

Customize <b>smake</b> sessions by placing default values for 
command line options in the initialization file <tt>tools.ini</tt>. Any 
settings specified in <tt>tools.ini</tt> will be used for every <b>smake</b> 
session, unless /R is specified on the command line. The following is 
a sample of <b>smake</b> information in <tt>tools.ini</tt>: 

<pre>
	[SMAKE]
	# macro redefinitions 
		CCFLAGS=-A -wx -mn
		DEBUGFLAGS=-gh 
	# inference rule
	.c.obj: 
		  $&lt; 
</pre>

<b>smake</b> information must follow one of the tags [NMAKE] or 
[SMAKE]. Case is not significant. The format for comments is the 
same as in makefiles. <tt>tools.ini</tt> is read before the makefile; you 
can override macro definitions and <a href="#inverence">inference rules</a> specified in 
<tt>tools.ini</tt> in the makefile. 
<p>
When it searches for <tt>tools.ini</tt>, <b>smake</b> searches the directory for 
executable files first, then the current directory, and finally in the 
directory specified by the INIT environment variable. 


<a name="response">
<h3>Creating Response Files</h3>
</a>

<b>smake</b> can automatically creates a response file on disk, which 
contains text defined by the makefile. Specify 
the response file by name as input to another program, link 
OPTLINK or LIB. 
<p>
To write a line to a response file, use the command ECHO and 
redirect its output with one and two greater-than signs (&gt;&gt;). Write 
the first line with one greater-than sign so that ECHO creates a new 
file. Write the rest of the lines with two greater-than signs so that 
ECHO does not overwrite the file you just created. 
<p>
For example, this makefile creates the program main.exe from the 
source files main.cpp and funcs.cpp. It not only creates a linker 
response file, but also writes the linker's output to cmp.err: 

<pre>
	main.exe: main.obj funcs.obj
		echo main.obj+funcs.obj &gt; linker.rsp 
		echo main.exe,,, &gt;&gt; linker.rsp
		+<a href="optlink.html">link</a> @linker.rsp &gt; lnk.err 

	main.obj: main.cpp
		+<a href="sc.html">dmc</a> -c main.cpp &gt; cmp.err 

	funcs.obj: funcs.cpp
		+<a href="sc.html">dmc</a> -c funcs.cpp &gt;&gt; cmp.err 
</pre>

<a name="errorMessages">
<h1><b>smake</b> Error Messages</h1>
</a>

This appendix lists and describes error messages produced by the <b>smake</b>
utility.

<h3>List of <b>smake</b> Error Messages</h3>

When <b>smake</b> encounters an error, it prints a message to the screen 
describing the error and then returns to the operating system. 
<b>smake</b> error messages begin with the text "SMAKE fatal error:" 
followed in most cases by the name of the makefile and the current 
line number in the makefile, followed by one of the messages 
described below. 


<h4>access denied</h4>

DOS could not perform the action specified in a command block. 


<h4>can't create response file <i>filename</i></h4> 

<b>smake</b> could not find or open response file <i>filename</i> as specified on 
the command line (using the @ option). 


<h4>can't create temporary file <i>filename</i></h4> 

<b>smake</b> could not create the temporary file <i>filename</i>. 


<h4>can't execute command</h4> 

In a command block, the specified (DOS) command could not be 
executed. 


<h4>can't nest response file</h4> 

<b>smake</b> was passed a response file (using the @ option) that 
included another @ command. 


<h4>can't open error file <i>filename</i></h4> 

<b>smake</b> could not open the error file <i>filename</i>. 


<h4>can't open include file <i>filename</i></h4> 

<b>smake</b> could not open the #include file <i>filename</i>. 


<h4>can't open makefile <i>filename</i></h4> 

<b>smake</b> could not open the makefile <i>filename</i>. 


<h4>can't reopen <i>filename</i> for input</h4> 

<b>smake</b> could not reopen the makefile <i>filename</i> after closing a 
#included file. 


<h4>command expression retured with error code number</h4> 

In a command block, the command expression failed; it returned 
error code (ERRORLEVEL) number. 


<h4>directory not found</h4> 

In a command block, the specified (DOS) directory was not found. 


<h4>don't know how to make <i>filename</i></h4> 

<b>smake</b> did not have enough information to make target <i>filename</i> 
based on the makefile. 


<h4>error in macro substitution syntax: identifier</h4> 

The macro identifier uses internal substitution (for example, 
) incorrectly. 


<h4>exceeded max nesting level for conditionals</h4> 

Conditional directives (for example !IF) within the makefile were 
nested greater than 32 levels deep. 


<h4>extension ext too long in rule</h4> 

In a rule, <b>smake</b> encountered a file extension ext that was too long. 


<h4>file not found</h4> 

In a command block, the external (DOS) command was not found. 


<h4>illegal operator and/or operand in expression</h4> 

A conditional expression was not written properly. 


<h4>illegal string expression</h4> 

On the specified line, a string expression within a conditional 
statement used invalid syntax. 


<h4>invalid option number in parameter number</h4> 

The number th option in the number th parameter on the <b>smake</b> 
command line was invalid. 


<h4>invalid parameter number</h4> 

The number th parameter on the <b>smake</b> command line was invalid. 


<h4>not enough memory for command</h4> 

In a command block, there was not enough memory to execute the 
specified (DOS) command. 


<h4>out of memory</h4> 

<b>smake</b> could not allocate enough memory to continue. 


<h4>parameter number requires a <i>filename</i></h4> 

The number th parameter on the <b>smake</b> command line requires a 
file name argument. 


<h4>special macro expression is undefined in this context</h4> 

The predefined macro expression was used incorrectly. 


<h4>syntax error: expression</h4> 

On the specified line, expression contained a syntax error. 


<h4>text found after !ELSE</h4>

<b>smake</b> encountered text on a line following a !ELSE directive. 


<h4>too many rules or blocks for target <i>filename</i></h4> 

Target <i>filename</i> was associated with too many rules or blocks. 


<h4>unexpected directive</h4> 

<b>smake</b> encountered an invalid conditional directive (one beginning 
with a ! character). 


<h4>unknown error</h4> 

An unexpected error occurred. 


<h4>unknown error number executing command</h4> 

In a command block, a command returned an error code number 
that <b>smake</b> could not interpret. 


<h4>unmatched quotes in command identifier <i>filename</i></h4> 

<b>smake</b> was passed a response file (specified using @) that contained 
unmatched double quotation marks ("). 


<br><br><br><br>

</td></table>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

