
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - stdlib.h
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:15 2006
</div>
</div>

<!-- Generated by Ddoc from stdlib.d -->



<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>stdlib.h</h1>

<ul>
	<li><a href="#__max"><b>__max</b></a>
	<li><a href="#__min"><b>__min</b></a>
	<li><a href="#_alloca"><b>_alloca</b></a>
	<li><a href="#_atold"><b>_atold</b></a>
	<li><a href="#_chkstack"><b>_chkstack</b></a>
	<li><a href="#_cpumode"><b>_cpumode</b></a>
	<li><a href="#_ecvt"><b>_ecvt</b></a>
	<li><a href="#_environ"><b>_environ</b></a>
	<li><a href="#_exit"><b>_exit</b></a>
	<li><a href="#_fcvt"><b>_fcvt</b></a>
	<li><a href="#_fileinfo"><b>_fileinfo</b></a>
	<li><a href="#mblen"><b>mblen, _fmblen</b></a>
	<li><a href="#mbstowcs"><b>mbstowcs,_fmbstowcs</b></a>
	<li><a href="#mbtowc"><b>mbtowc, _fmbtowc</b></a>
	<li><a href="#_fmode"><b>_fmode</b></a>
	<li><a href="#_onexit"><b>_onexit, _fonexit</b></a>
	<li><a href="#_freect"><b>_freect</b></a>
	<li><a href="#_fullpath"><b>_fullpath</b></a>
	<li><a href="#wcstombs"><b>wcstombs, _fwcstombs</b></a>
	<li><a href="#wctomb"><b>wctomb, _fwctomb</b></a>
	<li><a href="#_gcvt"><b>_gcvt</b></a>
	<li><a href="#_halloc"><b>_halloc</b></a>
	<li><a href="#_hfree"><b>_hfree</b></a>
	<li><a href="#_itoa"><b>_itoa</b></a>
	<li><a href="#_lrotl"><b>_lrotl, _lrotr</b></a>
	<li><a href="#_ltoa"><b>_ltoa</b></a>
	<li><a href="#_makepath"><b>_makepath</b></a>
	<li><a href="#_memavl"><b>_memavl</b></a>
	<li><a href="#_memmax"><b>_memmax</b></a>
	<li><a href="#_msize"><b>_msize Functions</b></a>
	<li><a href="#_osmajor"><b>_osmajor</b></a>
	<li><a href="#_osminor"><b>_osminor</b></a>
	<li><a href="#_osmode"><b>_osmode</b></a>
	<li><a href="#_osver"><b>_osver</b></a>
	<li><a href="#_pgmptr"><b>_pgmptr</b></a>
	<li><a href="#_psp"><b>_psp</b></a>
	<li><a href="#_putenv"><b>_putenv</b></a>
	<li><a href="#_rotl"><b>_rotl, _rotr</b></a>
	<li><a href="#_searchenv"><b>_searchenv</b></a>
	<li><a href="#_splitpath"><b>_splitpath</b></a>
	<li><a href="#_stackavail"><b>_stackavail</b></a>
	<li><a href="#_ultoa"><b>_ultoa</b></a>
	<li><a href="#_winmajor"><b>_winmajor</b></a>
	<li><a href="#_winminor"><b>_winminor</b></a>
	<li><a href="#_winver"><b>_winver</b></a>
	<li><a href="#exit"><b>exit</b></a>
	<li><a href="#exit_pushstate"><b>exit_pushstate, exit_popstate</b></a>
	<li><a href="#abort"><b>abort</b></a>
	<li><a href="#abs"><b>abs</b></a>
	<li><a href="#atexit"><b>atexit, _fatexit</b></a>
	<li><a href="#atof"><b>atof</b></a>
	<li><a href="#atoi"><b>atoi</b></a>
	<li><a href="#atol"><b>atol</b></a>
	<li><a href="#bsearch"><b>bsearch</b></a>
	<li><a href="#calloc"><b>calloc Functions</b></a>
	<li><a href="#coreleft"><b>coreleft</b></a>
	<li><a href="#errno"><b>errno</b></a>
	<li><a href="#expand"><b>expand</b></a>
	<li><a href="#free"><b>free Functions</b></a>
	<li><a href="#getenv"><b>getenv</b></a>
	<li><a href="#ldiv"><b>ldiv, div</b></a>
	<li><a href="#malloc"><b>malloc Functions</b></a>
	<li><a href="#mblen"><b>mblen, _fmblen</b></a>
	<li><a href="#mbstowcs"><b>mbstowcs,_fmbstowcs</b></a>
	<li><a href="#mbtowc"><b>mbtowc, _fmbtowc</b></a>
	<li><a href="#_memmax"><b>_memmax</b></a>
	<li><a href="#perror"><b>perror</b></a>
	<li><a href="#qsort"><b>qsort</b></a>
	<li><a href="#rand"><b>rand</b></a>
	<li><a href="#random"><b>random</b></a>
	<li><a href="#randomize"><b>randomize</b></a>
	<li><a href="#realloc"><b>realloc Functions</b></a>
	<li><a href="#srand"><b>srand</b></a>
	<li><a href="#strtof"><b>strtof, strtod</b></a>
	<li><a href="#strtol"><b>strtol, strtoul</b></a>
	<li><a href="#strtold"><b>strtold</b></a>
	<li><a href="#system"><b>system</b></a>
	<li><a href="#_tolower"><b>_tolower, tolower, _toupper, toupper</b></a>
	<li><a href="#wcstombs"><b>wcstombs, _fwcstombs</b></a>
	<li><a href="#wctomb"><b>wctomb, _fwctomb</b></a>
</ul>

<b>Note:</b> long long forms are not supported by 16 bit memory models.
Wide character forms are only in Win32.

<!-- =========================================== -->

<hr> <h2><a name="__max">__max</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>__max(a, b); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The __max function compares the values a and b and then returns 
the larger one. The arguments can be of any numeric data type. The 
arguments and return value must be the same data types. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  max
</dd>

<dt><b>Return Value</b></dt> <dd>The larger value in arguments a or b. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#__min">__min</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of __max */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void main ()
{   
   int x = 5, y = 6, z, w; 
   
   z = __max (x, y);
   w = __min (x, y); 

   printf (" The max should be 6 and is %d\n", z);
   printf (" The min should be 5 and is %d\n", w); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">The max should be 6 and is 6
The min should be 5 and is 5 
</pre>
</dd>



 </dl>
<!-- =========================================== -->

<hr> <h2><a name="__min">__min</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>__min(a, b); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The __min function compares two values and returns the smaller 
one. The arguments can be of any numeric data type. The a and b 
arguments and the return value must all be of the same data type. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  min
</dd>

<dt><b>Return Value</b></dt> <dd>The smaller of the two arguments. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#__max">__max</a>
</dd>

<dt><b>Example</b></dt> <dd>See __max
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_alloca">_alloca</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *_alloca(size_t size); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _alloca function allocates a number of bytes (specified in the 
size parameter) on the program's stack. The allocated space is 
automatically freed when the calling function exits. Restrictions are:<p> 

<ul>    <li>Do not use the _alloca function in an expression that 
      is an argument to a function.</li>
    <li>Any function that references _alloca must declare at 
      least one local variable. When you compile with 
      optimization on, the stack pointer might not be restored 
      properly in functions that have no local variables and that 
      reference _alloca. (This restriction does not apply to 
      programs compiled with the DOSX memory model.)</li>
    <li>Do not pass the pointer value returned by _alloca as an 
      argument to free.</li>
</ul>
</dd>

<dt><b>Synonym</b></dt> <dd>Function: alloca 
</dd>

<dt><b>Return Value</b></dt> <dd>A pointer to the allocated stack area. If space cannot be allocated, 
the return value is NULL. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#calloc">calloc Functions</a><br>
<a href="#malloc">malloc Functions</a><br>
<a href="#realloc">realloc Functions</a><br>
<a href="#_stackavail">_stackavail</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _alloca 
	Also demonstrates _stackavail 
*/ 
#include &lt;malloc.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main() 
{   
    char *buffer; 

    printf (" Stack available before _alloca:% u\n", 
	      _stackavail()); 
    buffer = _alloca(100* sizeof(char)); 
    printf (" Stack available after _alloca:% u\n", 
	      _stackavail()); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd>Output will be similar to:

<pre class="console">Stack available before _alloca: 4804 
Stack available after _alloca: 4694 
</pre>
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_atold">_atold</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h<br>
math.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>long double _atold(const char *nptr);
</tt></dd>

<dt><b>Description</b></dt> <dd>Converts the string pointed to by nptr into a long double. The input string
is a sequence of characters that can be interpreted as a numerical value of
the specified type. The string may have leading spaces, tabs, and + or -.
It represent a decminal point number. This number can be followed by an
exponent that has an introductory letter (d, D, e, or E) and an optionally
signed decimal integer.
<p>

Conversion stops on the first unrecognized character. If there are no
recognized characters, the result is 0. 0 (for _atold).
</dd>

<dt><b>Return Value</b></dt> <dd>Returns the long double value derived from converting the string.  Zero is returned if the string has no recognizable characters.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#atof">atof</a><br>
<a href="#atoi">atoi</a><br>
<a href="#atol">atol</a><br>
<a href="#_ecvt">_ecvt</a><br>
<a href="#_fcvt">_fcvt</a><br>
<a href="#scanf">scanf</a><br>
<a href="#strtol">strtol</a>
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_chkstack">_chkstack</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t _chkstack(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>_chkstack determines if the stack has grown larger than the memory allocated for it and if so, aborts the program with a stack overflow message. This function should be called in recursive functions or other functions that might use a lot of stack space.  Alternatively, stack checking can be inserted in the code automatically at compilation both from within the environment and by using the -s switch in the command line. In the 32-bit memory models, the 80386 segment protection mechanism automatically aborts the program if stack space grows into the heap so this function is not implemented.
</dd>

<dt><b>Return Value</b></dt> <dd>Returns the number of bytes remaining on the stack, if the stack has not overflowed.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">If you compile the following example as a C++ program, you must
declare _stack as extern "C" because _stack has C linkage. For
example:

	extern "C" _stack = 2048 


/* 	Example for _chkstack 	*/ 

#include &lt;dos.h&gt; 
#include &lt;stdio.h&gt; 

unsigned _stack = 2048; /* Sets stack size */ 

void crush_stack (void) 
{   
   static int count = 0; 
   int remaining_stack; 
   char a_chunk_of_memory[128]; 

   *a_chunk_of_memory = '\0'; 
   remaining_stack = _chkstack (); 
   count += 1; 
   printf (" On call number %d, stack size = 
	   %d\n", count, remaining_stack); 
   crush_stack (); 
}

void main () 
{   
    crush_stack (); 
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">On call number 1, stack size = 1876
On call number 2, stack size = 1742
On call number 3, stack size = 1608
On call number 4, stack size = 1474
On call number 5, stack size = 1340
On call number 6, stack size = 1206
On call number 7, stack size = 1072
On call number 8, stack size = 938
On call number 9, stack size = 804
On call number 10, stack size = 670
On call number 11, stack size = 536
On call number 12, stack size = 402
On call number 13, stack size = 268
Stack Overflow 
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_cpumode">_cpumode</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern unsigned char _cpumode;
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable specifies the mode in which the processor is running. It can have
one of the following values:<br>

<dl>
<dt>_REAL_MODE 
<dd>Real mode 
<dt>_PROT_MODE 
<dd>Protected mode 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_ecvt">_ecvt</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_ecvt(double val, int ndig, int *decpt, int *sign)
</tt></dd>

<dt><b>Description</b></dt> <dd>The _ecvt function converts a double value to a string of digits. The 
val argument is the value to be converted and the ndig argument 
specifies the number of digits of val to be converted. If ndig is less 
than the actual number of digits in val, the digit string is rounded. If val has fewer than ndig digits, the string is padded with 0's.<p>

The decpt argument points to an integer that specifies the location 
of the decimal point, relative to the the first digit in the string. If the integer is negative, the decimal point is positioned the specified 
number of places to the left of the first digit.<p>

The sign argument points to an integer that indicates the sign of the 
converted string. If the integer is 0, the string specifies a positive 
number. Otherwise, the string specifies a negative number.<p>

The converted string is written into a statically allocated area, which 
is also used by the fcvt and printf function. Therefore, a call to 
one of these functions overwrites the result of the previous call.
</dd>

<dt><b>Synonym</b></dt> <dd>Function: ecvt 
</dd>

<dt><b>Return Value</b></dt> <dd>A pointer to the string of digits. Otherwise, returns no error.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_fcvt">_fcvt</a><br>
<a href="#sprintf">sprintf</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _ecvt */ 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{   
   double test;
   char *result; 
   int decimalpt, sign; 

   printf (" Enter a number: ") ; 
   scanf ("% lf", &test); 

   printf ("\nInput was %g\n", test); 

   result = _ecvt(test, 5, &decimalpt, &sign);
   printf (" Result string is '% s'\n", result ); 
   printf (" where the number of digits is 5,
	     the decimal point is "); 
   printf (" at position %d,\nand the sign value
	     is %d\n", decimalpt, sign); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter a number: -21.433
Input was -21.433
Result string is '21433' 
where the number of digits is 5, the decimal 
point is at position 2,
and the sign value is 1 
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_environ">_environ</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern char **_environ; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable points to an array of pointers, which point to zero or 
more environment variable strings for the process. The value of each 
string in the form, NAME= string. The string can be empty. <p>

When a program executes, its initial environment variable settings 
are copied from the environment of the parent program, which is 
usually the operating system. Functions getenv and _putenv use 
_environ to search for and modify the settings. Using _putenv to 
add or delete settings changes the size of the environment table, and 
can also change the table's memory location, depending on memory 
requirements of the program. In these cases, _environ adjusts and 
points to the correct table location. 
</dd>

<dt><b>Synonym</b></dt> <dd>Variable: environ 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_exit">_exit</a></h2><dl> 

<dt><b>Header</b></dt> <dd>process.h<br>
stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _exit(int exitstatus); 
</tt></dd>

<dt><b>Description</b></dt> <dd>_exit closes all output files and returns to the operating system 
with an exit status given by exitstatus. It does not call the static 
destructors or flush the buffers, but immediately returns to the 
operating system. <a href="#exit">exit</a> is preferred over _exit for C++ programs. 
exitstatus is normally EXIT_SUCCESS to indicate a normal end 
of program and EXIT_FAILURE to indicate an error. Only the lower 
order byte of exitstatus is returned to the parent process. The 
exit status can be referenced by the name ERRORLEVEL in batch 
files and as the return value from calls to spawn functions. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#abort">abort</a><br>
<a href="#exit">exit</a><br>
_spawn Functions
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _exit, exit */ 

#include &lt;process.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{   
   int input = 0; 
   printf (" Program demonstrating different
   paths out of a program\n"); 

   while (input &lt;1|| input &gt;2 )
   {   
	printf ("\nSelect :\n1 to call exit(),
		 \n2 to call _exit()\n"); 
	scanf ("% d", &input);
   } 
   if (input == 1)
   {   
	printf (" Calling exit(). Files will be
		  closed, buffers flushed, and\n"); 
	printf (" static destructors called.\n");
	exit(EXIT_SUCCESS); 
   }
   else 
   {
   printf (" Calling _exit(). Files will be 
		closed, buffers will not be \n");
   printf (" flushed and static destructors 
		will not be called.\n");
   _exit(EXIT_SUCCESS); 
   }
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Program demonstrating different paths out of a program

Select :
1 to call exit(),
2 to call _exit() 1
Calling exit(). Files will be closed, buffers flushed, and
static destructors will not becalled.

or

Program demonstrating different paths out of a program

Select :
1 to call exit(),
2 to call _exit()
2
Calling _exit(). Files will be closed, buffers will not be
flushed and static destructors will not be called.
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_fcvt">_fcvt</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h  (for _fcvt)
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_fcvt(double val, int count, int *decpt, int *sign); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _fcvt function converts a floating-point value to a string of 
digits. The val argument is the value to be converted, the count 
argument specifies the number of digits (of val) to be stored after 
the decimal point. If count is less than the actual number of digits 
to the right of the decimal point in val, the digit string is rounded. If val has fewer than count digits of precision, the string is padded 
with 0's. <p>

The decpt argument points to an integer that specifies the location 
of the decimal point, relative to the the first digit in the string. If the integer is negative, the decimal point is positioned the specified 
number of places to the left of the first digit. <p>

The sign argument points to an integer that indicates the sign of the 
converted string. If the integer is 0, the string specifies a positive 
number. Otherwise, the string specifies a negative number. <p>

The converted string is written into a statically allocated area, which 
is also used by the ecvt and printf functions. Therefore, a call to 
one of these functions overwrites the result of the previous call. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: fcvt 
</dd>

<dt><b>Return Value</b></dt> <dd>A pointer to the string of digits. No return value for an error. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_ecvt">_ecvt</a><br>
<a href="#sprintf">sprintf</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for fcvt */ 

#include &lt;process.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{   
   double test;
   char *result; 
   int decimalpt, sign; 

   printf (" Enter a number: ") ;
   scanf ("% lf", &test); 

   printf ("\nInput was %g\n", test); 

   result = fcvt(test, 5, &decimalpt, &sign);
   printf (" Result string is '% s'\n", result ); 
   printf (" where the number of digits after the
	     decimal point is 5,\n"); 
   printf (" the decimal point is at position %d,", decimalpt); 
   printf ("\nand the sign value is %d\n", sign); 
} 
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_fileinfo">_fileinfo</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern int _fileinfo; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable controls the passing of file information to a child 
process. By default, _fileinfo is set to 0 and does not pass 
information to the child. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="mblen">mblen</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int mblen(const char *s, size_t n);<br>
int __far _fmblen(const char __far *s, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>mblen returns the number of bytes in the multi-byte character that s 
points to. n is the maximum number of bytes to check in the 
character.<p>

_fmblen is a model-independent (large-model) form of the mblen 
function. 
</dd>

<dt><b>Return Value</b></dt> <dd>If s is not null, both functions return the number of bytes in the 
multi-byte character s. If s is null, or if the string that it points to does not contain a multi-byte character in the first n characters, both functions return -1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#mbstowcs">mbstowcs</a><br>
<a href="#mbtowc">mbtowc</a><br>
<a href="#wcstombs">wcstombs</a><br>
<a href="#wctomb">wctomb</a><br>
</dd>



 </dl>
<!-- =========================================== -->

<hr> <h2><a name="mbstowcs">mbstowcs</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);<br>
size_t __far _fmbstowcs(wchar_t __far *pwcs, const char __far *s, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>mbstowcs converts n or fewer multi-byte characters, from the s 
string, to a sequence of wide character codes. The resulting wide 
character string is stored in the array pcws. The wide character 
string in pcws is not null-terminated, unless a null character is 
encountered during conversion. If the s string contains a null 
character before n bytes, the null character is converted to a wide-character null character (L'\0').<p>

_fmbstowcs is a model-independent (large-model) form of the 
mbstowcs function. 
</dd>

<dt><b>Return Value</b></dt> <dd>The number of converted multi-byte characters. If either function 
encounters an invalid multi-byte character, it returns -1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#mbtowc">mbtowc</a><br>
<a href="#wcstombs">wcstombs</a><br>
<a href="#wctomb">wctomb</a>
</dd>

<dt><b>Example</b></dt> <dd>See wcstombs 
</dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="mbtowc">mbtowc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int mbtowc(wchar_t *pwc, const char *s, size_t n);<br>
int __far _fmbtowc(wchar_t __far *pwc, const char *s, size_t n); 

 
</tt></dd>

<dt><b>Description</b></dt> <dd>mbtowc converts the multi-byte character s to a corresponding wide 
character code (converting no more than n bytes), stores the code in 
the object pwc points to, and returns the length in bytes of the multi-byte character.<p>

_fmbtowc is a model-independent (large-model) form of the 
mbtowc function. 
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return the number of bytes copied, if successful. If s 
points to an invalid character, -1 is returned. If s is null, both 
functions return 0. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#mbtowc">mbtowc</a><br>
<a href="#wcstombs">wcstombs</a><br>
<a href="#wctomb">wctomb</a>
</dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_fmode">_fmode</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern int __cdecl _fmode; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable controls the default file translation mode. Modes are: 
<br>
<dl>
<dt>_O_TEXT
<dd>Text mode.  Carriage retur/line feeds are converted to line feeds.  This is the default.
<dt>_O_BINARY
<dd>Binary mode.  No conversions take place.
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>




 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_onexit">_onexit</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>_onexit_t _onexit(_onexit_t func);<br>
_fonexit_t __far _fonexit(_fonexit_t func); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _onexit function specifies a function to be called when a 
program terminates normally. Successive calls to _onexit create a 
register of functions that are executed in LIFO order. No more than 
32 functions can be registered with _onexit; NULL is returned if 
the number exceeds 32. For 32-bit platforms, 64 functions can be 
registered. The functions passed to _onexit do not take 
parameters. <p>

The _fonexit function is a far version of _onexit; it can be used 
with any memory model. <p>

Neither _onexit nor _fonexit are part of the ANSI definition. 
Use the <a href="#atexit">atexit</a> function for ANSI portability. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  onexit
</dd>

<dt><b>Return Value</b></dt> <dd>If successful, both functions return a pointer to the function. NULL is 
returned if there is no space left to store the function pointer. 
</dd>

<dt><b>Compatibility</b></dt> <dd>_onexit: DOS Windows 3.x Phar Lap DOSX Win32 <br>
_fonexit: DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#atexit">atexit</a><br>
<a href="#exit">exit</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _onexit */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void func1 ()
{   
   printf (" LAST printf\n");
} 

void func2 ()
{   
   printf (" This is the ");
} 

void main ()
{   
   _onexit ((_onexit_t) func1);
   _onexit ((_onexit_t) func2); 
   printf (" This is the FIRST printf\n");
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">This is the FIRST printf
This is the LAST printf 
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_freect">_freect</a></h2><dl> 

<dt><b>Header</b></dt> <dd>malloc.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned int _freect(size_t size);  
</tt></dd>

<dt><b>Description</b></dt> <dd>The _freect function determines the number of times a program 
can call a malloc function to allocate size bytes from the near 
heap. The _freect function determines this value by dividing the 
amount of memory that is available for dynamic memory allocation 
(in the default data segment) by the size argument. 
</dd>

<dt><b>Return Value</b></dt> <dd>The number of times a program can call a malloc function to 
allocate size bytes from the near heap. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#malloc">malloc Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _freect */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

void main () 
{   
   int i; 
   printf (" There is memory available for %u 
	     integers\n", _freect(sizeof(int))); 

   for (i= 0; i &lt; 1000; i++) 
      malloc(sizeof(int)); 

   printf (" After allocating 1000 integers there 
	   is room for %u more\n", 
	   _freect(sizeof(int))); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">There is memory available for 15502 integers
After allocating 1000 integers there is room for
14374 more
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_fullpath">_fullpath</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_fullpath(char *buffer, const char *pathname, size_t maxlen); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _fullpath function converts the relative pathname in the 
pathname argument to an absolute (fully qualified) pathname. The 
converted pathname is stored in the buffer argument. Argument 
maxlen specifies the length of the buffer buffer. If the length of 
the converted pathname is greater then maxlen, NULL is returned.<p> 

If the buffer argument is NULL, the _fullpath function allocates 
a buffer of _MAX_PATH size using malloc, and the maxlen 
argument is ignored. The caller must deallocate this buffer (using 
free) when appropriate.<p>

If the pathname argument specifies a disk drive, the current 
directory of this drive is combined with the path. If the drive is not 
valid, _fullpath returns NULL. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: fullpath 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns a pointer to the buffer containing the converted pathname.
Returns NULL if an error occurs. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_getcwd">_getcwd</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _fullpath */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main () 
{   
   char fname[_MAX_PATH]; 
   char full[_MAX_PATH]; 

   printf (" Enter a filename: "); 
   gets (fname); 

   if (_fullpath (full, fname, _MAX_PATH) == NULL) 
   {   
      perror (" Error calling fullpath()"); 
      <a href="#exit">exit</a>(EXIT_FAILURE); 
   } 
   printf (" The full path name is \"% s\"\n", 
	     full); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter a filename: _fullpat. c
The full path name is "C:\SC\EXAMPLES\_fullpat. c"
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="wcstombs">wcstombs</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
</tt></dd>

size_t __far _fwcstombs(char __far char *s, const wchar_t __far *pwcs, size_t n);
<p>

<dt><b>Description</b></dt> <dd>wcstombs converts the sequence of wide character codes pwcs to<br>
a multi-byte character string, stores it in the array s points to, and returns the number of array elements changed.<p>

_fwcstombs is a model-independent (large-model) form of the wcstombs function.
</dd>

<dt><b>Return Value</b></dt> <dd>The number of wide characters copied.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#mblen">mblen</a><br>
<a href="#mbstowcs">mbstowcs</a><br>
<a href="#mbtowc">mbtowc</a><br>
<a href="#wctomb">wctomb</a><br>
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="wctomb">wctomb</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int wctomb(char *s, wchar_t wchar);<br>
int __far _fwctomb(char __far *s, wchar_t wchar);
</tt></dd>

<dt><b>Description</b></dt> <dd>wctomb converts wchar to a multi-byte character, stores it in the array s points
to, and returns the length in bytes of the wide character.<p>

_fwctomb is a model-independent (large-model) form of the wctomb function.
</dd>

<dt><b>Return Value</b></dt> <dd>If successful, both functions return the number of bytes copied. If conversion
is not possible, -1 is returned. If wchar is the wide-character null character,
0 is returned.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#wcstombs">wcstombs</a><br>
<a href="#mbstowcs">mbstowcs</a><br>
<a href="#mbtowc">mbtowc</a><br>
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_gcvt">_gcvt</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_gcvt(double value, int digits, char *buffer); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _gcvt function converts the floating-point value in the value 
argument to a character string. The digits argument defines the 
number of significant digits. The resulting string is stored in the 
location pointed to by the buffer argument. A terminating null 
character is automatically appended.<p>

The _gcvt function attempts to represent significant digits in 
decimal format. If not possible, the function represents significant 
digits in exponential format. Trailing zeros might be suppressed.<p>

Be sure that buffer is large enough to accomodate the converted 
value, which may include a decimal point, a sign, exponent 
information, and the terminating null character. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  gcvt
</dd>

<dt><b>Return Value</b></dt> <dd>A pointer to the string of digits. There is no error return. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_ecvt">_ecvt</a><br>
<a href="#_fcvt">_fcvt</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _gcvt */ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main () 
{   
   char buffer[25]; 
   int precision = 4; 
   double source = 3.1415926535; 

   _gcvt (source, precision, buffer); 
   printf(" The number %8.16f converted to the 
	    string \"% s\"\n", source, buffer); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The number 3.1415926535000000 converted to the
string "3.142"
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_halloc">_halloc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void __huge *_halloc(long num, size_t size); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _halloc function allocates a huge array. The array consists of a 
number of elements, num; each element's size is represented as 
size. Each element is initialized to 0. If the size of the array is 
greater than 128K (131, 072 bytes), the size of each element must be 
a power of 2.<p> 

To free memory allocated by _halloc, use _hfree. 
</dd>

<dt><b>Return Value</b></dt> <dd>A void huge pointer to the allocated space; NULL if unsuccessful. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#free">free Functions</a><br>
<a href="#_hfree">_hfree</a><br>
<a href="#malloc">malloc Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _halloc 
	Also demonstrates _hfree, _filelength, _read 

	_HALLOC. C 

	This program must be compiled with the large 
	or compact memory models, which allow _read 
	to read into __far buffers. 
*/ 

#include &lt;malloc.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;io.h&gt; 
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;

static void error (char *message) 
{   
   perror (message); 
   <a href="#exit">exit</a>(EXIT_FAILURE); 
} 

void main () 
{   
   char __huge *buffer, filename[FILENAME_MAX], 
		   __huge *chunk, __huge *byte; 
   int handle; 
   long size; 
   unsigned actual; 

   fprintf (stderr, "Enter name of file to 
	    reverse: "); 
   gets (filename); 
   handle = _open (filename, _O_RDONLY | 
	    _O_BINARY); 
   if (handle == -1) 
      error (" Couldn't open file"); 
   size = _filelength (handle); 
   if (size == -1) 
      error (" Couldn't access file size"); 
   buffer = _halloc (size, sizeof (char)); 
   if (buffer == NULL) 
   {   
      printf (" Couldn't get a huge block %ld 
		bytes long\n", size); 
      <a href="#exit">exit</a>(EXIT_FAILURE); 
   } 
   for (chunk = buffer; chunk &lt; buffer + size; 
	chunk += actual) 
   {   
      actual = _read (handle, (void *) chunk, 
	       0xfffe); 
      if (actual == 0) 
	 break; 
   } 
   for (byte = chunk -1; byte &gt; buffer; 
	 byte -= 1) 
      putchar (* byte); 
      _hfree (buffer); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">C:\SC\EXAMPLES&gt;_halloc 
Enter name of file to reverse: _halloc. c 

} 

;) reffub(
eerfh_

;) etyb*(
rahctup 

)1 =-etyb ;reffub &gt; etyb ;1 -knuhc = etyb(
rof 

} 

;kaerb 

)0 == lautca(
fi 

;)" daer no rorrE"(
rorre 

)1-== lautca(
fi 

;) efffx0 ,knuhc)* diov(
,eldnah(
daer_= lautca 
. 
. 
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_hfree">_hfree</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _hfree(void __huge *memblock); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _hfree function deallocates a huge memory block. Argument 
memblock points to the memory previously allocated by _halloc. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#free">free Functions</a><br>
<a href="#_halloc">_halloc</a>
</dd>




 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_itoa">_itoa</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_itoa(int value, char *str, int radix); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _itoa function converts the value (in the value argument) to 
a null terminated string using the radix (base) specified in the radix 
argument. The radix must be in the range between 2 and 36. If value 
is negative and the radix is 10, the first character of the stored string is '-'. The result is stored in the string pointed to by str, which must be large enough to hold the result. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  itoa
</dd>

<dt><b>Return Value</b></dt> <dd>Returns str. Errors are not returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_ltoa">_ltoa</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _itoa */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void main () 
{   
   char buffer[10], *ptr; 
   int value = 67; 

   ptr = _itoa (value, buffer, 2); 
   printf (" The number %d in binary is 
	     \"% s\"\n", value, buffer); 

   ptr = _itoa (value, buffer, 8); 
   printf (" The number %d in octal is \"% s\"\n", 
	     value, buffer); 

   ptr = _itoa (value, buffer, 16); 
   printf (" The number %d in hex is \"% s\"\n", 
	     value, buffer); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The number 67 in binary is "1000011"
The number 67 in octal is "103"
The number 67 in hex is "43"
</pre></dd>



 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_lrotl">_lrotl</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned long _lrotl(unsigned long val, int shift);<br>
unsigned long _lrotr(unsigned long val, int shift); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The functions _lrotl and _lrotr carry out a binary rotation of 
the supplied unsigned long value, by shifting bits. 
</dd>

<dt><b>Return Value</b></dt> <dd>The rotated value as an unsigned long. There is no error return. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_rotl">_rotl</a><br>
<a href="#_rotr">_rotr</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _lrotl 
	Also demonstrates _lrotr 
*/ 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main () 
{   
   unsigned long value = 0x01234567; 
   printf (" value = %016b\n\n", value); 
   printf(" left 2 = %016b\n",_lrotl(value, 2)); 
   printf(" left 4 = %016b\n",_lrotl(value, 4)); 
   printf(" left 6 = %016b\n",_lrotl(value, 6)); 
   printf(" left 8 = %016b\n\n",_lrotl(value, 8)); 
   printf(" right 2 = %016b\n",_lrotr(value, 2)); 
   printf(" right 4 = %016b\n",_lrotr(value, 4)); 
   printf(" right 6 = %016b\n",_lrotr(value, 6)); 
   printf(" right 8 = %016b\n",_lrotr(value, 8)); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">value = 0100010101100111 

left 2 = 0001010110011100 
left 4 = 0101011001110000 
left 6 = 0101100111000000 
left 8 = 0110011100000001 

right 2 = 1101000101011001 
right 4 = 0011010001010110 
right 6 = 1000110100010101 
right 8 = 0010001101000101 
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_ltoa">_ltoa</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_ltoa(long number, char *string, int radix); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _ltoa function converts the long integer number into a null 
terminated string using the base specified in radix. The radix 
must be in the range 2 through 36. Attempts to use any other base 
causes _ltoa to ignore the radix argument and convert to 
decimal. If radix equals 10 and value is negative, the first character 
of the converted string is a minus sign. All conversions for bases 
other than 10 are unsigned. 
</dd>

<dt><b>Return Value</b></dt> <dd>A pointer to the converted string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_itoa">_itoa</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _ltoa */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt;

void main () 
{   
   char buffer[20], *ptr; 
   long value = 6989L; 

   ptr = _ltoa(value, buffer, 2); 
   printf (" The number %ld in binary is 
	     '\"% s\"\n", value, buffer); 

   ptr = _ltoa(value, buffer, 8);
   printf (" The number %ld in octal is 
	     '\"% s\"\n", value, buffer); 

   ptr = _ltoa(value, buffer, 16); 
   printf (" The number %ld in hex is '\"% s\"\n", 
	     value, buffer); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The number 6989 in binary is '" 1101101001101"
The number 6989 in octal is '" 15515" 
The number 6989 in hex is '" 1b4d"
</pre></dd>



 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_makepath">_makepath</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _makepath(char *path, const char *drive, const char *dir, const char *fname, const char *ext); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _makepath function constructs a pathname from the drive, 
directory, filename, and file extension specified in the argument list. 
The constructed pathname is stored in the location pointed to by the 
path argument. Be sure path buffer is large enough to hold the 
constructed pathname; constant _MAX_PATH, defined in 
stdlib.h, defines the maximum pathname size.<p>

Rules that apply to each component of the pathname are:<p> 
 If argument drive specifies a letter (A, B, etc) without a 
trailing colon, _makepath automatically inserts the 
colon. If drive is a null character or an empty string, no 
drive letter or colon appears in the constructed pathname.<br>
 If argument dir specifies a name without a trailing 
backslash, _makepath automatically inserts the 
backslash. If dir is a null character or an empty string, no 
directory name or backslash appears in the constructed 
pathname.<br>
 If argument fname is a null character or an empty string, 
no filename appears in the constructed pathname.<br>
 If argument ext does not contain the leading period, the 
_makepath function automatically inserts it. If ext is a 
null character or an empty string, no extension name or 
period appears in the constructed pathname.
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_fullpath">_fullpath</a><br>
<a href="#_splitpath">_splitpath</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _makepath */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;dos.h&gt;
#include &lt;direct.h&gt;

void main ()
{   
   char s[_MAX_PATH];
   char drive[_MAX_DRIVE]; 
   char dir[_MAX_DIR];
   char file[_MAX_FNAME]; 
   char ext[_MAX_EXT]; 

   _getcwd (s, _MAX_PATH);
   if (s[strlen (s) -1] != '\\') 
       strcat (s, "\\");
   _splitpath (s, drive, dir, file, ext); 
   strcpy (file, "DATA");
   strcpy (ext, ".EXT"); 
   _makepath(s, drive, dir, file, ext);
   puts(s); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">C:\SC\EXAMPLES\DATA.EXT
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_memavl">_memavl</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t _memavl(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _memavl function returns the approximate number of bytes of 
memory available for dynamic memory allocation from the near 
heap (default data segment). These bytes are not necessarily 
continguous. To find the largest number of contiguous bytes, use the 
_memmax function. 
</dd>

<dt><b>Return Value</b></dt> <dd>The approximate number of bytes of memory available for dynamic 
memory allocation. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#calloc">calloc Functions</a><br>
<a href="#_freect">_freect</a><br>
<a href="#malloc">malloc Functions</a><br>
<a href="#_memmax">_memmax</a><br>
<a href="#realloc">realloc Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _memavl */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

void main ()
{   
   long *ptr; 
   printf (" Memory available %u\n", _memavl ());
   if ((ptr = _nmalloc(1000 * sizeof (long))) != 
	 NULL)
   {   
      printf (" Memory now available %u\n",
		_memavl ()); 
      _nfree(ptr);
   } 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Memory available 59006
Memory now available 54490
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_memmax">_memmax</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t _memmax(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _memmax function returns the size in bytes of the largest 
contiguous block of memory that is available for allocation from the 
near heap (the default data segment). 
</dd>

<dt><b>Return Value</b></dt> <dd>The block size is returned. If unsuccessful, 0 is returned, indicating 
that nothing more can be allocated from the near heap. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#malloc">malloc Functions</a><br>
<a href="#_memavl">_memavl</a><br>
<a href="#_msize">_msize Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _memmax */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

void main ()
{   
   long *ptr; 
   printf (" Largest contiguous block of memory
	     is %u\n", _memmax ()); 
   if ((ptr = _nmalloc(1000 * sizeof (long))) !=
	     NULL) 
   {
      printf (" Now the largest block is %u\n", 
      _memmax ()); _nfree(ptr); 
   }
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Largest contiguous block of memory is 58992
Now the largest block is 54476
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_msize">_msize</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t _msize(void *memblock);<br>
size_t _fmsize(void __far *memblock);<br>
size_t _nmsize(void __near *memblock); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _msize functions return the size, in bytes, of the memory block 
allocated by a previous call to the appropriate version of the 
calloc, malloc, or realloc functions. For example, _fmsize 
returns the size of a memory block allocated by _fcalloc, 
_fmalloc, or _frealloc.<p>

In large data models, _msize maps to _fmsize. In small data 
models, _msize maps to _nmsize. 
</dd>

<dt><b>Return Value</b></dt> <dd>The size, in bytes, as an unsigned integer. 
</dd>

<dt><b>Compatibility</b></dt> <dd>_msize: DOS, Windows 3. x, Phar Lap/ DOSX, Win32<br>
_fmsize: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br>
_nmsize: DOS, Windows 3. x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#calloc">calloc Functions</a><br>
<a href="#malloc">malloc Functions</a><br>
<a href="#realloc">realloc Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _msize */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;malloc.h&t

void main ()
{   
   long *buffer;
   size_t size; 

   buffer = (long *) malloc(100 * sizeof(long));
   size = _msize(buffer); 
   printf(" The size of the buffer is %d\n", size); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The size of the buffer is 400
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_osmajor">_osmajor</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern unsigned char _osmajor; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable defines the major version number of the operating 
system. For example, its value running under MS-DOS 5. 0 is 5. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_osminor">_osminor</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern unsigned char _osminor;  
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable defines the minor version number of the operating 
system. For example, its value running under MS-DOS 3.1 is 10. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>



 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_osmode">_osmode</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern unsigned char _osmode; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable indicates which operating system is currently running: <p>

_DOS_MODE is 0 and indicates DOS or Phar Lap<br> 
_WIN_MODE is 2 and indicates Windows 3. x or Win32. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_osver">_osver</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern unsigned int _osver;  
</tt></dd>

<dt><b>Description</b></dt> <dd>For DOS, Windows 3. x, and Phar Lap, the _osver variable holds 
both the major and minor version numbers of the operating system. 
The high byte holds the major version number; the low byte holds 
the minor version number. This is the reverse of _osversion. For 
Win32 bit 15 is set to indicate the operating system platform: 0 is NT, 
1 is Win32. The other bits are not significant. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_pgmptr">_pgmptr</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern char __far *_pgmptr; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable is automatically initialized at startup to point to the full path
of the executing program. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>



 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_psp">_psp</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern unsigned _psp; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable contains the segment paragraph address of the program 
segment prefix. Use _psp to construct a far pointer, allowing access 
to the program segment prefix from within the program. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_putenv">_putenv</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _putenv(const char *envstring); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _putenv function adds or modifies environment variables. The 
envstring has the form varname = string, where varname 
represents an environment variable name and string represents the 
new setting. If the environment variable already exists, it is assigned 
the new setting. Otherwise, the variable is added. To remove an 
environment variable, specify an empty string. (For example, 
varname =.)<p>

The _putenv function affects the local environment for the current 
process; it does not modify the command-level environment. Any 
environment variable set will revert to its previous setting upon 
program termination. However, an environment variable set by 
_putenv is passed to spawned programs. The _putenv function 
complements the getenv function in the standard library. The 
library getenv function can be used to access environment 
variables set using putenv.<p>

Functions getenv, _putenv, and putenv use global variable 
_environ to search for and modify the settings. Using _putenv to 
add or delete settings, changes the size of the environment table, 
and can also change the table's memory location, depending on 
memory requirements of the program. In these cases, _environ 
adjusts and points to the correct table location. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if successful. Returns -1 if an error occurs. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#getenv">getenv</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _putenv 
	dumpenv. exe must also be built. 
*/ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;process.h&gt;

void main ()
{   
   if (_putenv (" ENVAR= New environment variable"))
   {   
      perror (" Could not set environment variable"); 
      exit (EXIT_FAILURE);
   } 
   else
      _spawnlp (_P_WAIT, "dumpenv. exe", NULL); 
} 


/*
   Example for _putenv 
   Compile program to file: dumpenv. exe
*/ 

#include &lt;stdio.h&gt;

void main (int argc, char *argv[], char* envp[])
{   
   char ** ep; 

   ep = envp;
   while (* ep) 
   {   
      puts (* ep); 
      ep++;
   } 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">COMSPEC=C:\COMMAND.COM
PROMPT=$p$g
INCLUDE=C:\SC\INCLUDE
LIB=C:\SC\LIB
TEMP=C:\DOS
PATH=C:\WINDOWS;C:\SC\BIN;C:\DOS;
ENVAR=New environment variable
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_rotl">_rotl</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned int _rotl(unsigned int val, int shift);<br>
unsigned int _rotr(unsigned int val, int shift); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The functions _rotl and _rotr carry out a binary rotation of the 
supplied unsigned integer, val, by shift bits. 
</dd>

<dt><b>Return Value</b></dt> <dd>Both of these functions return the rotated value as an unsigned int. 
Errors are not returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_lrotl">_lrotl</a><br>
<a href="#_lrotr">_lrotr</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _rotl
	Also demonstrates _rotr 
*/ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main ()
{   
   unsigned value = 0x01234; 

   printf (" value = %016b\n\n", value); 

   printf (" left 2 = %016b\n",
	     _rotl (value, 2)); 

   printf (" left 4 = %016b\n", 
	     _rotl (value, 4)); 

   printf (" left 6 = %016b\n", 
	     _rotl (value, 6)); 

   printf (" left 8 = %016b\n\n", 
	     _rotl (value, 8)); 

   printf (" right 2 = %016b\n", 
	     _rotr (value, 2)); 

   printf (" right 4 = %016b\n", 
	     _rotr (value, 4)); 

   printf (" right 6 = %016b\n", 
	     _rotr (value, 6)); 

   printf (" right 8 = %016b\n", 
	     _rotr (value, 8)); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">value = 0001001000110100
left 2 = 0100100011010000
left 4 = 0010001101000001
left 6 = 1000110100000100
left 8 = 0011010000010010


right 2 = 0000010010001101
right 4 = 0100000100100011
right 6 = 1101000001001000
right 8 = 0011010000010010
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_searchenv">_searchenv</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _searchenv(const char *filename, const char *varname, char *pathname); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _searchenv function searches for the file in the filename 
argument, using the environment variable in the varname 
argument. If the file is found, the complete pathname is stored in the 
buffer pointed to by the pathname argument. You must ensure that 
the pathname buffer is large enough to contain the constructed 
path name. If the filename is not found, an empty, null-terminated 
string is copied to the pathname buffer. <p>

When searching for a file, the _searchenv function searches first in 
the current working directory, and then looks through the directories 
specified by the varname environment variable. <p>

The _searchenv function is case-sensitive, so be sure that the 
varname variable matches the case of the environment variable. 
Environment variable names are uppercase. Common environment 
variables are PATH, LIB, and INCLUDE. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#getenv">getenv</a><br>
<a href="#_putenv">_putenv</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _searchenv */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void main ()
{   
   char buf[_MAX_PATH]; 

   _searchenv (" SC. EXE"," PATH", buf); 

   if (strlen (buf) == 0)
      printf (" SC. EXE not found \n"); 
   else
      printf (" SC. EXE found in %s\n", buf); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">SC.EXE found in C:\SC\BIN\SC.EXE
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_splitpath">_splitpath</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _splitpath(const char *path, char *drive, <br>
char *dir, char *name, char *ext);  
</tt></dd>

<dt><b>Description</b></dt> <dd>The _splitpath function splits the pathname pointed to by path 
into its components, and copies the components to the locations 
pointed to by the drive, dir, name, and ext arguments. The 
path argument must be of the form: <p>

drive:\dir\subdir\name. ext <p>

The function uses these conventions when copying components: <p>

The drive argument includes the colon<br> 
The dir argument includes leading, trailing backslashes<br>
The name argument will contain the filename<br> 
The ext argument will include the preceding period 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_fullpath">_fullpath</a><br>
<a href="#_makepath">_makepath</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _splitpath */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt; 

void main (int argc, char *argv[]) 
{   
   char drive[_MAX_DRIVE]; 
   char dir[_MAX_DIR]; 
   char filen[_MAX_FNAME]; 
   char ext[_MAX_EXT]; 

   _splitpath(argv[0], drive, dir, filen, ext); 

   printf(" This program's path is split as:\n" 
	"Drive: %s\n" 
	"Directory: %s\n" 
	"Filename: %s\n" 
	"Extension: %s\n", drive, dir, filen, ext); 
} 

</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">This program's path is split as:
Drive: C:
Directory: \SC\EXAMPLES
Filename: _SPLITPA
Extension: .EXE
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_stackavail">_stackavail</a></h2><dl> 

<dt><b>Header</b></dt> <dd>malloc.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t _stackavail(void);  
</tt></dd>

<dt><b>Description</b></dt> <dd>The _stackavail function gets the size, in bytes, of the available stack space for dynamically allocating stack memory with _alloca. 
</dd>

<dt><b>Return Value</b></dt> <dd>The available stack size, in bytes. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_alloca">_alloca</a>
</dd>




 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_ultoa">_ultoa</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_ultoa(unsigned long value, char *string, int radix); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _ultoa function converts the value in the value argument to 
a null-terminated string. The result is stored in the location pointed 
to by the string argument. The string can be a maximum of 33 
bytes long. The radix argument specifies the base of the value 
argument; the radix can range from 2 and 36. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: ultoa 
</dd>

<dt><b>Return Value</b></dt> <dd>A pointer to the converted string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_itoa">_itoa</a><br>
<a href="#_ltoa">_ltoa</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _ultoa */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void main () 
{   
   char buffer[64], *ptr; 
   unsigned long value = 3123456789L; 

   ptr = _ultoa(value, buffer, 2); 
   printf (" The number %lu in binary is 
	     \"% s\"\n", value, buffer); 

   ptr = _ultoa(value, buffer, 8); 
   printf (" The number %lu in octal is 
	     \"% s\"\n", value, buffer); 

   ptr = _ultoa(value, buffer, 16); 
   printf (" The number %lu in hex is \"% s\"\n", 
	     value, buffer); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The number 3123456789 in binary is<br> "10111010001011000010101100010101"
The number 3123456789 in octal is "27213025425"
The number 3123456789 in hex is "ba2c2b15"
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_winmajor">_winmajor</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern unsigned char _winmajor; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable specifies the major version number of the Windows in use. For example, the value of _winmajor running under Windows 3. 1 is 3. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_winminor">_winminor</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern unsigned char _winminor; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable specifies the minor version number of the Windows in use. For example, the value of _winminor running under Windows 3. 1 is 10.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_winver">_winver</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern unsigned int _winver; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable holds both the major and minor version numbers of the Windows in use. The high byte contains the major version, the low byte contains the minor version.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="exit">exit</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void exit (int exitstatus);
</tt></dd>

<dt><b>Description</b></dt> <dd>exit calls functions logged by <a href="#atexit">atexit</a>, all static destructors (for 
C++ programs), flushes all output buffers, closes all output files and 
returns to the operating system with an exit status given by 
exitstatus. exit is the preferred function for C++ programs. 
exitstatus is normally a EXIT_SUCCESS to indicate a normal 
end of program and EXIT_FAILURE to indicate an error. Only the 
lower order byte of exitstatus is returned to the parent process. 
The exit status can be referenced by the spawn return values. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#abort">abort</a><br>
<a href="#_exit">_exit</a><br>
_spawn
</dd>

<dt><b>Example</b></dt> <dd>See _exit
</dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="exit_pushstate">exit_pushstate</a></h2><dl> 

<dt><b>Header</b></dt> <dd>exitstat.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int exit_pushstate(int retval); int exit_popstate(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>Allows trapping calls to exit.<p>

exit_pushstate saves the current state of the list maintained by 
the <a href="#atexit">atexit</a> function, creating a new one --a new "exit state". exit 
return points are then intercepted and controlled to return to the 
position in the code of the last use of exit_pushstate. The exit 
state is then popped, returning the atexit list to its previous value. 
If an exit_popstate is encountered before a call to <a href="#exit">exit</a>, the 
exit state returns to the last pushed value.<p>

These functions can conveniently convert stand-alone programs to 
subroutines. First, use exit_pushstate to set the return point 
from <a href="#exit">exit</a>, providing an integer value that will inform the caller of 
the return value from <a href="#exit">exit</a> calls in the former stand-alone program. 
Second, set up an if statement to test if the value of retval is 0. 
This value indicates that a call to the new subroutine has not been made yet. Call the former stand-alone program's main function. 
Calls to <a href="#exit">exit</a> in the former stand-alone will return to the point at 
which exit_pushstate was called, with retval set to the return 
from the <a href="#exit">exit</a> function plus 1. Subtract 1 from the retval to 
obtain the actual return value. If the subordinate function never calls 
<a href="#exit">exit</a>, the function will return like a normal C function, at which 
point exit_popstate should be called explicitly. <p>

Functions registered with <a href="#atexit">atexit</a> in the new subroutine are called 
in last-in-first-out order before returning to the calling function. Up 
to 16 states can be pushed at one time; no more than 16 calls to 
former stand-alone programs may be on the program stack at any 
given time.
</dd>

<dt><b>Return Value</b></dt> <dd>The integer value retval will be set to the value returned by any 
calls to <a href="#exit">exit</a> plus 1 encountered before a matching 
exit_popstate has been reached. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#exit">exit</a><br>
<a href="#atexit">atexit</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for exit_popstate */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;exitstat.h&gt;

void f1 (void)
{   
   printf (" f1 called\n");
} 
void f2 (void)
{   
   printf (" f2 called\n");
} 
void f3 (void)
{   
   printf (" f3 called\n");
} 
int used_to_be_main (void) 
{
   printf (" used_to_be_main called\n"); 
   printf (" adding atexit functions\n");
   atexit (f3); 
   atexit (f2);
   printf (" exiting used_to_be_main\n"); 
   <a href="#exit">exit</a>(123);
} 
void main ()
{   
   int return_from_exit; 

   exit_pushstate (return_from_exit);
   if (return_from_exit == 0) 
   {

	used_to_be_main (); 
	exit_popstate ();
   } 
   else
	--return_from_exit; 
   atexit (f1);
   printf (" return_from_exit = %d\n", 
	     return_from_exit);
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">used_to_be_main called
adding atexit functions
exiting used_to_be_main
f2 called
f3 called
return_from_exit = 123
f1 called
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="abort">abort</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h<br>
process.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void abort(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The abort function terminates the currently executing program. It is 
the same as a function call to _exit with a non-zero status. 
</dd>

<dt><b>Return Value</b></dt> <dd>abort can be intercepted using the signal SIGABRT (see the 
function signal). abort does not flush the buffers nor does it call 
C++ static destructors. It is preferable to use <a href="#exit">exit</a>
rather than abort 
for C++ programs. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_c_exit">_c_exit</a><br>
<a href="#_cexit">_cexit</a><br>
<a href="#exit">exit</a><br>
<a href="#_exit">_exit</a><br>
<a href="#raise">raise</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for abort */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main ()
{   
   char input; 

   printf (" Enter 'a' to abort:");
   while (1) 
   {   
      scanf ("% c",&amp; input); 
      if (input == 'a')
      {   
	printf (" Aborting...\n");
	abort(); 
      }
   } 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter 'a' to abort: a
Aborting...
</pre></dd>



 </dl>
<!-- =========================================== -->

<hr> <h2><a name="atexit">atexit</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int atexit(void (__cdecl *func)(void));<br>
int __far _fatexit (void (__cdecl __far *func)(void));<br>
</tt></dd>

<dt><b>Description</b></dt> <dd>atexit registers the function func. When the program terminates normally by returning from main or by calling <a href="#exit">exit</a>,
the function is called. A maximum of 32 functions can be registered by successive calls to the atexit function. Registered functions are passed no arguments and no values are returned. The far version of atexit is _fatexit.<p>

The registered functions must have "C" linkage, the default linkage for C functions. Functions compiled with the C++ compiler must specify that they have "C" linkage in order to be registered with atexit. See the example.<p>

When <a href="#exit">exit</a> is called
(either explicitly or via a return from main):

<ol>
	<li>Functions registered via atexit are called in the re-verse order that they were registered. (last in, first out)
	<li>If this is a C++ program, the static destructors are called.
	<li>All open streams are flushed and closed.
	<li>_exit is called with the exit status, which returns to the operating system.<br>
</ol>

The _fatexit function is a far version of atexit; it can be used with any memory model.
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if func was successfully registered; otherwise non-zero if no more room exists for the function to be registered.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#exit">exit</a><br>
<a href="#_exit">_exit</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of atexit 	*/ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 


#if __cplusplus
extern "C" { /* force c linkage */ 
#endif

void xfunc1 (void)
{
    printf (" xfunc1() called.\n"); 
}

void xfunc2 (void) 
{
    printf (" xfunc2() called.\n"); 
}

#if __cplusplus 
}
#endif

void main() 
{
   atexit (xfunc1);
   atexit (xfunc2);
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">xfunc2() called.
xfunc1() called.
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="atof">atof</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h<br>
math.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>double atof(const char *nptr);
</tt></dd>

<dt><b>Description</b></dt> <dd>The atof function converts the string pointed to by nptr into a double-precision floating-point number. The string may have leading spaces, tabs, and + or -. Conversion stops on the first unrecognized character. If there are no recognized characters, the result is 0.
</dd>

<dt><b>Return Value</b></dt> <dd>Returns the double value derived from converting the string. Zero is returned if the input string has no recognizable characters.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#atoi">atoi</a><br>
<a href="#atol">atol</a><br>
<a href="#_ecvt">_ecvt</a><br>
<a href="#_fcvt">_fcvt</a><br>
<a href="#scanf">scanf</a><br>
<a href="#strtol">strtol</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of atof 	*/ 

#include &lt;stdio.h&gt; 	
#include &lt;stdlib.h&gt;

void main() 
{
   char *test1 = "3.141593"; 
   char *test2 = "123.5e15unrecognized 'u'"; 
   double result;

   result = atof (test1); 
   printf (" test1 is %g\n", result);

   result = atof (test2);
   printf (" test2 is %g\n", result); 
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">test1 is 3.14159
test2 is 1.235e+017
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="atoi">atoi</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int atoi(const char *nptr);<br>
long atol(const char *nptr);<br>
long atoll(const char *nptr);
</tt></dd>

<dt><b>Description</b></dt> <dd>
These functions convert a string to an integer. They are equivalent to:

<dl>
	<dt>atoi <dd>(int)strtol(nptr, (char **)NULL, 10);
	<dt>atol <dd>strtol(nptr, (char **)NULL, 10);
	<dt>atoll <dd>strtoll(nptr, (char **)NULL, 10);
</dl>
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns the integer value derived from converting the string.
Zero is returned if the input string has no recognizable characters.
</dd>

<dt><b>Compatibility</b></dt> <dd>
ANSI C99 7.20.1.2, DOS, Windows 3.x, Phar Lap, DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#atof">atof</a><br>
<a href="#_atold">_atold</a><br>
<a href="#_ecvt">_ecvt</a><br>
<a href="#_fcvt">_fcvt</a><br>
<a href="#scanf">scanf</a><br>
<a href="#strtol">strtol</a>


<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of atoi 	*/ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main()
{
    int result;
    char *test1 = "310"; 
    char *test2 = "No Number";

    result = atoi (test1);
    printf("Test1 is %d\n", result);

    result = atoi(test2);
    printf("Test2 is %d\n", result);
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Test1 is 310
Test2 is 0
</pre></dd>

</dd><!-- =========================================== -->

<hr> <h2><a name="bsearch">bsearch</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h<br>
search.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *bsearch(const void *key, const void *base, size_t num, size_t width, int (* cmp)(const void *elem1, const void *elem2)); 
</tt></dd>

<dt><b>Description</b></dt> <dd>bsearch performs a binary search of a sorted array of num elements, which is pointed to by base, for an element that matches key. Contents of the array must have been previously sorted into ascending order. Each item of the array is width bytes. The function used in the search is pointed to by cmp; it must be supplied by the programmer and must be declared as taking C linkage. The cmp function takes two arguments as pointers to the element in the array.  The cmp function must return one of the following values:<br>
<dl>
<b>Return a value. . ./If. . .</b> 
<dt>&lt; 0 
<dd>elem1 is less than elem2 
<dt>= 0 
<dd>elem1 and elem2 match 
<dt>&gt; 0 
<dd>elem1 is greater then elem2
</dl>

The standard library function strcmp is a suitable compare function for C-style strings.
</dd>

<dt><b>Return Value</b></dt> <dd>Returns a pointer to the matching element, or NULL if not found.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd></dd>
<a href="#_lsearch">_lsearch</a>
 </dl>


<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for bsearch 	*/ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 

#define SIZE(arr) (sizeof(arr) / sizeof(arr[0]))

int array[] = { 15,117,232,332,456,567,678,789};

#ifdef __cplusplus 
extern "C" 
#endif

int intcmp (const void *p1, const void *p2) 
{   
  return (*(int *) p1 -*(int *) p2); 
} 

void main() 
{   
    int *pointer; 
    int key = 567; 

    pointer = (int *) bsearch (&key, array, 
	      SIZE(array), sizeof(int), intcmp); 

    if (pointer) 
       printf ("[% d] is in array \n", key); 
    else 
       printf ("[% d] is not in array \n", key); 
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">[567] is in array
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="calloc">calloc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *calloc(size_t num, size_t size);<br>
void __far *_fcalloc(size_t num, size_t size);<br>
void __near *_ncalloc(size_t num, size_t size);
</tt></dd>

<dt><b>Description</b></dt> <dd>The calloc functions allocate a block of memory that is num * size bytes in size from the program heap. The memory is cleared (i. e. all bytes are initialized to zero) and a pointer to it is returned.  The calloc function allocates storage space from the heap associated with the program's data model. The _fcalloc function allocates storage from the far heap (outside the default data segment). The _ncalloc function allocates storage from the near heap (inside the default data segment.)<p>

If an error occurs (e. g. insufficient memory), NULL is returned. If either num or size is 0, NULL is returned. If a memory block larger than 64K is required, the X memory model should be used. Memory is dynamically allocated from the heap at run time, and must be freed explicitly if the space is required again within the program.
</dd>

<dt><b>Return Value</b></dt> <dd>A pointer to the allocated memory is returned on success, otherwise a NULL pointer is returned.
</dd>

<dt><b>Compatibility</b></dt> <dd>calloc: DOS Windows 3. x Phar Lap/ DOSX Win32<br>
_fcalloc: DOS Windows 3.x Phar Lap/ DOSX Win32<br>
_ncalloc: DOS Windows 3. x Phar Lap/ DOSX Win32
</dd>

<dt><b>See Also</b></dt> <dd><a href="#free">free Functions</a><br>
<a href="#malloc">malloc Functions</a><br>
<a href="#realloc">realloc Functions</a><br>
<a href="#farcalloc">farcalloc</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for calloc 	*/

#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define num 50 

/* compile with large data model */ 

void main() 
{   
   long *buffer; 

   buffer = calloc (num, sizeof(long)); 
   if (buffer == NULL) 
   {   
      fprintf (stderr, "Calloc failed"); 
      abort(); 
   }

   printf (" Memory allocated at offset:% x\n", 
	     buffer); 
   free (buffer); 
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Memory allocated at offset: ee 
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="coreleft">coreleft</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>For tiny, small, and medium models:<br>
unsigned coreleft(void);
</tt></dd>

For compact, large, and huge models:<br>
unsigned long coreleft(void); 
<p>

<dt><b>Description</b></dt> <dd>The coreleft function returns the amount of RAM not in use.
</dd>

<dt><b>Return Value</b></dt> <dd>For tiny, small, and medium models, the amount of unused memory between the top
of the heap and the stack is returned.
<p>

For compact, large, and huge models, the amount of unused memory between the
highest allocated block and the end of available memory is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#farcoreleft">farcoreleft</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for coreleft 	*/ 

#include &lt;stdio.h&gt; 
#include &lt;alloc.h&gt; 

void main () 
{   
   printf (" There is %lu core left\n", (unsigned 
	     long) coreleft ()); 
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">There is 524287 core left
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="errno">errno</a></h2><dl> 

<dt><b>Header</b></dt> <dd>errno.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern int errno;
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable is set to an error code when an error occurs in certain 
functions. The error codes are independent of the operating system. 
If a function sets errno the indication for it is in the entry for the 
function. To print the error message associated with the errno 
value, use the perror function. To access the error message string 
without printing use strerror or _strerror. <p>

Variable errno can have many values but only a subset of them are 
actually set by the functions. The entire list of values is shown here; 
those that are not set by functions show <b>NS</b>, for not set. Also, some 
of the values are for Win32 only. These are marked here as<b>Win32</b>. 
The errno values that are used and the error messages that the 
perror function outputs for each constant are: <p>
<dl>
<dt>E2BIG
<dd>Argument list too long 
<dt>EACCES
<dd>Permission denied 
<dt>EAGAIN
<dd>Resource temporarily unavailable Win32 
<dt>EBADF
<dd>Bad file descriptor 
<dt>EBUSY NS
<dd>Resource device 
<dt>ECHILD
<dd>No child process Win32 
<dt>EDEADLOCK
<dd>Resource deadlock avoided 
<dt>EDOM
<dd>Domain error 
<dt>EEXIST
<dd>File exists 
<dt>EFAULT NS
<dd>Bad address 
<dt>EFBIG NS
<dd>File too large 
<dt>EILSEQ NS
<dd>Illegal byte sequence 
<dt>EINTR NS
<dd>Interrupted function call 
<dt>EINVAL
<dd>Invalid argument 
<dt>EIO NS
<dd>Input/ output error 
<dt>EISDIR NS
<dd>Is a directory 
<dt>EMFILE
<dd>Too many open files 
<dt>EMLINK NS
<dd>Too many links 
<dt>ENAMETOOLONG NS
<dd>Filename too long 
<dt>ENFILE NS
<dd>Too many open files in system 
<dt>ENODEV NS
<dd>No such device 
<dt>ENOENT
<dd>No such file or directory 
<dt>ENOEXEC
<dd>Exec format error 
<dt>ENOLCK NS
<dd>No locks available 
<dt>ENOMEM
<dd>Not enough space 
<dt>ENOSPC
<dd>No space left on device 
<dt>ENOSYS NS
<dd>Function not implemented 
<dt>ENOTDIR NS
<dd>Not a directory 
<dt>ENOTEMPTY
<dd>Directory not empty Win32 
<dt>ENOTTY NS
<dd>Inappropriate I/ O control operation 
<dt>ENXIO NS
<dd>No such device or address 
<dt>EPERM
<dd>Operation not permitted Win32 
<dt>EPIPE
<dd>Broken pipe Win32 
<dt>ERANGE
<dd>REsult too large 
<dt>EROFS NS
<dd>Read-only file system 
<dt>ESPIPE NS
<dd>Invalid seek 
<dt>ESRCH NS
<dd>No such process 
<dt>EXDEV
<dd>Improper link 
<dt>EZERO NS
<dd>No error 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_doserrno">_doserrno</a><br>
<a href="#_sys_errlist">_sys_errlist</a><br>
<a href="#_sys_nerr">_sys_nerr</a><br>
<a href="#strerror">strerror</a><br>
<a href="#_strerror">_strerror</a><br>
<a href="#perror">perror</a>
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="expand">expand</a></h2><dl> 

<dt><b>Header</b></dt> <dd>malloc.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *_expand(void *memblock, size_t size); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The expand function attempts to enlarge or reduce the size of an 
allocated block of memory without moving its location in the heap. 
The size argument is the new block size in bytes.<p>

Argument memblock points to the beginning of the block. It can 
also point to a freed block unless an intervening call to calloc, 
malloc, realloc, or _expand occur. When it points to a freed 
block, the block remains free after a call to _expand. <p>

The function changes the size of the storage block in the data 
segment depending on the data model. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns a void pointer to the reallocated memory block. The 
_expand function returns NULL if memory is insufficient to expand 
the block. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#calloc">calloc Functions</a><br>
<a href="#malloc">malloc Functions</a><br>
<a href="#realloc">realloc Functions</a><br>
<a href="#free">free Functions </a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _expand
	Also demonstrates malloc, _msize, strcat 
   _EXPAND.C
*/ 

#include &lt;malloc.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main (int argc, char const *const argv[])
{   
   int i, total_size;
   char *args; 

   args = malloc (10);
   if (args == NULL) 
   {
	perror (" Couldn't malloc"); 
	exit (EXIT_FAILURE);
   } 
   *args = '\0';
   total_size = 1; 
   for (i = 1; i &lt; argc; i += 1)
   {   
	total_size += strlen (argv[i]) + 1;
	if (total_size &gt; _msize (args)) 
	{
	    args = _expand (args, total_size); 
	    if (args == NULL)
	    {   
	       puts ("... Couldn't expand any more");
	       exit (EXIT_FAILURE); 
	    }
	    puts ("... expanded..."); 
        }
        strcat (args, " "); 
        strcat (args, argv[i]);
        puts (args); 
   }
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">C:\SC\EXAMPLES&gt;_expand here are some command line arguments 
here
here are 
... expanded...
here are some 
.. Couldn't expand any more 
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="free">free</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h<br>
malloc.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void free(void *p);<br>
void _ffree(void __far *p);<br>
void _nfree(void __near *p); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The free functions release the memory segment pointed to by p. 
The number of bytes that are freed is the number of bytes specified 
when the segment was allocated (or reallocated). The free function 
deallocates memory from the default data segment that has been 
allocated using calloc, malloc, or realloc. The _ffree 
function deallocates memory from the far heap that has been 
allocated using _fcalloc, _fmalloc, or _frealloc. The 
_nfree function deallocates memory from the near heap that has 
been allocated using _ncalloc, _nmalloc, or _nrealloc. The 
free functions do nothing if p is NULL.
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>free: DOS Windows 3.x Phar Lap/ DOSX Win32 
_ffree: DOS Windows 3.x Phar Lap/ DOSX Win32 
_nfree: DOS Windows 3.x Phar Lap/ DOSX Win32
</dd>

<dt><b>See Also</b></dt> <dd><a href="#calloc">calloc</a><br>
<a href="#malloc">malloc</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for free */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void main () 
{   
   char *p; 
   if ((p = malloc(1000)) == NULL) 
   {   
      printf (" Unable to allocate memory.\n"); 
      <a href="#exit">exit</a>(EXIT_FAILURE); 
   } 
   printf (" Allocated 1000 bytes. Freeing...\n"); 
   free (p); 
   printf (" Freed.\n"); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Allocated 1000 bytes. Freeing...
Freed.
</pre>
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="getenv">getenv</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *getenv(const char *name); 
</tt></dd>

<dt><b>Description</b></dt> <dd>getenv searches the environment list for a string of the form 
"varname= value", where varname is equal to name, and returns a 
pointer to the value string, if such a string is present. Comparisons 
are case-sensitive and environment names are usually uppercase.<p>

Functions getenv and _putenv use global variable _environ to 
search for and modify the settings. Using _putenv to add or delete 
settings, changes the size of the environment table, and can also 
change the table's memory location, depending on memory 
requirements of the program. In these cases, _environ adjusts and 
points to the correct table location. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns a pointer to the value string of an environment variable. A 
NULL return value means the name was not found in the 
environment. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_putenv">_putenv</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for getenv */ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main () 
{   
   char *path; 

   path = getenv("PATH"); 
   if (path == NULL) 
      fprintf(stderr, "No PATH set\n"); 
   else 
      printf("PATH=%s\n", path); 	
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">PATH=Y:.;C:\NDW;C:\DOS;C:\;C:\WINDOWS;C:\SC\BIN;Z:. 
</pre>
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="abs">abs</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int abs(int i);<br>
long labs(long li);<br>
long long llabs(long long lli);
</tt></dd>

<dt><b>Description</b></dt> <dd>
The <b>abs</b> functions return the absolute value of their arguments.
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns the absolute value. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
ANSI C99 7.20.6.1, DOS, Windows 3.x, Phar Lap, DOSX, Win32 


<dt><b>See Also</b></dt> <dd>
<a href="math.html#fabs">fabs Functions</a>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* Example for labs */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void main() 
{   
   long test, result; 

   test = -314159L; 
   result = labs(test); 
   printf("The absolute value of 
	     (%ld) is (%ld)\n", test, result); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The absolute value of (-314159) is (314159) 
</pre></dd>



</dd><!-- =========================================== -->

<hr> <h2><a name="ldiv">ldiv</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>ldiv_t ldiv(long numerator, long denominator);<br>
div_t div(int numerator, int denominator); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The ldiv function divides the numerator by the denominator, 
returning the quotient and remainder. If the denominator is 0 the 
program will terminate with an error message. 
</dd>

<dt><b>Return Value</b></dt> <dd>div returns a structure of type ldiv_t, containing both quotient 
and remainder: long quot, rem. 
</dd>


DOS Windows 3.x Phar Lap DOSX Win32 
 </dl>


<dt><b>See Also</b></dt> <dd></dd>
<a href="#div">div</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for ldiv */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main () 
{   
   ldiv_t result; 
   long numerator, denominator; 

   printf (" Enter the numerator: "); 
   scanf ("% ld", &numerator); 
   printf (" And denominator: "); 
   scanf ("% ld", &denominator); 

   result = ldiv (numerator, denominator); 
   printf (" The quotient is %ld and the 
	     remainder is %ld\n", result.quot, 
      result.rem); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter the numerator: 45
And denominator: 7
The quotient is 6 and the remainder is 3
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="malloc">malloc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h<br>
malloc.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *malloc(size_t numbytes);<br>
void __far *_fmalloc(size_t numbytes);<br>
void __near *_nmalloc(size_t numbytes); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The malloc functions allocate a block of memory that is numbytes 
in size. malloc allocates memory from the heap; _fmalloc 
allocates memory from the far heap; _nmalloc allocates memory 
from the near heap. If numbytes is 0, NULL is returned.<p>

Memory allocated with malloc must be released back to the heap 
with the free function rather than with the delete operator. 
Memory allocated with _fmalloc must be released back to the 
heap with the _ffree function; memory allocated with _nmalloc 
must be released with the _nfree function. 
</dd>

<dt><b>Return Value</b></dt> <dd>Pointer to the memory block allocated. NULL is returned if not 
enough memory is available, or if numbytes is 0. 
</dd>

<dt><b>Compatibility</b></dt> <dd>malloc: DOS Windows 3. x Phar Lap/ DOSX Win32<br>
_fmalloc: DOS Windows 3. x Phar Lap/ DOSX Win32<br> 
_nmalloc: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#calloc">calloc Functions</a><br>
<a href="#free">free Functions</a><br>
<a href="#realloc">realloc Functions</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for malloc */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#define NUM_INTS 1024 

void main ()
{   
   int *memblock; 

   memblock = malloc (NUM_INTS * sizeof (int));
   if (memblock == NULL) 
   {
	perror (" Insufficient memory"); 
	<a href="#exit">exit</a>(EXIT_FAILURE);
   } 
   else
	printf (" Memory allocated\n"); 
   free(memblock);
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Memory allocated
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="mblen">mblen</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int mblen(const char *s, size_t n);<br>
int __far _fmblen(const char __far *s, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>mblen returns the number of bytes in the multi-byte character that s 
points to. n is the maximum number of bytes to check in the 
character.<p>

_fmblen is a model-independent (large-model) form of the mblen 
function. 
</dd>

<dt><b>Return Value</b></dt> <dd>If s is not null, both functions return the number of bytes in the 
multi-byte character s. If s is null, or if the string that it points to does not contain a multi-byte character in the first n characters, both functions return -1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#mbstowcs">mbstowcs</a><br>
<a href="#mbtowc">mbtowc</a><br>
<a href="#wcstombs">wcstombs</a><br>
<a href="#wctomb">wctomb</a><br>
</dd>



 </dl>
<!-- =========================================== -->

<hr> <h2><a name="mbstowcs">mbstowcs</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);<br>
size_t __far _fmbstowcs(wchar_t __far *pwcs, const char __far *s, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>mbstowcs converts n or fewer multi-byte characters, from the s 
string, to a sequence of wide character codes. The resulting wide 
character string is stored in the array pcws. The wide character 
string in pcws is not null-terminated, unless a null character is 
encountered during conversion. If the s string contains a null 
character before n bytes, the null character is converted to a wide-character null character (L'\0').<p>

_fmbstowcs is a model-independent (large-model) form of the 
mbstowcs function. 
</dd>

<dt><b>Return Value</b></dt> <dd>The number of converted multi-byte characters. If either function 
encounters an invalid multi-byte character, it returns -1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#mbtowc">mbtowc</a><br>
<a href="#wcstombs">wcstombs</a><br>
<a href="#wctomb">wctomb</a>
</dd>

<dt><b>Example</b></dt> <dd>See wcstombs 
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="mbtowc">mbtowc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int mbtowc(wchar_t *pwc, const char *s, size_t n);<br>
int __far _fmbtowc(wchar_t __far *pwc, const char *s, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>mbtowc converts the multi-byte character s to a corresponding wide 
character code (converting no more than n bytes), stores the code in 
the object pwc points to, and returns the length in bytes of the multi-byte character.<p>

_fmbtowc is a model-independent (large-model) form of the 
mbtowc function. 
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return the number of bytes copied, if successful. If s 
points to an invalid character, -1 is returned. If s is null, both 
functions return 0. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#mbtowc">mbtowc</a><br>
<a href="#wcstombs">wcstombs</a><br>
<a href="#wctomb">wctomb</a>
</dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_memmax">_memmax</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t _memmax(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _memmax function returns the size in bytes of the largest 
contiguous block of memory that is available for allocation from the 
near heap (the default data segment). 
</dd>

<dt><b>Return Value</b></dt> <dd>The block size is returned. If unsuccessful, 0 is returned, indicating 
that nothing more can be allocated from the near heap. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#malloc">malloc Functions</a><br>
<a href="#_memavl">_memavl</a><br>
<a href="#_msize">_msize Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _memmax */ 

#include <stdio.h>
#include <stdlib.h> 
#include <malloc.h> 

void main ()
{   
   long *ptr; 
   printf (" Largest contiguous block of memory
	     is %u\n", _memmax ()); 
   if ((ptr = _nmalloc(1000 * sizeof (long))) !=
	     NULL) 
   {
      printf (" Now the largest block is %u\n", 
      _memmax ()); _nfree(ptr); 
   }
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Largest contiguous block of memory is 58992
Now the largest block is 54476
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="perror">perror</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void perror(const char *msg); 
</tt></dd>

<dt><b>Description</b></dt> <dd>Displays a message on the standard error output describing the last 
error that occurred in a system or library function call. The argument 
msg is printed first, then a colon, followed by the error description. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_strerror">_strerror</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for perror */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main ()
{   
   FILE *fp; 

   fp = fopen(" perror. dat", "r"); 

   if (! fp)
      perror(" Unable to open file for reading"); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Unable to open file for reading: No such file or directory 
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="qsort">qsort</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h<br>
search.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void qsort(void *base, size_t nel, size_t size, int(__cdecl *compare)(const void *, const void*)); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The qsort function is an implementation of the quick-sort 
algorithm. It sorts a table of elements. The function arguments are: 
<br>
<dl>
<b>Argument/Descr</b>
<dt>base
<dd>Points to the element at the base of the table. 
<dt>nel
<dd>The number of elements in the table. 
<dt>size
<dd>The size in bytes of one table element. 
<dt>compare
<dd>The name of the comparison function. 
</dl>
<p>

The function compare must be written by the programmer and 
must return an integer that is less than, equal to, or greater than zero according to a comparison of the first argument to the second. 
compare should be declared as taking C linkage. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for qsort */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAXL 10
unsigned char *line[MAXL]; 

#ifdef __cplusplus
extern "C" 
#endif
// 
// Compare function sorts by pointers not rrays
// 
int comp(const void *a, const void *b)
{   
   return strcmp(*(char **) a, *(char **) b);
} 
int main()
{   
   int j, k:
   unsigned char buffer[82]; 
   printf(" Enter 10 strings to sort\n");
   for(j = 0; j &lt; MAXL; ++ j) 
   {
      printf(" String %d: ", j+ 1); 
      if(! fgets((char *) buffer, 80, stdin))
	break; 
      line[j] = malloc(strlen((char *) buffer)+ 1);
      strcpy((char *) line[j],(char *) buffer); 
   }
   printf("\n\n\nSorting ten lines from stdin:\n"); 
   qsort(line, j, sizeof(unsigned char *), comp); 

   for (k = 0; k &lt; j; k++)
      printf(" Line %d: %s", k + 1, line[k]); 
   return EXIT_SUCCESS;
} 
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter 10 strings to sort
String 1: red
String 2: green
String 3: orange
String 4: blue
String 5: white
String 6: cyan
String 7: brown
String 8: black
String 9: purple
String 10: yellow

Sorting ten lines from stdin...
Line 1: black
Line 2: blue
Line 3: brown
Line 4: cyan
Line 5: green
Line 6: orange
Line 7: purple
Line 8: red
Line 9: white
Line 10: yellow
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="rand">rand</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int rand(void);  
</tt></dd>

<dt><b>Description</b></dt> <dd>rand returns a random number in the range 0 to RAND_MAX. 
srand seeds the random number generator. 
</dd>

<dt><b>Return Value</b></dt> <dd>An integer containing the random number. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#srand">srand</a><br>
<a href="#random">random</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for rand
	Also demonstrates srand 
	Simulates the throwing of three dice */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;time.h&gt;

int dieroll ()
{   
   return ((rand () % 6) + 1);
} 

void main ()
{   
   int total = 0, die, nd;
   srand((int) time (NULL)); 

   for (nd = 0; nd &lt; 3; nd++)
   {   
      die = dieroll ();
      total += die; 

      printf (" Die roll %d: %d\n", nd + 1, die);
   } 
   printf ("\nThe total of the three dice is
	   %d.\n", total); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Die roll 1:2
Die roll 2:2
Die roll 3:5

The total of the three dice is 9.
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="random">random</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int random(int num); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The random function generates a random number between 0 and 
the upper limit specified in the num argument. 
</dd>

<dt><b>Return Value</b></dt> <dd>A random number between 0 and num -1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#rand">rand</a><br>
<a href="#randomize">randomize</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for random
	Also demonstrates randomize 
	Simulates the throwing of three dice */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int dieroll ()
{   
   return (random (6) + 1);
} 

void main ()
{   
   int total = 0, die, nd; 

   randomize (); 

   for (nd = 0; nd &lt; 3; nd++)
   {   
      die = dieroll ();
      total += die; 

      printf (" Die roll %d: %d\n", nd + 1, die);
   } 
   printf ("\nThe total of the three dice is
	   %d.\n", total); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Die roll 1:1
Die roll 2:1
Die roll 3:6

The total of the three dice is 8.
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="randomize">randomize</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void randomize(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The randomize function initializes the random number generator 
with a random value obtained by calling function time. Because 
randomize calls time, include the time.h file in your program. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#rand">rand</a><br>
<a href="#random">random</a>
</dd>

<dt><b>Example</b></dt> <dd>See random
</dd>



 </dl>
<!-- =========================================== -->

<hr> <h2><a name="realloc">realloc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h<br>
malloc.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *realloc (void *ptr, size_t size);
</tt></dd>

void __far *_frealloc(void __far *ptr, size_t size);<p>

void __near *nrealloc(void __near *ptr, size_t size); 
<p>

<dt><b>Description</b></dt> <dd>The realloc family functions change the size of a previously 
allocated memory block pointed to by ptr. The size of the block 
after the call to realloc is specified by size. If size is 0, ptr is 
free'd and NULL is returned. If ptr is NULL, then size is malloc'd 
and the result is returned. If there is insufficient room to expand the 
current block, a new block will be allocated and the current block 
released. Existing data will be copied into the new block.<p>

The realloc function reallocates memory in the default heap; 
_frealloc reallocates memory in the far heap; _nrealloc 
reallocates memory in the near heap. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns a pointer to the reallocated memory block. Returns NULL 
(but ptr is not freed) if memory is insufficient for the realloc. 
</dd>

<dt><b>Compatibility</b></dt> <dd>realloc: DOS, Windows 3. x, Phar Lap/ DOSX, Win32<br>
_frealloc: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br> 
_nrealloc: DOS, Windows 3. x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#calloc">calloc Functions</a><br>
<a href="#free">free Functions</a><br>
<a href="#malloc">malloc Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for realloc */ 

#include &lt;malloc.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main (int argc, char const *const argv[]) 
{   
   int i;
   unsigned total_size;
   char *arg_string; 

   arg_string = malloc (10);
   if (arg_string == NULL) 
   {   
      perror (" Couldn't malloc"); 
      <a href="#exit">exit</a>(EXIT_FAILURE);
   } 
   *arg_string = '\0';
   /* at least 1 for the null char at the end */ 
   total_size = 1;
   for (i = 1; i &lt; argc; i += 1) 
   {   
      /* + 1 for the blank */ 
      total_size += strlen (argv[i]) + 1;
      if (total_size &gt; _msize (arg_string)) 
      {
	 arg_string = realloc (arg_string, 
		       total_size); 
	 if (arg_string == NULL) 
	 {
	   puts ("... Couldn't expand any more"); 
	   <a href="#exit">exit</a>(EXIT_FAILURE);
	 } 
	 puts ("... expanded...");
      } 
      strcat (arg_string, " ");
      strcat (arg_string, argv[i]); 
      puts (arg_string);
   } 
} 

</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console"> Now
 Now is
 ... expanded...
 Now is the
 ... expanded...
 Now is the time
 ... expanded...
 Now is the time for
 ... expanded...
 Now is the time for all
 ... expanded...
 Now is the time for all good
 ... expanded...
 Now is the time for all good men
 ... expanded...
 Now is the time for all good men ...
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="srand">srand</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void srand(unsigned seed); 
</tt></dd>

<dt><b>Description</b></dt> <dd>srand initializes the random number generator rand with a seed 
number. If srand is never called, the default is srand(1). 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd>See rand
</dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="strtof">strtof</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>float strtof(const char *nptr, char ** endptr);<br>
double strtod(const char *nptr, char ** endptr); 
</tt></dd>

<dt><b>Description</b></dt> <dd>Converts the character representation of a floating-point value to a 
float or double. The function assumes that the input string 
(pointed to by nptr) is in the same format as a literal floating-point 
constant. The first character encountered that cannot be a part of a 
literal floating-point constant terminates the translation process. The 
address of the terminating character is assigned to the pointer 
variable pointed to by endptr. NAN and INF are valid input 
values representing NaN and infinity. 
</dd>

<dt><b>Return Value</b></dt> <dd>A float or double value based on the string pointed to by nptr. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#atof">atof</a><br>
<a href="#scanf">scanf</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for strtod */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt;

void main () 
{   
   char str[80]; 
   char *endptr; 
   double d; 

   printf (" Enter a string for double 
	     conversion: "); 
   gets (str); 

   d = strtod (str, &endptr); 
   if (endptr == str) 
      printf (" That is not a valid string\n"); 
   else 
   {   
      printf (" The converted float is %g\n", d); 
      if (strlen (endptr) != 0) 
	 printf (" The remaining string from your 
		  input is \"% s\"\n", endptr); 
   } 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter a string for double conversion: 100
bottles of beer on the wall
The converted float is 100
The remaining string from your input is "
bottles of beer on the wall"
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="strtol">strtol</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdlib.h<br>
inttypes.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
#include &lt;stdlib.h&gt;<br>
<br>
long strtol(const char *nptr, char **endptr, int base);<br>
unsigned long strtoul(const char *nptr, char **endptr, int base);<br>
long long strtoll(const char *nptr, char **endptr, int base);<br>
unsigned long long strtoull(const char *nptr, char **endptr, int base);<br>
<br>
long wcstol(const wchar_t *nptr, wchar_t **endptr, int base);<br>
unsigned long wcstoul(const wchar_t *nptr, wchar_t **endptr, int base);<br>
long long wcstoll(const wchar_t *nptr, wchar_t **endptr, int base);<br>
unsigned long long wcstoull(const wchar_t *nptr, wchar_t **endptr, int base);<br>
<br>
#include &lt;inttypes.h&gt;<br>
intmax_t strtoimax(const char *nptr, char **endptr, int base);<br>
uintmax_t strtoumax(const char *nptr, char **endptr, int base);<br>
intmax_t wcstoimax(const wchar_t *nptr, wchar_t **endptr, int base);<br>
uintmax_t wcstoumax(const wchar_t *nptr, wchar_t **endptr, int base);<br>
</tt></dd>

<dt><b>Description</b></dt> <dd>The <tt>strtol</tt> functions convert a string pointed to by <i>nptr</i> 
to an integer value. During conversion, the functions 
recognize a string of digits with the following form:

<pre class="bnf">[whitespace] [sign] [0] [{ x | X } ] [digits]
</pre>

The function stops reading the string at the first character that does 
not represent a part of the number. A pointer to that character will 
be stored into <i>*endptr</i>, if <i>endptr</i> is not <tt>NULL</tt>.
<p>

<i>base</i> is the numerical base of the conversion, which can be from
2 through 36. If it is 0, the format of the string determines the base.
If the leading character is 0 
and the second character is not <b>x</b> or <b>X</b>, the string is interpreted as 
octal. If the first character is <b>0</b> and the second character is
<b>x</b> or <b>X</b>
it will be interpreted as a hexadecimal integer.
<p>

If the leading character is <b>1</b> through <b>9</b>, the string is interpreted as a 
decimal integer. The upper or lower case letters <b>A</b> to <b>Z</b>
are assigned 
values 10 through 35. Only letters with values less than the base are 
permitted.
</dd>

<dt><b>Return Value</b></dt> <dd>
If the value overflows, then errno is set to <b>ERANGE</b> and a value is
returned from the following table. For signed functions, the sign
determines if it is the MAX or MIN value:

<table>	<tr><td>strtol		<td>LONG_MAX or LONG_MIN
	<tr><td>strtoul		<td>ULONG_MAX
	<tr><td>strtoll		<td>LLONG_MAX or LLONG_MIN
	<tr><td>strtoull	<td>ULLONG_MAX
	<tr><td>wcstol		<td>LONG_MAX or LONG_MIN
	<tr><td>wcstoul		<td>ULONG_MAX
	<tr><td>wcstoll		<td>LLONG_MAX or LLONG_MIN
	<tr><td>wcstoull	<td>ULLONG_MAX
	<tr><td>strtoimax	<td>INTMAX_MAX or INTMAX_MIN
	<tr><td>strtoumax	<td>UINTMAX_MAX
	<tr><td>wcstoimax	<td>INTMAX_MAX or INTMAX_MIN
	<tr><td>wcstoumax	<td>UINTMAX_MAX
</table>

If an unrecognized 
character is encountered before a legal character, zero is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
ANSI C99 7.8.2.3, 7.8.2.4, 7.20.1.4, 7.24.4.1.1,
DOS, Windows 3.x, Phar Lap, DOSX, Win32<br>
<b>Note:</b> long long forms are not supported by 16 bit memory models.
Wide character forms are only in Win32.
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#atoi">atoi</a><br>
<a href="#atol">atol</a><br>
<a href="#atol">atoll</a><br>
<a href="#scanf">scanf</a><br>
<a href="#strtold">strtold</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for strtol */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt; 

void main () 
{   
   char str[80]; 
   char *endptr; 
   long int i; 

   printf("Enter a string for long int conversion: "); 
   gets(str); 

   i = strtol(str, &endptr, 0); 
   if (endptr == str) 
      printf("That is not a valid string\n"); 
   else 
   {   
      printf("The converted long int is %d\n", i); 
      if (strlen(endptr) != 0) 
	 printf("The remaining string from your input is \"%s\"\n", endptr); 
   } 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter a string for long int conversion: 0x64
bottles of beer on the wall
The converted long int is 100
The remaining string from your input is "bottles of beer on the wall" 
</pre>
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="strtold">strtold</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>long double strtold(const char *nptr, char **endptr); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The strtold function converts an ASCII string pointed to by 
nptr to a long double value and recognizes a string of the form: 

<pre class="bnf">[whitespace] [sign] [digits] [.digits] [{ d | D | e | E } [sign] digits]
</pre>

A whitespace, which consists of space and tab characters, is 
ignored; sign is either plus (+) or minus (-); and digits are one 
or more decimal digits. If no digits appear before the decimal point, 
at least one must appear after the decimal point. The decimal digits 
can be followed by an exponent, which consists of an introductory 
letter and optionally signed decimal integer. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  strtold
</dd>

<dt><b>Return Value</b></dt> <dd>Returns the value of the floating-point number, except when this 
would cause an overflow. In this case, the function returns plus (+) 
or minus (-) HUGE_VAL. The function returns 0 if no conversion 
could be performed or if an underflow occurred. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#atoi">atoi</a>,
<a href="#atol">atol</a>,
<a href="#scanf">scanf</a>,
<a href="#strtol">strtol</a>
</dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="system">system</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h<br>
process.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int system(const char *string); 
</tt></dd>

<dt><b>Description</b></dt> <dd>system causes string to pass to the operating system command 
processor as if the string had been typed in at the console. The 
current program waits until the command is executed and then 
resumes. The exit status of programs run using system, cannot be 
determined. Use one of the spawn functions if an exit status is 
required. system cannot be used to set environment variables. 
</dd>

<dt><b>Return Value</b></dt> <dd>If there was not enough available memory to execute the process, 
then -1 is returned. Otherwise, a 0 is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>_exec<br>
_spawn
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for system */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;direct.h&gt;

void prompt () 
{   
   char path[_MAX_DIR]; 

   _getcwd (path, _MAX_DIR); 
   printf ("% s&gt;", path); 
} 

int execute (char *command) 
{   
   int res = 0; 

   _strupr(command); 
   if (strstr (command, "DEL") == command) 
      printf (" You do not have rights to do 
		that.\n\n"); 
   else if (strstr (command, "FORMAT") == 
	    command) 
      printf (" You do not have rights to do 
		that.\n\n"); 
   else if (strstr (command, "EXIT ALPHA") == 
	    command) 
      res = 1; 
   else 
      system (command); 

   return res; 
} 

void main () 
{   
   int res; 
   char command[128]; 

   do 
   {   
      prompt (); 
      gets (command); 

      res = execute (command); 
   } while (! res); 
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">C:\DM\BIN&gt; dir *.ini

Volume in drive C is 
Volume Serial Number is 1CD4-5ECB 
Directory of C:\DM\BIN 

TOOLS 	INI 	  610 	06-10-94 	11:34a 
SRT 	INI 	7,949 	06-11-94 	10:41a 
PENWIN 	INI 	  396 	12-07-92 	 3:10a 
PRJMGR 	INI 	  143 	06-21-94 	 9:14a 

4 file(s) 		      9,098 bytes 
			102,592,512 bytes free 

C:\DM\BIN&gt; del *.ini 
You do not have rights to do that. 

C:\DM\BIN&gt; 
</pre></dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="_tolower">_tolower</a></h2><dl> 

<dt><b>Header</b></dt> <dd>ctype.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _tolower(int c); int tolower(int c);
</tt></dd>

int _toupper(int c); int toupper(int c); 
<p>

<dt><b>Description</b></dt> <dd>The tolower function converts any integer value c in the range of 
'A' -'Z' to lowercase. The _tolower function is special version of 
tolower which is intended for use only when c is uppercase. If 
_tolower encounters a value that is not an uppercase letter, the 
result is undefined.<p>

toupper converts to uppercase the integer value c in the range of 
'a' -'z'. Function _toupper is a special version of toupper that is 
intended for use only when c is lowercase. If _toupper encounters 
a value that is not a lowercase letter, the result is undefined.<p>

These functions are implemented as macros in ctype.h, and are 
also included as functions within the library. Undefining the macros, 
or not including ctype.h, defaults to usage of the library functions. 
</dd>

<dt><b>Return Value</b></dt> <dd>tolower returns c, converted to lower case if it was uppercase, 
otherwise c is returned unchanged. toupper returns c, converted 
to upper case if it was lower case, otherwise c is returned 
unchanged. If _tolower and _toupper encounter an invalid 
character, the result is undefined. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for tolower 
	Also demonstrates _toascii, _tolower, 
	toupper, _toupper */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

void main () 
{   
   char *str = "Row, Row Row Your Boat...", *p; 

   printf (" The original string: \"% s\"\n", str); 

   printf (" After running tolower on each 
	     character: \""); 
   for (p = str; *p; p++) 
      printf("% c", tolower (* p)); 
   printf ("\"\n"); 

   printf (" After running toupper on each 
	     character: \""); 
   for (p = str; *p; p++) 
      printf("% c", toupper (* p)); 
   printf ("\"\n"); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The original string: "Row, Row Row Your Boat..."
After running tolower on each character: "row,
row row your boat..."
After running toupper on each character: "ROW,
ROW ROW YOUR BOAT..."
</pre></dd>


 </dl>
<!-- =========================================== -->

<hr> <h2><a name="wcstombs">wcstombs</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);<br>
size_t __far _fwcstombs(char __far char *s, const wchar_t __far *pwcs, size_t n);
</tt></dd>

<dt><b>Description</b></dt> <dd>wcstombs converts the sequence of wide character codes pwcs to<br>
a multi-byte character string, stores it in the array s points to, and returns the number of array elements changed.<p>

_fwcstombs is a model-independent (large-model) form of the wcstombs function.
</dd>

<dt><b>Return Value</b></dt> <dd>The number of wide characters copied.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#mblen">mblen</a><br>
<a href="#mbstowcs">mbstowcs</a><br>
<a href="#mbtowc">mbtowc</a><br>
<a href="#wctomb">wctomb</a><br>
</dd>

 </dl>
<!-- =========================================== -->

<hr> <h2><a name="wctomb">wctomb</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int wctomb(char *s, wchar_t wchar);<br>
int __far _fwctomb(char __far *s, wchar_t wchar);
</tt></dd>

<dt><b>Description</b></dt> <dd>wctomb converts wchar to a multi-byte character, stores it in the array s points
to, and returns the length in bytes of the wide character.<p>

_fwctomb is a model-independent (large-model) form of the wctomb function.
</dd>

<dt><b>Return Value</b></dt> <dd>If successful, both functions return the number of bytes copied. If conversion
is not possible, -1 is returned. If wchar is the wide-character null character,
0 is returned.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#wcstombs">wcstombs</a><br>
<a href="#mbstowcs">mbstowcs</a><br>
<a href="#mbtowc">mbtowc</a><br>
</dd>

 </dl>


<br><br><br><br>

</td></table>







<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

