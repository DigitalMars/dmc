
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - bios.h
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:13 2006
</div>
</div>

<!-- Generated by Ddoc from bios.d -->



<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">

<h1>bios.h</h1>

<ul>
	<li><a href="#biosdisk"><b>biosdisk</b></a>
	<li><a href="#_bios_keybrd"><b>_bios_keybrd, bioskey</b></a>
	<li><a href="#biosprint"><b>biosprint</b></a>
	<li><a href="#biostime"><b>biostime</b></a>
	<li><a href="#_bios_disk"><b>_bios_disk</b></a>
	<li><a href="#_bios_equiplist"><b>_bios_equiplist, biosequip</b></a>
	<li><a href="#_bios_keybrd"><b>_bios_keybrd, bioskey</b></a>
	<li><a href="#_bios_memsize"><b>_bios_memsize, biosmemory</b></a>
	<li><a href="#_bios_printer"><b>_bios_printer</b></a>
	<li><a href="#_bios_serialcom"><b>_bios_serialcom, bioscom</b></a>
	<li><a href="#_bios_timeofday"><b>_bios_timeofday</b></a>
	<li><a href="#_int86"><b>_int86, int86_real, int86</b></a>
	<li><a href="#_int86x"><b>_int86x, int86x_real, int86x</b></a>
</ul>

<!-- =========================================== -->

<hr> <h2><a name="biosdisk">biosdisk</a></h2><dl> 

<dt><b>Header</b></dt> <dd>bios.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int <b>biosdisk</b>(int <i>cmd</i>, int <i>drive</i>, int <i>head</i>, int <i>track</i>, int <i>sector</i>, int <i>nsects</i>, void *<i>buffer</i>);
</tt></dd>

<dt><b>Description</b></dt> <dd><b>biosdisk</b> accesses interrupt 0x13 for BIOS disk operations on the
drive specified by the <i>drive</i> argument.
For floppy drives, 0 identifies the first
drive, 1 is for the second drive, and so forth.
This function is not available under DOSX.
<br><br>

<i>cmd</i> specifies the disk operation to perform.
<i>head</i>, <i>track</i>, <i>sector</i>, <i>nsects</i>, and <i>buffer</i> provide
further information for the command specified by <i>cmd</i>.
<p>

The following command values are available:<br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<th> <i>cmd</i>
	<th>Meaning
	</tr><tr>
	<td>0
	<td>Resets disk system by a hard reset; all other parameters are ignored. 
	</tr><tr>
	<td>1 
	<td>Returns the status of the last disk operation; all other parameters are ignored. 
	</tr><tr>
	<td>2 
	<td>Reads the specified disk sectors. The head, track, and sector arguments specify the starting sector. The nsects argument specifies the number of sectors to read. The read data is stored in buffer.
	</tr><tr>
	<td>3
	<td>Writes disk sectors from memory. The head, track, and sector arguments specify the starting sector. The nsects argument specifies the number of sectors to write. The data is read from buffer. 
	</tr><tr>
	<td>4
	<td>Verifies sectors. The head, track, and sector arguments specify the starting sector. The nsects argument specifies the number of sectors to verify.
	</tr><tr>
	<td>5
	<td>Formats a track. The head and track arguments specify the track to format. Buffer stores the sector headers. 
	</tr><tr>
	<td>6
	<td>Formats a track and sets bad sector flags. 
	</tr><tr>
	<td>7
	<td>Formats the drive beginning at a specific track. 
	</tr><tr>
	<td>8
	<td>Gets the current drive parameters and stores them in buffer. 
	</tr><tr>
	<td>9
	<td>Initializes drive-pair characteristics. 
	</tr><tr>
	<td>10 
	<td>Does a long read. 
	</tr><tr>
	<td>11
	<td>Does a long write. 
	</tr><tr>
	<td>12
	<td>Does a disk seek.
	</tr><tr>
	<td>13
	<td>Alternates disk reset. 
	</tr><tr>
	<td>14 
	<td>Reads sector buffer. 
	</tr><tr>
	<td>15 
	<td>Writes sector buffer. 
	</tr><tr>
	<td>16 
	<td>Tests the specified drive to see if it is ready. 
	</tr><tr>
	<td>17 
	<td>Recalibrates the drive. 
	</tr><tr>
	<td>18 
	<td>Performs diagnostics on controller RAM. 
	</tr><tr>
	<td>19 
	<td>Performs drive diagnostics. 
	</tr><tr>
	<td>20 
	<td>Performs controller internal diagnostics. 
	</tr>
</table>
</dd>

<dt><b>Return Value</b></dt> <dd>A status byte that can contain the following values:<br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<td>0x00 
	<td>Successful completion 
	</tr><tr>
	<td>0x01 
	<td>Bad command 
	</tr><tr>
	<td>0x02 
	<td>Address mark not found 
	</tr><tr>
	<td>0x03 
	<td>Attempt to write to write-protected disk 
	</tr><tr>
	<td>0x04
	<td>Sector not found 
	</tr><tr>
	<td>0x05 
	<td>Reset failed (hard disk) 
	</tr><tr>
	<td>0x06 
	<td>Disk changed since last operation 
	</tr><tr>
	<td>0x07 
	<td>Drive parameter activity failed 
	</tr><tr>
	<td>0x08
	<td>Direct memory access (DMA) overrun 
	</tr><tr>
	<td>0x09 
	<td>Attempt to perform DMA across 64K 
	</tr><tr>
	<td>0x0A 
	<td>Bad sector detected 
	</tr><tr>
	<td>0x0B 
	<td>Bad track detected 
	</tr><tr>
	<td>0x0C 
	<td>Usupported track 
	</tr><tr>
	<td>0x11 
	<td>CRC/ECC corrected data error 
	</tr><tr>
	<td>0x20 
	<td>Controller failure 
	</tr><tr>
	<td>0x40 
	<td>Seek operation failed 
	</tr><tr>
	<td>0x80 
	<td>Attachment failed to respond 
	</tr><tr>
	<td>0xAA 
	<td>Drive not ready (hard disk) 
	</tr><tr>
	<td>0xBB 
	<td>Undefined errror occurred (hard disk) 
	</tr><tr>
	<td>0xCC
 	<td>Write fault occurred 
	</tr><tr>
	<td>0xE0 
	<td>Status error 
	</tr><tr>
	<td>0xFF 
	<td>Sense operation failed
	</tr>
</table>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#absread">absread</a><br>
<a href="#abswrite">abswrite</a><br>
<a href="#_bios_disk">_bios_disk</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for biosdisk 	*/ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;bios.h&gt;

void main()
{   
   int result; 
   char buffer[512]; 

   printf("Attempting to read from drive A:\n"); 
   result = biosdisk(_DISK_READ, 0, 0, 1, 1, 1, buffer); 
}
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_bios_keybrd">_bios_keybrd, bioskey</a></h2><dl>

<dt><b>Header</b></dt> <dd>bios.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _bios_keybrd(int flag);<br> 
int bioskey(int flag); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _bios_keybrd and bioskey functions pass <i>flag</i> to BIOS 
interrupt 0x16, the keyboard interrupt. The values for <i>flag</i> are:
<p>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<th>Name
	<th>Value
	<th>Meaning
	<tr>
	<td>_KEYBRD_READ <td>0x00 
	<td>Read the next key value from the keyboard input buffer. Wait for one if none are available. 
	<tr>
	<td>_KEYBRD_READY <td>0x01 
	<td>Determine if any keys are in the keyboard input buffer. 
	<tr>
	<td>_KEYBRD_SHIFTSTATUS <td>0x02 
	<td>Read the status of the shift keys. 
	<tr>
	<td>_NKEYBRD_READ <td>0x10 
	<td>Enhanced read 
	<tr>
	<td>_NKEYBRD_READY <td>0x11 
	<td>Enhanced ready 
	<tr>
	<td>_NKEYBRD_SHIFTSTATUS <td>0x12 
	<td>Enhanced shift status 
	</table>
</dd>

<dt><b>Return Value</b></dt> <dd>If <i>flag</i> is 0, the value returned is the key value.
The ASCII value of the key is returned in the low byte,
and the scan code in the high byte.
If the low byte is 0, then the key value is not an ASCII key
(it might be an arrow or function key).
<p>

If <i>flag</i> is 1, 0 is returned if there are no keys in the input buffer,
otherwise the next key value is returned.
The key value is not removed from the input buffer,
and is still available to be read.
<p>

If <i>flag</i> is 2, the value returned is the state of the shift keys
encoded into the bits as follows:<br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<td>0x01 
	<td>Right shift key is down 
	<tr>
	<td>0x02 
	<td>Left shift key is down 
	<tr>
	<td>0x04 
	<td>Ctrl key is down 
	<tr>
	<td>0x08 
	<td>Alt key is down 
	<tr>
	<td>0x10 
	<td>Scroll Lock is toggled 
	<tr>
	<td>0x20 
	<td>Num Lock is toggled 
	<tr>
	<td>0x40 
	<td>Caps Lock is toggled 
	<tr>
	<td>0x80 
	<td>Ins is toggled
	</table>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _bios_keybrd 	*/

#include &lt;bios.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 

void main() 
{   
   int key, shift; 
   int lastshift; 

   while (1) 
   {   
      shift = _bios_keybrd(2); 

      /* if shift status changes */ 
      if (shift != lastshift)
	 printf("Shift = 0x% 02x \n", shift);

      /* if a key is available */ 
      if (_bios_keybrd(1)) 
      {   
	 /* read the key */ 
	 key = _bios_keybrd(0); 
	 if ((key &amp; 0xFF) == 'q')
	     break; 
	 printf("Key = 0x% 04x \n", key); 
      } 

      lastshift = shift; 
   } 
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><ol>
<li>Press the right shift key down, release it.
<li>Press the right shift key down, then the left,
release the right then release the left.
<li>Press 'q' to quit.
</ol>
Output looks like this:

<pre class="console">Shift = 0x20
Shift = 0x21
Shift = 0x20
Shift = 0x21
Shift = 0x23
Shift = 0x22
Shift = 0x20
</pre>
</dd>
 </dl>

<!-- =========================================== -->

<hr> <h2><a name="biosprint">biosprint</a></h2><dl> 

<dt><b>Header</b></dt> <dd>bios.h</dd>

<dt><b>Prototype</b></dt> <dd><tt>int biosprint(int cmd, int abyte, int port);</tt></dd>

<dt><b>Description</b></dt> <dd>The biosprint function performs printer functions using BIOS 
interrupt 0x17. The cmd argument specifies a print command; the 
abyte argument specifies the character to print, and the port 
argument specifies the port to which the printer is connected. Port 
numbers are zero-based. (That is, a port argument of 0 indicates 
LPT1; 1 indicates LPT2, and so on.)<br><br>

The cmd argument specifies one of the following operations:<br>


	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th> cmd <th> operation
	<tr> <td>0 <td>Print the character specified in the abyte argument. 
	<tr> <td>1 <td>Initialize the selected printer. Ignore abyte argument. 
	<tr> <td>2 <td>Return current printer status. Ignore abyte argument. 
	</table>
</dd>

<dt><b>Return Value</b></dt> <dd>The current printer status. Possible values are:<br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th> value <th> meaning
	<tr> <td>0x01 <td>Printer timed out 
	<tr> <td>0x08 <td>I/ O error 
	<tr> <td>0x10 <td>Printer selected
	<tr> <td>0x20 <td>Out of paper 
	<tr> <td>0x40 <td>Acknowledge 
	<tr> <td>0x80 <td>Printer not busy 
	</table>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_bios_equiplist">_bios_equiplist</a><br>
<a href="#_bios_printer">_bios_printer</a><br>
<a href="#_bios_serialcom">_bios_serialcom</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for biosprint */ 

#include &lt;stdio.h&gt;
#include &lt;bios.h&gt;

void main () 
{   
   int status, bit_number; 
   char *description[] = 
   {   
      "Printer timed out", 
      "Unknown status", 
      "Unknown status", 
      "I/O error", 
      "Printer selected", 
      "Out of paper", 
      "Acknowledge", 
      "Printer not busy" 
   }; 

   status = biosprint (_PRINTER_STATUS, 0, 1); 
   for (bit_number = 0; bit_number &lt; 8; bit_number += 1) 
      if (status &amp; (1 &lt;&lt; bit_number)) 
	 printf("% s\n", description[bit_number]); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">I/O error
Acknowledge
Printer not busy 
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="biostime">biostime</a></h2><dl> 

<dt><b>Header</b></dt> <dd>bios.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>long biostime(int cmd, long newtime); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The biostime function either reads or sets the BIOS timer, using BIOS interrupt
0x1A. The cmd argument determines whether the time is to be read (cmd = 0) or
set (cmd = 1). If the time is to be read, the function returns current BIOS time
(in clock ticks since midnight). If the time is to be set, the BIOS time of day
counter is set to the value of newtime. The BIOS timer counts ticks since
midnight at a rate of approximately 18. 2 clock ticks per second.
</dd>

<dt><b>Return Value</b></dt> <dd>If the cmd argument is 0, the current value of the BIOS timer is returned. If
the cmd argument is 1, the timer is set to the long value in the newtime
argument.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_bios_timeofday">_bios_timeofday</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for biostime 	*/ 

#include &lt;stdio.h&gt; 
#include &lt;bios.h&gt; 

void main () 
{   
   long ticks;

   ticks = biostime (0, 0L); 
   printf("Ticks since midnight is %d\n", ticks); 
}
</pre>
<br><br>

<dt><b>Output</b></dt> <dd><pre class="console">Ticks since midnight is 25622
</pre>
</dd>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_bios_disk">_bios_disk</a></h2><dl> 

<dt><b>Header</b></dt> <dd>bios.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _bios_disk(unsigned service, struct diskinfo_t *info); 
</tt></dd>

<dt><b>Description</b></dt> <dd>_bios_disk is a direct interface to the BIOS disk control interrupt 0x13.
<i>service</i> specifies the disk function desired;
<i>info</i> specifies the disk parameters.
This function is not available under DOSX.
<p>

Six services are available on a basic IBM PC.
They are selected by <i>service</i>:
<p>

	<table border=1 cellpadding=4 cellspacing=0>

	<tr>
	<th><i>service</i>
	<th>Value
	<th>Operation
	<tr>
	<td>_DISK_RESET 
	<td>0
	<td>Causes a hard reset of the floppy disk controller and is useful after an error occurs. Ignores the info parameter.
	<tr>
	<td>_DISK_STATUS 
	<td>1
	<td>Obtains the status of the last disk operation. Ignores the info parameter.
	<tr>
	<td>_DISK_READ 
	<td>2
	<td>Reads one or more disk sectors into the memory buffer pointed to by buffer in the diskinfo_t structure. Requires all fields in the diskinfo_t structure, pointed to by info, be correctly set up.
	<tr>
	<td>_DISK_WRITE 
	<td>3
	<td>Writes one or more disk sectors with data from the memory buffer pointed to by buffer in the diskinfo_t structure. Requires all fields in structure diskinfo_t, pointed to by info, be correctly set up.
	<tr>
	<td>_DISK_VERIFY 
	<td>4
	<td>Verifies that disk sectors exist and are readable.
	Performs a CRC (cyclic redundancy check).
	Requires all fields in structure diskinfo_t, pointed to by info,
	be correctly set up.
	<tr>
	<td>_DISK_FORMAT 
	<td>5
	<td>Formats the track specified in the head and track fields of the diskinfo_t structure pointed to by info. Only one track can be formatted in each call. The buffer field contains a set of sector markers, the format of which depends on the type of disk drive. See an IBM reference manual for marker formats.

	</table>
<br><br>

The format of the diskinfo_t structure is:<br>

<pre class="ccode">struct diskinfo_t { 
  unsigned drive;      /* drive number*/
  unsigned head;       /* head number*/
  unsigned track;      /* track number*/
  unsigned sector;     /* start sector no.*/
  unsigned nsectors;   /* sectors to process */
  void __far *buffer;  /* Memory buffer to use */ 
};
</pre>
</dd>

<dt><b>Return Value</b></dt> <dd>Depends on the service requested. Reset and format services do not return
meaningful values. Read, write, and verify services return the number of sectors
processed in the low byte; the high byte is 0. The status service, and if an
error has occurred, the read, write, or verify service, places a code in the
high byte of the return value.<br><br>

The status codes are:<br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<td>0x01 
	<td>Invalid request / bad command 
	<tr>
	<td>0x02 
	<td>Address mark not found 
	<tr>
	<td>0x04 
	<td>Sector not found 
	<tr>
	<td>0x05 
	<td>Reset failure 
	<tr>
	<td>0x07 
	<td>Drive parameter activity failure 
	<tr>
	<td>0x09 
	<td>DMA overrun 
	<tr>
	<td>0x0a 
	<td>Bad sector flag detected 
	<tr>
	<td>0x10 
	<td>Data read (ECC) error 
	<tr>
	<td>0x11 
	<td>Corrected data read (ECC) error 
	<tr>
	<td>0x20 
	<td>Controller failure 
	<tr>
	<td>0x40 
	<td>Seek error 
	<tr>
	<td>0x80 
	<td>Disk timed out / not responding 
	<tr>
	<td>0xaa 
	<td>Drive not ready 
	<tr>
	<td>0xbb 
	<td>Undefined error 
	<tr>
	<td>0xcc 
	<td>Write fault 
	<tr>
	<td>0xe0 
	<td>Status error 
	<tr>
	<td>0XFF 
	<td>Sense operation failed 
	</table>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#biosdisk">biosdisk</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _bios_disk 	*/ 

#include &lt;bios.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib. h&gt 

int lowbytes (int tomask) 
{   
   return (tomask &amp; 0x00FF); 
} 

int highbytes (int toshift) 
{   
   return (toshift &gt;&gt; 8); 
} 

void main() 
{   
   int status; 
   struct diskinfo_t disk; 

   status = _bios_disk (1, &disk); 
   status = highbytes (status); 
   if (status != 0) 
      printf("Last disk operation had error %x\n", status); 
   else 
      printf("Last disk operation completed OK.\n"); 
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Last disk operation completed OK.</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_bios_equiplist">_bios_equiplist, biosequip</a></h2><dl>

<dt><b>Header</b></dt> <dd>bios.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _bios_equiplist(void);
</tt></dd>

<dt><b>Synonym</b></dt> <dd>biosequip
</dd>

<dt><b>Description</b></dt> <dd>The _bios_equiplist function executes BIOS interrupt 0x11 to determine what equipment is present.
</dd>

<dt><b>Return Value</b></dt> <dd>A register value indicating what equipment is installed.<br>


	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th> Bit <th> Meaning
	<tr> <td>15,14 <td>The number of printers attached 
	<tr> <td>13 <td>Not used 
	<tr> <td>12 <td>1 if a game adaptor is attached 
	<tr> <td>11,10,9 <td>The number of serial (RS232) ports 
	<tr> <td>8 <td>Not used 
	<tr> <td>7,6 <td>The number of diskette drives (maximum 4) 
	<tr> <td>5,4 <td>The initial video mode 
	<tr> <td>00 <td>Not used 
	<tr> <td>01 <td>40x25 color 
	<tr> <td>10 <td>80x25 color 
	<tr> <td>11 <td>Monochrome 
	<tr> <td>3,2 <td>Planar RAM size (11 = 64k which is normal) 
	<tr> <td>1 <td>Not used 
	<tr> <td>0 <td>Set if there are any diskette drives
	</table>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_bios_keybrd">_bios_keybrd</a><br>
<a href="#_bios_memsize"> _bios_memsize</a><br>
<a href="#_bios_printer">_bios_printer</a><br>
<a href="#_bios_serialcom">_bios_serialcom</a><br>
<a href="#_bios_disk">_bios_disk</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _bios_equiplist 	*/ 

#include &lt;bios.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib. h&gt 

#define GAME_ADAPTOR 0x0c

void main() 
{   
   unsigned equipment;

   equipment = _bios_equiplist(); 

   if (equipment &amp; GAME_ADAPTOR) 
      printf("Game adaptor installed.\n"); 
   else 
      printf("No game adaptor installed.\n"); 

}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Game adaptor installed.</pre>
</dd>
 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_bios_keybrd">_bios_keybrd, bioskey</a></h2><dl>

<dt><b>Header</b></dt> <dd>bios.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _bios_keybrd(int flag);<br> 
int bioskey(int flag); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _bios_keybrd and bioskey functions pass flag to BIOS 
interrupt 0x16, the keyboard interrupt. The values for flag are:<br><br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th> Macro <th> flag <th> Meaning
	<tr> <td>_KEYBRD_READ <td> 0x00
		<td>Read the next key value from the
		keyboard input buffer. Wait for one
		if none are available. 
	<tr> <td>_KEYBRD_READY <td> 0x01 
		<td>Determine if any keys are in the
		keyboard input buffer.
	<tr> <td>_KEYBRD_SHIFTSTATUS <td> 0x02 <td>Read the status of the shift keys.
	<tr> <td>_NKEYBRD_READ <td> 0x10 <td>Enhanced read 
	<tr> <td>_NKEYBRD_READY <td> 0x11 <td>Enhanced ready 
	<tr> <td>_NKEYBRD_SHIFTSTATUS <td> 0x12 <td>Enhanced shift status 
	</table>
</dd>

<dt><b>Return Value</b></dt> <dd>If flag is 0, the value returned is the key value. The ASCII value of<br> 
the key is returned in the low byte, and the scan code in the high<br>
byte. If the low byte is 0, then the key value is not an ASCII key (it<br> 
might be an arrow or function key). If flag is 1, 0 is returned if<br>
there are no keys in the input buffer, otherwise the next key value is<br> 
returned. The key value is not removed from the input buffer, and is<br>
still available to be read. If flag is 2, the value returned is the state<br> 
of the shift keys encoded into the bits as follows:<br><br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <td> 0x01 <td>Right shift key is down 
	<tr> <td> 0x02 <td>Left shift key is down 
	<tr> <td> 0x04 <td>Ctrl key is down 
	<tr> <td> 0x08 <td>Alt key is down 
	<tr> <td> 0x10 <td>Scroll Lock is toggled 
	<tr> <td> 0x20 <td>Num Lock is toggled 
	<tr> <td> 0x40 <td>Caps Lock is toggled 
	<tr> <td> 0x80 <td>Ins is toggled
	</table>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _bios_keybrd 	*/

#include &lt;bios.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib. h&gt 

void main() 
{   
   int key, shift; 
   int lastshift; 

   while (1) 
   {   
      shift = _bios_keybrd (2); 

      /* if shift status changes */ 
      if (shift != lastshift)
	 printf("Shift = 0x% 02x \n", shift);

      /* if a key is available */ 
      if (_bios_keybrd(1)) 
      {   
	 /* read the key */ 
	 key = _bios_keybrd(0); 
	 if ((key &amp; 0xFF) == 'q') break; 
	 printf("Key = 0x% 04x \n", key); 
      } 

      lastshift = shift; 
   } 
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd>Press the right shift key down, release it.<br>
Press the right shift key down, then the left,<br>
release the right<br>
then release the left. Press 'q' to quit.<br>
Output looks like this:<br><br>

<pre class="console">Shift = 0x20
Shift = 0x21
Shift = 0x20
Shift = 0x21
Shift = 0x23
Shift = 0x22
Shift = 0x20
</pre>
</dd>
 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_bios_memsize">_bios_memsize, biosmemory</a></h2><dl>

<dt><b>Header</b></dt> <dd>bios.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _bios_memsize(void); 
</tt></dd>

<dt><b>Synonym</b></dt> <dd>biosmemory()
</dd>

<dt><b>Description</b></dt> <dd>The function _bios_memsize executes a BIOS interrupt 0x12, which is the memory
size determination routine.
</dd>

<dt><b>Return Value</b></dt> <dd>Returns the maximum number of contiguous 1K memory blocks which are present, as
an integer.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_bios_equiplist">_bios_equiplist</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _bios_memsize 	*/

#include &lt;bios.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main() 
{   
   printf("The memory size of this system is %dK\n",
	_bios_memsize());
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">The memory size of this system is 636K</pre>
</dd>
 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_bios_printer">_bios_printer</a></h2><dl> 

<dt><b>Header</b></dt> <dd>bios.h</dd>

<dt><b>Prototype</b></dt> <dd><tt>int <b>_bios_printer</b>(unsigned <i>service</i>, unsigned <i>printer</i>, unsigned <i>data</i>);
</tt></dd>

<dt><b>Description</b></dt> <dd><b>_bios_printer</b> executes a BIOS interrupt 0x17, which is the printer
interface routine. <i>service</i> determines which of three possible
operations to perform:
<br><br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th> <i>service</i> <th> Value <th> Operation
	<tr> <td>_PRINTER_WRITE <td> 0 <td>Write the low order byte of <i>data</i>
	to the printer which was specified in the <i>printer</i> argument.
	<tr> <td>_PRINTER_INIT <td> 1 <td>Initialize the selected <i>printer</i>.
	Ignore the <i>data</i> argument. 
	<tr> <td>_PRINTER_STATUS <td> 2 <td>Return the current <i>printer</i>
	status.  Ignore the <i>data</i> argument.
	</table>
<br><br>

<b>_bios_printer</b> is not supported under windows.
</dd>

<dt><b>Return Value</b></dt> <dd>The low byte of the return value, for all three services, contains the printer
status. Possible values are:
<br><br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <td>0x01 <td>Printer timed out 
	<tr> <td>0x08 <td>I/ O error 
	<tr> <td>0x10 <td>Printer selected 
	<tr> <td>0x20 <td>Out of paper 
	<tr> <td>0x40 <td>Acknowledge 
	<tr> <td>0x80 <td>Printer not busy
	</table>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_bios_equiplist">_bios_equiplist</a><br>
<a href="#biosprint">biosprint</a>
</dd>

<dt><b>Example</b></dt> <dd>
<pre class="ccode">/* 	Example for <b>_bios_printer</b> 
*/ 
#include &lt;bios.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib. h&gt 

void main() 
{   

   unsigned i, data = 36; 
   unsigned status; 

   printf("Place printer offline and press [Enter]\n"); 
   getchar (); 
   status = <b>_bios_printer</b>(2, 0, data); 
   printf("Status with printer offline: %x\n", status); 

   printf("Press [Enter] to initialize printer\n"); 
   getchar(); 
   status = <b>_bios_printer</b>(1, 0, data); 
   printf("Status after printer initialized: %x\n", status);

   printf("Press [Enter] to print\n"); 
   getchar(); 
   for (i= 0; i&gt; 10; i++) 
      <b>_bios_printer</b>(0, 0, data); 

   status = <b>_bios_printer</b>(0, 0, '\n'); 
   printf("Status after printing %d %c's:% x\n", i, data, status); 
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Place printer offline and press [Enter]
Status with printer offline:
Press [Enter] to initialize printer
Status after printer initialized:
Press [Enter] to print
Status after printing $'s: 
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_bios_serialcom">_bios_serialcom, bioscom</a></h2><dl>

<dt><b>Header</b></dt> <dd>bios.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _bios_serialcom(unsigned service, unsigned port, unsigned data); 
</tt></dd>

<dt><b>Synonym</b></dt> <dd>bioscom()
</dd>

<dt><b>Description</b></dt> <dd>This function uses the BIOS to provide serial RS232 operations. The function is not supported under Microsoft Windows. The IBM BIOS allows only polled operation of the serial ports, not interrupt operation. The port argument is the number of the serial port to address. This is set to 0 for COM1 and 1 for COM2.<br><br>

Four services are provided:<br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <td>_COM_INIT, or 0 <td>Set up the serial port as specified in the data argument (see below).
	<tr> <td>_COM_SEND, or 1 <td>Transmit the data character through the selected serial port 
	<tr> <td>_COM_RECEIVE, or 2 <td>Accepts an input character through the selected serial port. 
	<tr> <td>_COM_STATUS, or 3 <td>Return the current status of the selected serial port.
	</table>
<br><br>

The data argument for the initialize service is created by OR'ing together one value from each of the following categories.<br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th> Baud Rate <th> Value
	<tr> <td>_COM_110 <td>0 
	<tr> <td>_COM_150 <td>32 
	<tr> <td>_COM_300 <td>64 
	<tr> <td>_COM_600 <td>96 
	<tr> <td>_COM_1200 <td>128 
	<tr> <td>_COM_2400 <td>160 
	<tr> <td>_COM_4800 <td>192 
	<tr> <td>_COM_9600 <td>224 
	</table>
<br><br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th> Data Word Length <th> Value
	<tr> <td>_COM_CHR7 <td>2 
	<tr> <td>_COM_CHR8 <td>3
	</table>
<br><br>
 
	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th># of Stop Bits <th> Value
	<tr> <td>_COM_STOP1 <td>0 
	<tr> <td>_COM_STOP2 <td>4
	</table>
<br><br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th>Parity <th> Value 
	<tr> <td>_COM_NOPARITY <td>0 
	<tr> <td>_COM_ODDPARITY <td>8 
	<tr> <td>_COM_EVENPARITY <td>24 
	</table>
</dd>

<dt><b>Return Value</b></dt> <dd>A 16-bit integer whose high byte contains status bits. The low byte<br> 
varies according to the service requested. High byte status bits are:<br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th> Bit <th> Meaning when set 
	<tr> <td>15 <td>Timed out 
	<tr> <td>14 <td>Transmitter Shift register empty 
	<tr> <td>13 <td>Transmitter Holding register empty 
	<tr> <td>12 <td>Break detected 
	<tr> <td>11 <td>Framing Error 
	<tr> <td>10 <td>Parity Error 
	<tr> <td>9 <td>Overrun Error 
	<tr> <td>8 <td>Data Ready
	</table>
<br><br>

If the send service is requested but data cannot be sent, bit 15 is set.<br><br> 

If the receive service is requested, the byte read is returned in the low byte. If an error occurrs, at least one bit in the high byte is set to indicate the source of the error.<br><br>

If the service requested is either initialize or status, additional status information are returned in the low byte:
<br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <th> Bit <th> Meaning when set 
	<tr> <td>7 <td>Data Carrier Detect (DCD) state 
	<tr> <td>6 <td>Ring Indicator (RI) state 
	<tr> <td>5 <td>Data Set Ready (DSR) state 
	<tr> <td>4 <td>Clear To Send (CTS) state 
	<tr> <td>3 <td>Change in DCD 
	<tr> <td>2 <td>Change in RI 
	<tr> <td>1 <td>Change in DSR 
	<tr> <td>0 <td>Change in CTS
	</table>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _bios_serialcom 	*/

#include &lt;bios.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib. h&gt

void main() 
{   
   unsigned com1_status;

   com1_status = _bios_serialcom (3,0,0); 
   printf("Com1 status : %x\n", com1_status); 
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Com1 status : 6000</pre>
</dd>
 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_bios_timeofday">_bios_timeofday</a></h2><dl> 


<dt><b>Header</b></dt> <dd>bios.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _bios_timeofday(unsigned mode, long *btime);
</tt></dd>

<dt><b>Description</b></dt> <dd>	_bios_timeofday provides an interface to the IBM BIOS time of day functions,
	interrupt 0x1A (26).
	<i>mode</i> determines whether the time is to be read or set:
	<p>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<th><i>mode</i>
	<th>Value
	<th>Meaning 
	<tr>
	<td>_TIME_GETCLOCK 	<td>0 		<td>Retrieve time 
	<tr>
	<td>_TIME_SETCLOCK 	<td>1 		<td>Set time
	</table>
<br><br>

If the time is to be read, the current BIOS time (in clock ticks since midnight) is placed in the long integer pointed to by btime.  Otherwise, the BIOS time of day counter is set to the value of that 
long. There are approximately 18. 2 clock ticks per second.
</dd>

<dt><b>Return Value</b></dt> <dd>If mode is 0, the function returns 1 if the system clock has passed midnight since the last time it was read. Otherwise, it returns 0. If mode is 1, no meaningful value is returned.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#biostime">biostime</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _bios_timeofday 	*/ 

#include &lt;bios.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib. h&gt

void main() 
{   
   unsigned hours, minutes; 
   long btime; 

   _bios_timeofday (0,&amp; btime);

   btime = (btime* 10)/ 182; 
   minutes = (unsigned) btime / 60; 
   hours = minutes / 60; 
   minutes %= 60; 

   printf("The time is %2d:%2d\n", 
	     hours, minutes); 
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">The time is 15:34</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_int86">_int86, int86_real, int86</a></h2><dl>

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _int86(int intnum, union _REGS *regsin, union REGS *regsout); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
int int86_real(int intnum, union _REGS *regsin, union REGS *regsout); 
The _int86 functions perform a software interrupt, where intnum 
is the interrupt number (0.. 255), regsin is a pointer to a structure 
containing the values of the registers AX, BX, CX, DX, SI and DI to 
be passed to the interrupt, and regsout is a pointer to a structure 
into which the return values of the registers will be written.<br><br>

The _REGS structure is defined in dos. h. Consult your system 
hardware and software manuals to determine what the interrupt 
numbers are and what they do on your machine.<br><br>

In the 32-bit memory models, the functions _bdos, bdos, bdosx, 
_int86, int86, _int86x, int86x, _intdos, intdos, 
_intdosx, and intdosx filter parameters sent to the real mode 
interrupt. For example, if DOS function 40h (write) is detected, the 
source buffer is copied to a buffer in conventional memory (dos-buffer) 
and a pointer to dos-buffer is passed to DOS, since DOS 
could not properly use the buffer located in extended memory. If 
the information passed is larger than dos-buffer, there are multiple 
calls to DOS to transfer all information, which may be much larger 
than 64k. Where pointers are passed to these functions, they are 
assumed to contain protected mode addresses. The filtering routine 
used for these functions assumes that all far pointers passed in 
registers to DOS have a segment address of DGROUP. If you use 
int86x to execute INT 21h and specify selectors other than 
DGROUP, the results will be unpredictable. It is possible to bypass 
this filtering by using the function int_86real instead of int86. 
This function bypasses all protected mode filtering in both the Phar 
Lap and DOSX extenders and executes the interrupt in real mode. It 
can be used to retrieve real mode segment values from the BIOS or 
from DOS if desired. Under the X memory model, not all DOS calls 
are supported in the filtering process. DOS calls (listed in hex) that 
are completely supported include:<br><br>

0..9, b, d, e, 19, 2a..2e, 30, 33, 36, 39..43, 45..47, 4c..4f, 54..58, 5b..5c, 63, 66..68<br><br>

Partial support is provided for:<br><br>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr> <td>0c <td>AL = 0AH not supported 
	<tr> <td>1a <td>DTA set to a location in conventional memory 
	<tr> <td>2f <td>Get DTA returns protected mode address of DTA in conventional memory 
	<tr> <td>44 <td>Subfunctions 2, 3, 4, 5, c, and d are not supported 
	<tr> <td>59 <td>Information at ES: DI not available 
	<tr> <td>5a <td>Information at ds: dx is not available 
	<tr> <td>62 <td>returns protected mode selector, not real mode segment 
	</table>

<br>

Functions not supported:<br><br>

0a, 0f..17, 1b..1c, 21..29, 31, 35, 38, 48..4b, 5e..5f, 65 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  int86
</dd>

<dt><b>Return Value</b></dt> <dd>The _int86 function returns the value in the AX register at the 
completion of the interrupt. The state of the carry flag can be 
determined from x. cflag in regsout. Do not use _int86 for 
interrupts 0x25 or 0x26. Use dos_abs_disk_read / write for 
those. 
</dd>

<dt><b>Compatibility</b></dt> <dd>_int86: DOS Windows 3. x Phar Lap/ DOSX 
int86_real: DOS Windows 3. x Phar Lap/ DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_int86x">_int86x</a><br>
<a href="#_int86x">int86x_real</a><br>
<a href="#_intdos">_intdos</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _int86 */ 

#include &lt;dos.h&gt; 
#include &lt;stdio.h&gt;

void main () 
{   
   union _REGS inregs, outregs; 
   unsigned char last_flags, new_flags; 
   int n; 
   char *description[] = 
   {   
      "right shift", 
      "left shift", 
      "control", 
      "alt", 
      "scroll lock", 
      "num lock", 
      "caps lock", 
      "insert" 
   }; 
   printf("Press keyboard toggles and shift 
	     keys\n"); 
   printf("Press ctrl-break to quit\n"); 
   for (;;) 
   {   
      inregs. h. ah = 2; /* get keyboard flags */ 
	     _int86 (0x16, &inregs, &outregs); 
      new_flags = outregs. h. al ^ last_flags; 
      if (new_flags) 
	 for (n = 0; n &lt; 8; n += 1) 
	     if (new_flags &amp; (1 &lt;&lt; n)) 
		 printf("% s %s\n", description[n], 
		    outregs. h. al &amp; (1 &lt;&lt; n)? "on": 
				      "off"); 
      last_flags = outregs. h. al; 
   } 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Press keyboard toggles and shift keys
Press ctrl-break to quit
alt on
left shift on
left shift off
alt off
insert on
right shift on
alt on
control on
right shift off
control off
alt off
num lock off
num lock on
control on
^C
</pre>
</dd>
 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_int86x">_int86x, int86x_real, int86x</a></h2><dl>

<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _int86x(int intnum, union _REGS *regsin, union _REGS *regsout, struct _SREGS *segregs);<br><br>

int int86x_real(int intnum, union _REGS *regsin, union _REGS *regsout, struct _SREGS *segregs); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _int86x and int86x_real functions perform a software 
interrupt, where intnum is the interrupt number (0 through 255). 
regsin is a pointer to a structure containing the values of the 
registers AX, BX, CX, DX, SI and DI to be passed to the interrupt. 
segregs is a pointer to a structure containing the values of the 
segment registers to be passed to the interrupt. These functions also 
are used to return the values in the segment registers after the 
interrupt has completed. regsout is a pointer to a structure into 
which the return values of the registers will be written. The _REGS, 
and _SREGS structures are defined in dos. h. Consult your system 
hardware and software manuals to determine what the interrupt 
numbers are and what they do on your machine.<br><br>

The int86x_real function is used with the 32-bit models. For a 
further explanation of performing interrupts in the 32-bit model, see 
_int86, int86_real. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  int86x
</dd>

<dt><b>Return Value</b></dt> <dd>The _int86x and int86x functions return the value in the AX 
register at the completion of the interrupt. The state of the carry flag can be determined from x. cflag in regsout. Do not use _int86x 
for interrupts 0x25 or 0x26. For _int86x, if an error occurs, the 
cflag field in regsout is non-zero and _doserrno is set to the 
corresponding error code. 
</dd>

<dt><b>Compatibility</b></dt> <dd>_int86x: DOS Windows 3.x Phar Lap/ DOSX<br>
int86x_real: DOS Windows 3.x Phar Lap/ DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_int86">_int86</a><br>
<a href="#_int86">int86_real</a><br>
<a href="#_intdos">_intdos</a><br>
<a href="#_intdosx">_intdosx</a>
</dd>

<dt><b>Example</b></dt> <dd>See _int86 
</dd>

 </dl>

<br><br><br><br>

</td></table>




<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

