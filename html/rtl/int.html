
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - int.h
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:14 2006
</div>
</div>

<!-- Generated by Ddoc from int.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>int.h</h1>

<ul>
	<li><a href="#int_gen"><b>int_gen</b></a>
	<li><a href="#int_getvector"><b>int_getvector</b></a>
	<li><a href="#int_intercept"><b>int_intercept</b></a>
	<li><a href="#int_on"><b>int_off</b></a>
	<li><a href="#int_on"><b>int_on</b></a>
	<li><a href="#int_prev"><b>int_prev</b></a>
	<li><a href="#int_restore"><b>int_restore</b></a>
	<li><a href="#int_setvector"><b>int_setvector</b></a>
</ul>

<!-- =========================================== -->

<hr> <h2><a name="int_gen">int_gen</a></h2><dl> 

<dt><b>Header</b></dt> <dd>int.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void int_gen(int intno); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The int_gen function generates a standard Intel 80x86 interrupt, 
where intno is the interrupt to generate. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="RTL.html"></a>The other int_functions
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for int_gen */ 

#include &lt;int.h&gt;
#include &lt;stdlib.h&gt;

void main () 
{
   int_gen (5); /* print-screen interrupt */ 
} 
</pre></dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="int_getvector">int_getvector</a></h2><dl> 

<dt><b>Header</b></dt> <dd>int.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void int_getvector(unsigned vector, unsigned *poffset, unsigned *psegment); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The int_getvector function gets the contents of the specified 
interrupt vector, splits it into its segment and offset components, and 
stores each in the unsigned integers pointed to by poffset and 
psegment. 
</dd>

<dt><b>Return Value</b></dt> <dd>None 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="RTL.html"></a>The other int_functions
</dd>

 </dl>



<!-- =========================================== -->

<hr> <h2><a name="int_intercept">int_intercept</a></h2><dl> 

<dt><b>Header</b></dt> <dd>int.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int int_intercept(unsigned vector, int(* funcptr) (struct INT_DATA *pd), unsigned stacksize); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The int_intercept function links a standard C function to an 
interrupt vector that handles interrupts when they occur. The 
funcptr is a pointer to the C function that will handle the interrupt. 
This function must be declared as having C linkage. The vector 
argument defines which interrupt vector the function will be 
attached to (0 through 255). The stacksize argument is the 
number of bytes of memory allocated for the stack within the 
interrupt handler. stacksize should be a minimum of 256 bytes, 
except that if stacksize is 0, no stack is allocated, and the 
program stack is used. This is essential for interrupt routines that are 
required to be re-entrant, such as serial handlers.<br><br>

If a zero value is returned from the interrupt handler (* funcptr)(), 
then the previous interrupt vector for this vector is called. Otherwise, a return from the interrupt is performed. Values in registers can be read/ written through the pointer pd, which points to the INT_DATA struct that is passed to (* funcptr)().<br><br>

Follow these rules when handling interrupts in C++.<br><br>

1. Do not use DOS or BIOS calls during interrupt handling 
if the possibility exists that an interrupt can occur when 
DOS or BIOS is executing. This is because DOS and 
BIOS are not re-entrant. Beware of functions like new 
and malloc, which use DOS calls internally.<br>
2. Do not let the interrupt handler, or any function called 
by it, use more than the allocated stack space. If the 
handler is intended to be re-entrant, use a stacksize of 
zero to int_intercept so that a local stack is not 
created and the normal program stack is used instead.<br>
3. Do not call any function that is not re-entrant. For 
example be careful in your use of global variables; 
unpredictable results can occur.<br>
4. Do not perform I/ O from within the interrupt handler. 
This is especially true for high level file I/ O.<br> 
5. When using variables set by interrupt handlers, declare 
the variables to be volatile.<br>
6. Turn off stack overflow checking for the handler.<br><br>

Note<br>
Intercepting interrupts is an advanced technique 
and requires a good understanding of DOS and the 
IBM family of PCs to use it successfully. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns zero if successful. Otherwise, -1 is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>The other int_functions
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for int_intercept */ 

#include &lt;int.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static volatile int ctrl_c_count = 0; 

int do_ctrl_c (struct INT_DATA *pd) 
{   
   ++ ctrl_c_count; 
   return 1; 
} 

void main () 
{   
   int_intercept (0x23, do_ctrl_c, 256); 
   while (ctrl_c_count &lt; 3) 
      printf (" Number of ctrl-C's is %d\n", 
		ctrl_c_count); 
   int_restore (0x23); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Number of ctrl-C's is 0
Number of ctrl-C's is 0
Number of ctrl-C's is 0
Number of ctrl-C's is 0
Number of ctrl-C's is 0
Number of ctrl-C's is 0
Number of ctrl-C's is 0
Number of ctrl-C's is ^C
0
Number of ctrl-C's is 0
Number of ctrl-C's is 0
Number of ctrl-C's is 0
Number of ctrl-C's is 1
Number of ctrl-C's is 1
Number of ctrl-C's is 1
Number of ctrl-C's is 1
Number of ctrl-C's is 1
Number of ctrl-C's ^C
is 1
Number of ctrl-C's is 1
Number of ctrl-C's is 1
Number of ctrl-C's is 1
Number of ctrl-C's is 1
Number of ctrl-C's is 1
Number of ctrl-C's is 2
Number of ctrl-C's is 2
Number of ctrl-C's is 2
Number of ctrl^ C
-C's is 2
Number of ctrl-C's is 2
Number of ctrl-C's is 2
Number of ctrl-C's is 2
Number of ctrl-C's is 2
</pre>
</dd>

 </dl>



<!-- =========================================== -->

<hr> <h2><a name="int_on">int_on</a></h2><dl> 

<dt><b>Header</b></dt> <dd>int.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void int_off(void); void int_on(on); 
</tt></dd>

<dt><b>Description</b></dt> <dd>These functions turn on or off the interrupts. The int_on function 
does it via an STI (set interrupt flat) instruction; the int_off function 
does it via a CLI (clear interrupt flag) instruction. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>The other int_functions
</dd>

 </dl>





<!-- =========================================== -->

<hr> <h2><a name="int_prev">int_prev</a></h2><dl> 

<dt><b>Header</b></dt> <dd>int.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>long int_prev(struct INT_DATA *idp); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The int_prev function calls the standard interrupt handler from 
within a user-handler that was installed using int_intercept. The 
parameter *ipd passes register values into the routine. On exit, it 
contains the register values at the end of the standard interrupt 
handler. 
</dd>

<dt><b>Return Value</b></dt> <dd>A long containing the values in the DX and AX registers at the end of 
the called routine. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>The other int_functions
</dd>
 </dl>




<!-- =========================================== -->

<hr> <h2><a name="int_restore">int_restore</a></h2><dl> 

<dt><b>Header</b></dt> <dd>int.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void int_restore(unsigned vector);  
</tt></dd>

<dt><b>Description</b></dt> <dd>The int_restore function unlinks the first interrupt handler that 
was hooked into the specified vector via int_intercept. This 
function must not be called unless an interrupt handler was linked to 
the vector using int_intercept. int_restore is the 
complement to the int_intercept function. 
</dd>

<dt><b>Return Value</b></dt> <dd>If successful, a zero is returned. Otherwise, -1 is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#int_intercept">int_intercept</a><br>
</dd>

<dt><b>Example</b></dt> <dd>See int_intercept
</dd>
 </dl>




<!-- =========================================== -->

<hr> <h2><a name="int_setvector">int_setvector</a></h2><dl> 

<dt><b>Header</b></dt> <dd>int.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void int_setvector(unsigned vector, unsigned offset, unsigned segment); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The int_setvector installs the address of a user routine supplied 
in offset and segment in the specified interrupt vector. The 
routine where you set the interrupt vector must be marked as 
__interupt. For example if you want your C function to be a 
Ctrl_C vector, declare the function as:

<pre class="ccode">void __interupt __far __cdecl func
</pre>

If the routine is written in assembly, save and restore all registers and return via an IRET instruction. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>The other int_functions
</dd>
 </dl>




<br><br><br><br>

</td></table>





<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

