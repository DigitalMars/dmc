
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - dos.h part 1
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:14 2006
</div>
</div>

<!-- Generated by Ddoc from dos.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>dos.h part 1</h1>

These are interfaces to the DOS operating system. They generally
correspond directly to DOS API calls. They are not portable to operating
systems other than DOS.

<dl><dl>
	<dt><a href="#absread"><b>absread</b></a>
	<dt><a href="#abswrite"><b>abswrite</b></a>
	<dt><a href="#dos_abs_disk_read"><b>dos_abs_disk_read</b></a>
	<dt><a href="#dos_abs_disk_write"><b>dos_abs_disk_write</b></a>
	<dt><a href="#dos_alloc"><b>dos_alloc</b></a>
	<dt><a href="#_dos_allocmem"><b>_dos_allocmem</b></a>
	<dt><a href="#dos_calloc"><b>dos_calloc</b></a>
	<dt><a href="#_dos_close"><b>_dos_close</b></a>
	<dt><a href="#_dos_commit"><b>_dos_commit</b></a>
	<dt><a href="#dos_creat"><b>dos_creat</b></a>
	<dt><a href="#_dos_creat"><b>_dos_creat</b></a>
	<dt><a href="#_dos_creatnew"><b>_dos_creatnew</b></a>
	<dt><a href="#_doserrno"><b>_doserrno</b></a>
	<dt><a href="#_dosexterr"><b>_dosexterr</b></a>
	<dt><a href="#_dos_findfirst"><b>_dos_findfirst</b></a>
	<dt><a href="#_dos_findnext"><b>_dos_findnext</b></a>
	<dt><a href="#dos_free"><b>dos_free</b></a>
	<dt><a href="#_dos_freemem"><b>_dos_freemem</b></a>
	<dt><a href="#dos_get_ctrl_break"><b>dos_get_ctrl_break</b></a>
	<dt><a href="#dos_get_verify"><b>dos_get_verify</b></a>
	<dt><a href="#_dos_getdate"><b>_dos_getdate</b></a>
	<dt><a href="#_dos_getdiskfree"><b>_dos_getdiskfree, _getdiskfree</b></a>
	<dt><a href="#dos_getdiskfreespace"><b>dos_getdiskfreespace</b></a>
	<dt><a href="#_dos_getdrive"><b>_dos_getdrive</b></a>
	<dt><a href="#_dos_getfileattr"><b>_dos_getfileattr</b></a>
	<dt><a href="#_dos_getftime"><b>_dos_getftime</b></a>
	<dt><a href="#_dos_gettime"><b>_dos_gettime</b></a>
	<dt><a href="#_dos_getvect"><b>_dos_getvect</b></a>
	<dt><a href="#_dos_keep"><b>_dos_keep</b></a>
	<dt><a href="#_dos_lock"><b>_dos_lock</b></a>
	<dt><a href="#_dos_open"><b>_dos_open</b></a>
	<dt><a href="#dos_open"><b>dos_open</b></a>
	<dt><a href="#_dos_read"><b>_dos_read</b></a>
	<dt><a href="#_dos_seek"><b>_dos_seek</b></a>
	<dt><a href="#_dos_setblock"><b>_dos_setblock</b></a>
	<dt><a href="#dos_setblock"><b>dos_setblock</b></a>
	<dt><a href="#dos_set_ctrl_break"><b>dos_set_ctrl_break</b></a>
	<dt><a href="#_dos_setdate"><b>_dos_setdate</b></a>
	<dt><a href="#_dos_setdrive"><b>_dos_setdrive</b></a>
	<dt><a href="#_dos_setfileattr"><b>_dos_setfileattr</b></a>
	<dt><a href="#_dos_setftime"><b>_dos_setftime</b></a>
	<dt><a href="#_dos_settime"><b>_dos_settime</b></a>
	<dt><a href="#_dos_setvect"><b>_dos_setvect</b></a>
	<dt><a href="#dos_set_verify"><b>dos_set_verify</b></a>
	<dt><a href="#_dos_write"><b>_dos_write</b></a>
</dl></dl>

These interface to services provided by the 32 bit DOS extenders.

<dl><dl>
	<dt><a href="#_x386_coreleft"><b>_x386_coreleft</b></a>
	<dt><a href="#_x386_free_protected_ptr"><b>_x386_free_protected_ptr</b></a>
	<dt><a href="#_x386_get_abs_address"><b>_x386_get_abs_address</b></a>
	<dt><a href="#_x386_map_physical_address"><b>_x386_map_physical_address</b></a>
	<dt><a href="#_x386_memlock"><b>_x386_memlock</b></a>
	<dt><a href="#_x386_memunlock"><b>_x386_memunlock</b></a>
	<dt><a href="#_x386_mk_protected_ptr"><b>_x386_mk_protected_ptr</b></a>
</dl></dl>

<!-- =================================================== -->

<hr> <h2><a name="absread">absread</a></h2><dl> 

<dt><b>Header</b></dt> <dd>	dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>	int <b>absread</b>(int drive, int nsects, long lsect, char *buffer);
</tt></dd>

<dt><b>Description</b></dt> <dd>	Reads specific disk sectors from a drive.
	<i>drive</i> is the drive to read from.
	<i>nsects</i> is the number of sectors to read; this can be a 
	maximum of either 64K or the buffer size, whichever is smaller.
	<i>lsect</i> defines the beginning logical sector number.
	<i>buffer</i> indicates where the data should be placed.
	<p>

	This function is exactly the same as
	<a href="#dos_abs_disk_read">dos_abs_disk_read</a>.
</dd>

<dt><b>Return Value</b></dt> <dd>	0 if successful, otherwise the DOS error code. 
</dd>

<dt><b>Compatibility</b></dt> <dd>	DOS, Windows 3.x, Phar Lap, DOSX
</dd>

<dt><b>See Also</b></dt> <dd>	<a href="#abswrite">abswrite</a><br>
	<a href="#dos_abs_disk_read">dos_abs_disk_read</a>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="abswrite">abswrite</a></h2><dl> 


<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int <b>abswrite</b>(int drive, int nsects, long lsect, const char *buffer);  
</tt></dd>

<dt><b>Description</b></dt> <dd><tt>abswrite</tt> writes to the drive specified by <i>drive</i>.
<i>nsects</i> defines the number of sectors to 
write; this must be either 64K or the size of the buffer, whichever is 
smaller. <i>buffer</i> specifies the address in memory 
where the data will be written from.
<p>

This function is exactly the same as <tt>dos_abs_disk_write</tt>. 
</dd>

<dt><b>Return Value</b></dt> <dd>0 if successful, otherwise the DOS error code. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS, Windows 3.x, Phar Lap, DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#absread">absread</a><br>
<a href="#dos_abs_disk_write">dos_abs_disk_write</a>
</dd>

<dt><b>Example</b></dt> <dd>See dos_abs_disk_write 
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="dos_abs_disk_read">dos_abs_disk_read</a></h2><dl> 

<dt><b>Header</b></dt> <dd>	dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int <b>dos_abs_disk_read</b>(int drive, int num_sec, long start_sec, char *buffer);
</tt></dd>

<dt><b>Description</b></dt> <dd>Transfers control directly to BIOS to perform disk read. Use 0 to 
specify drive A, 1 for B, and so on to 25. The number of sectors to 
read is num_sec. start_sec defines the first sector for operation. 
Argument buffer is the operation's destination memory address. 
The buffer must be large enough to hold the requested sectors. 
</dd>

<dt><b>Return Value</b></dt> <dd><dl>
<dt>
Returns a 0 on success. Non-zero indicates an error; the lower byte 
contains the DOS error code; the higher byte contains the specific 
BIOS error. The BIOS error codes are: 

<dd>0x01 Bad command 
<dd>0x02 Bad address mark 
<dd>0x03 Write protect error 
<dd>0x04 Sector not found 
<dd>0x08 DMA (direct memory access) failure 
<dd>0x10 Data error (bad CRC) 
<dd>0x20 Controller failure 
<dd>0x40 Seek operation failed 
<dd>0x80 Device failed to respond 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#dos_abs_disk_write">dos_abs_disk_write</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* Example for dos_abs_disk_read
   Also demonstrates absread (which is just like it), atoi, toupper,
   and isprint 

   DISKDUMP.C 

   Reads logical sector 1 from drive A and prints a hex and
   ascii dump of it. 
*/

#include &lt;stdio.h&gt; 
#include &lt;dos.h&gt;
#include &lt;ctype.h&gt; 
#include &lt;stdlib.h&gt;

static unsigned char buffer[512]; 

void main(int argc, const char *const argv[])
{ 
   int i, drive, sector;
   unsigned char *p; 
   unsigned code; 

   if (argc &lt; 3) 
      goto usage_error; 
   drive = toupper(*argv[1]) - 'A';
   if (drive &lt; 0 || drive &gt; 25) 
      goto usage_error;
   sector = atoi(argv[2]); 
   code = dos_abs_disk_read(drive, 1, sector, (char *)buffer); 
   if (code != 0)
   { 
	fprintf(stderr, "Error, dos code %02x, bios code %02x\n",
		code &amp; 0xff, code &gt;&gt; 8); 
	exit(EXIT_FAILURE);
   } 
   printf("Drive %c, logical sector %d:\n",
	     drive + 'A', sector); 
   for (p = buffer; p &lt; buffer + sizeof buffer; p += 16) 
   {
      for (i = 0; i &lt; 16; i += 1) 
         printf("%02x ", p[i]);
      printf(" "); 
      for (i = 0; i &lt; 16; i += 1)
         if (isprint(p[i])) 
            printf("%c", p[i]); 
         else 
            printf(".");
      printf("\n"); 
   } 
   exit(EXIT_SUCCESS); 

usage_error:
   fprintf(stderr, "Usage: DISKDUMP drive-letter sector-number\n");
   exit(EXIT_FAILURE); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Drive C, logical sector 0:
 
eb 3c 90 4d 53 44 4f 53 35 2e 30 00 02 10 01 00 .&lt;. MSDOS5.0..... 
02 00 02 00 00 f8 00 01 20 00 40 00 20 00 00 00 ........ .@. ... 
e0 f7 0f 00 80 00 29 c7 5e 63 1c 4d 53 2d 44 4f .......^ c. MS-DO 
53 5f 36 20 20 20 46 41 54 31 36 20 20 20 fa 33 S_6 FAT16 .3 
c0 8e d0 bc 00 7c 16 07 bb 78 00 36 c5 37 1e 56 .....|... x. 6.7. V 
16 53 bf 3e 7c b9 0b 00 fc f3 a4 06 1f c6 45 fe .S.&gt;|......... E. 
0f 8b 0e 18 7c 88 4d f9 89 47 02 c7 07 3e 7c fb ....|. M.. G...&gt;|. 
cd 13 72 79 33 c0 39 06 13 7c 74 08 8b 0e 13 7c .. ry3.9..| t....| 
89 0e 20 7c a0 10 7c f7 26 16 7c 03 06 1c 7c 13 .. |..|.&amp;.|...|. 
16 1e 7c 03 06 0e 7c 83 d2 00 a3 50 7c 89 16 52 ..|...|.... P|.. R 
7c a3 49 7c 89 16 4b 7c b8 20 00 f7 26 11 7c 8b |. I|.. K|. ..&amp;.|. 
1e 0b 7c 03 c3 48 f7 f3 01 06 49 7c 83 16 4b 7c ..|.. H.... I|.. K| 
00 bb 00 05 8b 16 52 7c a1 50 7c e8 92 00 72 1d ...... R|. P|... r. 
b0 01 e8 ac 00 72 16 8b fb b9 0b 00 be e6 7d f3 ..... r........}. 
a6 75 0a 8d 7f 20 b9 0b 00 f3 a6 74 18 be 9e 7d .u... ..... t...} 
e8 5f 00 33 c0 cd 16 5e 1f 8f 04 8f 44 02 cd 19 ._. 3...^.... D... 
58 58 58 eb e8 8b 47 1a 48 48 8a 1e 0d 7c 32 ff XXX... G. HH...| 2. 
f7 e3 03 06 49 7c 13 16 4b 7c bb 00 07 b9 03 00 .... I|.. K|...... 
50 52 51 e8 3a 00 72 d8 b0 01 e8 54 00 59 5a 58 PRQ.:. r.... T. YZX 
72 bb 05 01 00 83 d2 00 03 1e 0b 7c e2 e2 8a 2e r..........|.... 
15 7c 8a 16 24 7c 8b 1e 49 7c a1 4b 7c ea 00 00 .|..$|.. I|. K|... 
70 00 ac 0a c0 74 29 b4 0e bb 07 00 cd 10 eb f2 p.... t)......... 
3b 16 18 7c 73 19 f7 36 18 7c fe c2 88 16 4f 7c ;..| s.. 6.|.... O| 
33 d2 f7 36 1a 7c 88 16 25 7c a3 4d 7c f8 c3 f9 3.. 6.|..%|. M|... 
c3 b4 02 8b 16 4d 7c b1 06 d2 e6 0a 36 4f 7c 8b ..... M|..... 6O|. 
ca 86 e9 8a 16 24 7c 8a 36 25 7c cd 13 c3 0d 0a .....$|. 6%|..... 
4e 6f 6e 2d 53 79 73 74 65 6d 20 64 69 73 6b 20 Non-System disk 
6f 72 20 64 69 73 6b 20 65 72 72 6f 72 0d 0a 52 or disk error.. R 
65 70 6c 61 63 65 20 61 6e 64 20 70 72 65 73 73 eplace and press 
20 61 6e 79 20 6b 65 79 20 77 68 65 6e 20 72 65 any key when re 
61 64 79 0d 0a 00 49 4f 20 20 20 20 20 20 53 59 ady... IO SY 
53 4d 53 44 4f 53 20 20 20 53 59 53 00 00 55 aa SMSDOS SYS.. U. 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="dos_abs_disk_write">dos_abs_disk_write</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int dos_abs_disk_write( int drive, int num_sec, long start_sec, const char *buffer): <br><br>
</tt></dd>

<dt><b>Description</b></dt> <dd>The dos_abs_disk_write function transfers control directly to 
BIOS to perform the disk write. The drive should contain a 0 for A, 
a 1 for B, and so on, up to 25. The number of sectors to write is 
specified in num_sec. start_sec defines the first sector for 
operation. Buffer is the source memory address for the operation.
<p>

Writing to a disk using this function could cause irretrievable loss of 
data, and may damage the file structure of the disk. For this reason 
no example is given. Use this function if you are fully conversant 
with the organization of MS-DOS disks and their file structures. 
</dd>

<dt><b>Return Value</b></dt> <dd>See dos_abs_disk_read 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Win32
</dd>

<dt><b>See Also</b></dt> <dd><a href="#dos_abs_disk_read">dos_abs_disk_read</a>
</dd>

<dt><b>Example</b></dt> <dd>See dos_abs_disk_read 
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="dos_alloc">dos_alloc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned dos_alloc( unsigned para); <br><br>
</tt></dd>

<dt><b>Description</b></dt> <dd>The dos_alloc function allocates memory from the heap by a 
direct call to MS-DOS. The argument para contains the number of 
paragraphs required; a paragraph contains 16 bytes. Memory 
allocated with dos_alloc should only be freed with dos_free. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns the segment of the allocated block. If unsuccessful, returns 
zero, sets _doserrno to the OS error number, and sets errno to 
the corresponding standard code. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#dos_free">dos_free</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for dos_alloc
	Also demonstrates dos_free, _MK_FP 
*/ 
#include &lt;dos.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main ()
{   
   unsigned newseg; void __far *pointer; 


   newseg = dos_alloc (20);
   if (newseg == 0) 
   {   
	perror ("dos_alloc failed"); 
	exit (EXIT_FAILURE);
   } 
   pointer = _MK_FP (newseg, 0);
   printf("Memory allocated successfully at %Fp\n", pointer);
   if (dos_free (newseg) == -1) 
   {   
	perror ("Unable to free memory\n");
	exit (EXIT_FAILURE);
   } 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Memory allocated successfully at 2FF5:0000
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_allocmem">_dos_allocmem</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
errno.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_allocmem(unsigned size, unsigned *segp);
</tt></dd>

<dt><b>Description</b></dt> <dd>Allocates a DOS memory segment, 
using the DOS system call 0x48. The allocated memory block has 
the number of paragraphs specified by <i>size</i>. (There 
are 16 bytes in a paragraph.) <i>segp</i> points to the word 
that contains the segment descriptor of the allocated memory block. 
<p>

Do not use the _dos_allocmem and malloc functions in the 
same program. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if the memory is successfully allocated. If unsuccessful, -1 
DOS error code is returned and the word pointed to by <i>segp</i> is set 
to the size (in paragraphs) of the largest available block.
In addition, the global variable _doserrno is set and the
global variable errno is set to ENOMEM, for not enough memory. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS, Windows 3.x
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_freemem">_dos_freemem</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_allocmem
	Also demonstrates _dos_freemem 
*/ 
#include &lt;dos.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main() 
{   
   unsigned largest;
   int size = 64;
   unsigned segp; 

   largest = <b>_dos_allocmem</b>(size, &segp);
   if (largest != -1)
   {   
       printf("Address of segment: %p\n", segp);
       printf("Allocated memory at segment:% x\n", &segp);
       _dos_freemem( segp); 
   }
   else 
       printf("Unable to allocate memory\n");
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Address of segment: 3690
Allocated memory at segment: 17e0
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="dos_calloc">dos_calloc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned dos_calloc( unsigned para); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The dos_calloc function allocates memory from the heap by a 
direct call to MS-DOS. If successful, the allocated memory is cleared 
(all bytes zero). The argument para contains the number of 
paragraphs required; each paragraph contains 16 bytes. Memory 
allocated with dos_calloc should only be freed by dos_free. 
</dd>

<dt><b>Return Value</b></dt> <dd>If successful, dos_calloc returns the segment of the allocated 
block, otherwise zero is returned, _doserrno is set to the OS error 
number, and errno is set to the corresponding standard error code. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#dos_alloc">dos_alloc</a> 
</dd>

<dt><b>Example</b></dt> <dd>See dos_alloc 
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_close">_dos_close</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h<br>
errno.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _dos_close( int handle); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_close function uses system call 0x3E to close the file 
indicated by the handle argument. (The handle is a descriptor 
returned by the call that created or last opened the file.) 
</dd>

<dt><b>Synonym</b></dt> <dd>dos_close
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if successful. Otherwise, _doc_close returns the DOS 
error code and sets errno to EBADF, indicating an invalid file 
handle. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_open">_dos_open</a>
</dd>

<dt><b>Example</b></dt> <dd>See _dos_open 
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_commit">_dos_commit</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h<br>
errno.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_commit( int handle); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_commit function uses system call 0x68 to flush to disk 
the DOS buffers associated with the file indicated by handle. This 
function also forces an update on the corresponding disk directory 
and file allocation table. In addition, the function ensures that the file 
is flushed directly to disk (not at the operating system's discretion.) 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if successful. Otherwise, it returns the DOS error code and 
sets errno to EBADF, indicating an invalid file handle. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_read">_dos_read</a><br>
<a href="#_dos_write">_dos_write</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_commit 	
	Also demonstrates _dos_close, _dos_creat,
	_dos_read and _dos_write 
*/ 
#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void main()
{   
   int fd;
   int result;
   unsigned count;
   char buf[32] = "Hello from Digital Mars\0" ; 
   char newbuf[50]; 
   fd = 0;
   result = _dos_creat ("temp.dat", _A_NORMAL, &fd);
   if (result != 0) 
	perror ("_dos_creat failed");
   else 
   {
	_dos_write (fd, buf, strlen (buf), &count);
	_dos_commit (fd); 
	_dos_read (fd, newbuf, 50, &count);
	_dos_close (fd); 
   }
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">This program will overwrite the contents of the file temp.dat with the 
string "Hello from Digital Mars". 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="dos_creat">dos_creat</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int dos_creat(const char *name, int attrib);
</tt></dd>

<dt><b>Description</b></dt> <dd>The <tt>dos_creat</tt> function opens a new file named <tt>name</tt> with 
attributes specified in <tt>attrib</tt>. It returns the new file's handle 
(whereas <a href=#_dos_creat><tt>_dos_creat</tt></a>
copies the new file's handle to the location 
pointed to by handle). The file is opened for read and write access. 
If the specified file exists, the file keeps its original attributes,
the size is reset to 0, and the contents of the file are lost.
If the specified file does not exist, a new file is created. 
<p>

The attribute byte is the same as described in the reference manual 
for MS-DOS. Use the following attribute values defined in dos.h:

<dl>
<dt>_A_NORMAL <dd>0x00 Normal File
<dt>_A_RDONLY <dd>0x01 Read Only
<dt>_A_HIDDEN <dd>0x02 Hidden file
<dt>_A_SYSTEM <dd>0x04 System file
<dt>_A_ARCH   <dd>0x20 Archive bit 
</dl>
</dd>

<dt><b>Synonym</b></dt> <dd>Attribute values: FA_NORMAL, FA_RDONLY, FA_HIDDEN, FA_SYSTEM, FA_ARCH 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns a DOS handle if the file is successfully created. If 
unsuccessful, it returns -1, and <tt>errno</tt> is set to the corresponding 
error code, and <a href=#_doserrno><tt>_doserrno</tt></a>
is set to the OS error number. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_creat">_dos_creat</a><br>
<a href="#_dos_creatnew">_dos_creatnew</a><br>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_creat">_dos_creat</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h<br>
errno.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _dos_creat( const char *name, unsigned attrib, int *handle); 
</tt></dd>

<dt><b>Description</b></dt> <dd>This function opens a new file named name with attributes specified 
in attrib. The _dos_creat function copies the new file's handle 
to the location pointed to by handle. The file is opened for read 
and write access. <br><br>

If the specified file exists, the file keeps its original attributes, the size is reset to 0, and the contents of the file are lost. If the specified file does not exist, a new file is created. <br><br>

The attribute byte is the same as described in the reference manual 
for MS-DOS. Use the following attribute values defined in dos.h: <br><br>

_A_NORMAL 0x00 Normal File<br>
_A_RDONLY 0x01 Read Only<br> 
_A_HIDDEN 0x02 Hidden file<br> 
_A_SYSTEM 0x04 System file<br> 
_A_ARCH 0x20 Archive bit 
</dd>

<dt><b>Return Value</b></dt> <dd>0 if successful. Otherwise returns the DOS error code and errno is 
set to one of the following values:<br><br>
<dl>
<dt>EACCES 
<dd>Access denied because the directory is full 
<dt>EMFILE 
<dd>Too many open file handles 
<dt>ENOENT 
<dd>Path or file not found 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_creatnew">_dos_creatnew</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">
/* 	Example for _dos_creat
	Also demonstrates _dos_close 
*/ 
#include &lt;dos.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{   
   int handle;
   int result; 

   result = _dos_creat ("temp.dat", _A_NORMAL,
			   &handle); 
   if (result != 0)
      perror ("_dos_creat failed"); 
   else
   {   
   printf("File successfully created\n");
   _dos_close( handle); 
   } 


} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">File successfully created 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_creatnew">_dos_creatnew</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_creatnew( const char *path, unsigned attrib, int *handle); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_creatnew function creates a file using the 0x5B system 
call. This function opens a new file named name with attributes 
specified in attrib. The new file's handle is copied into the 
location pointed to by handle. The file is opened for both read and 
write access. If the file already exists, _dos_creatnew fails. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if successful. Otherwise, the DOS error code is returned 
and errno is set to one of the following values:<br><br>
<dl>
<dt>EACCES 
<dd>Access denied because the directory is full
<dt>EEXIST 
<dd>File already exists
<dt>EMFILE 
<dd>Too many open file handles
<dt>ENOENT 
<dd>Path or file not found 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_creat">_dos_creat</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_creatnew
	Also demonstrates _dos_close 
*/ 
#include &lt;dos.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{   
   int handle;
   int result; 

   result = _dos_creatnew ("temp.dat", _A_NORMAL, &handle); 

   if (result != 0)
	perror ("_dos_creatnew failed"); 
   else
   {
	printf("File created\n");
	_dos_close(handle); 
   } 
} 	
</pre>
</dd>

<dt><b>Output</b></dt> <dd>If the file temp.dat does not exist: 
<pre class="console">File created 
</pre>
If the file temp.dat exists: 
<pre class="console">_dos_creatnew failed: File exists 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_doserrno">_doserrno</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern int _doserrno; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable contains the operating system error code for the last 
error that occurred. For DOS, Windows 3.x, and Phar Lap, the error 
code is a DOS error code; for Win32 it is a Win32 error code. 
<p>

When errno is set, _doserrno is also set. If the error did not 
originate from an operating system call, _doserrno is undefined. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="stdlib.html#errno">errno</a><br>
<a href="string.html#_sys_errlist">_sys_errlist</a><br>
<a href="string.html#_sys_nerr.html">_sys_nerr</a>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dosexterr">_dosexterr</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt><tt>int <b>_dosexterr</b>(struct _DOSERROR *err);</tt>
</tt></dd>

<dt><b>Description</b></dt> <dd><tt><b>_dosexterr</b></tt> uses system call 0x59 to retrieve DOS 
error information on a failed DOS call. The returned error 
information is stored in the structure pointed to by <i>err</i>. 
The <tt><b>_dosexterr</b></tt> function returns information in a 
structure of type _DOSERROR.
<p>
	<table border=1 cellpadding=4 cellspacing=0>
	<caption>_DOSERROR struct fields</caption>
	<tr>
	<td>int exterror 
	<td>AX register contents (extended error)
	<tr>
	<td>char eclass 
	<td>BH register contents (error class)
	<tr>
	<td>char action 
	<td>BL register contents (action)
	<tr>
	<td>char locus 
	<td>CH register contents (error locus)
	</table>

<p> 

If <i>err</i> is NULL, <tt><b>_dosexterr</b></tt> will return 
immediately with the extended error number.
<tt><b>_dosexterr</b></tt> is only available with MS-DOS 3.x and above. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: dos_exterr, dosexterr<br>
Structure: DOSERROR 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns the DOS extended error number, which is the exterror 
field of the _DOSERROR structure. A value of 0 means that no error 
occurred in the previous operation. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS 3.x and above, Windows 3.x, Phar Lap, DOSX, Win32
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_creat">_dos_creat</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_exterr
	Also demonstrates _dos_close, _dos_creat 
	 and _dos_creatnew 
*/ 
#include &lt;dos.h&gt;
#include &lt;io.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{   
    int handle;
    int result; 
    struct _DOSERROR p;

    /* These calls in this order should */
    /* guarantee an error occurs */ 

    result = _dos_creat("temp.dat", _A_NORMAL, &handle); 
    result = _dos_creatnew("temp.dat", _A_NORMAL, &handle); 
    if (result != 0)
    {   
	<b>_dosexterr</b>(&p);
	printf("Exterror = %d\n", p.exterror); 
	printf("Class = %d\n", p.errclass);
	printf("Action = %d\n", p.action); 
	printf("Locus = %d\n", p.locus);
	perror("Create new file error"); 
    } 
    else 
	printf("No file error"); 

    _dos_close(handle); 
    return 0;
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Exterror = 80
Class = 12
Action = 3
Locus = 2
Create new file error: File exists 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_findfirst">_dos_findfirst</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h<br>
errno.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_findfirst( const char *name, unsigned attr, struct find_t *fileinfo); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_findfirst function uses system call 0x4E to return 
information about the first instance of a file whose name and 
attributes match name and attr. The file information is returned in 
the structure pointed to by fileinfo. <br><br>

The name argument can contain wildcards. The attr argument can 
be one or more of the following attributes. To specify more than one 
value, join them with the bitwise OR operator. <br><br>
<dl>
<dt>_A_ARCH 
<dd>Archive
<dt>_A_HIDDEN 
<dd>Hidden file
<dt>_A_NORMAL 
<dd>Normal file
<dt>_A_RDONLY 
<dd>Read only
<dt>_A_SUBDIR 
<dd>Subdirectory
<dt>_A_SYSTEM 
<dd>System file
<dt>_A_VOLID 
<dd>Volume ID
</dl>
<br>

If a program specifies any combination of _A_HIDDEN, _A_SUBDIR 
or _A_SYSTEM, then _dos_findfirst returns normal files in 
addition to the specified files. The program must examine the 
attribute contained in the DTA to determine the type of file found. <br><br>

File information is returned in a find_t structure. This type, which 
is defined in the dos.h header file, has the following elements:<br>
<dl>
<dt>char reserved[21] 
<dd>Reserved for use by DOS 
<dt>char attrib
<dd>Attribute byte for matched path 
<dt>unsigned short wr_time
<dd>Time of last write to file 
<dt>unsigned short wr_date
<dd>Date of last write to file 
<dt>unsigned long size
<dd>Length of file in bytes 
<dt>char name[13]
<dd>Null-terminated name of matched file/ directory, without the path 
</dl>
<br>

The formats for the wr_time and wr_date are in DOS format and 
are not for use by other C run-time functions. The time format is: 
<br><br>
<dl>
<dt>Bits 0-4 
<dd>Number of 2-second increments (0-29)
<dt>Bits 5-10 
<dd>Minutes (0-59)
<dt>Bits 11-15 
<dd>Hours (0-23)
</dl><br>

The date format is: <br><br>
<dl>
<dt>Bits 0-4 
<dd>Day of month (1-31)
<dt>Bits 5-8 
<dd>Month (1-12)
<dt>Bits 9-15 
<dd>Year (relative to 1980)
</dl>
<br>

The primary difference between this routine and findfirst is that 
this routine allows recursion through the use of different file 
information structures for each invocation of _dos_findfirst. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if a file is found. Otherwise, returns the DOS error code 
and sets errno to ENOENT, indicating that name was not found. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_findnext">_dos_findnext</a>
</dd>

<dt><b>Example</b></dt> <dd>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_findnext">_dos_findnext</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h<br>
errno.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_findnext( struct find_t *fileinfo); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_findnext function uses system call 0x4F to return 
information about the next instance of a file whose file information 
block was returned by a previous _dos_findfirst call. Argument 
fileinfo specifies a previously returned file information block.<br><br>

File information is stored in a _find_t structure. This type is 
defined in the dos.h header file. For a description of the _find_t 
structure, see the _dos_findfirst reference page. <br><br>

The primary difference between this function and findnext is that 
it allows recursion through the use of different file information 
structures for each time the _dos_findfirst function is called. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if a file is found. Otherwise, it returns the DOS error code 
and sets errno to ENOENT, indicating that no file could be found. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_findfirst">_dos_findfirst</a>
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="dos_free">dos_free</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int dos_free( unsigned seg); 
</tt></dd>

<dt><b>Description</b></dt> <dd>Frees (releases back to the operating system) memory previously 
allocated with dos_alloc or dos_calloc. Argument seg is the 
segment address of the memory to be freed. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if the memory was sucessfully freed; if the memory could 
not be freed, the return value is -1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x
</dd>

<dt><b>See Also</b></dt> <dd><a href="#dos_alloc">dos_alloc</a>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_freemem">_dos_freemem</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h<br>
errno.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_freemem( unsigned seg); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_freemem function uses system call 0x49 to free memory 
previously allocated with _dos_allocmem. Argument seg is the 
segment address of the memory to be freed, which was returned by 
a previous call to _dos_allocmem. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if the memory was sucessfully freed. If the memory could 
not be freed, the return value is -1 and errno is set to ENOMEM. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_allocmem">_dos_allocmem</a>
</dd>

<dt><b>Example</b></dt> <dd>See _dos_allocmem 
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="dos_get_ctrl_break">dos_get_ctrl_break</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int dos_get_ctrl_break( void);
</tt></dd>

<dt><b>Description</b></dt> <dd>Returns the state of the DOS control break status. Returns a non-zero 
value if BREAK checking is on and a zero value if BREAK checking 
is off. For additional information, see the BREAK command in the 
reference manual for your MS-DOS system. 
</dd>

<dt><b>Return Value</b></dt> <dd>Return non-zero if the status is on and a zero if the status is off. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#dos_set_ctrl_break">dos_set_ctrl_break</a>
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="dos_get_verify">dos_get_verify</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int dos_get_verify( void); 
</tt></dd>
 
<dt><b>Description</b></dt> <dd>Returns the state of the DOS verify status. This function will return a 
non-zero value if VERIFY is on and a zero if the VERIFY is off. For 
additional information, see the VERIFY command in the technical 
reference manual for your DOS system. 
</dd>

<dt><b>Return Value</b></dt> <dd>Return non-zero if the status is on and a zero if the status is off. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#dos_set_verify">dos_set_verify</a>
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="_dos_getdate">_dos_getdate</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _dos_getdate( struct _dosdate_t *date); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The dos_getdate function obtains the current system date via a 
call to DOS function 0x2A and places it in the structure pointed to 
by the date argument.<br><br>
The format of the _dosdate_t structure is:<br><br>
<pre class="ccode">struct _dosdate_t
{   
   unsigned char day;    /* day of month( 1-31)*/
   unsigned char month; /* month (1-12)*/ 
   unsigned int year; /* year (1980-2099)*/
   unsigned char dayofweek; /* 0-6 (0= Sunday)*/ 
} 
</pre>
</dd>

<dt><b>Synonym</b></dt> <dd>Function: dos_getdate<br>
Type: dos_date_t 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_setdate">_dos_setdate</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_getdate and _dos_setdate
*/ 
#include &lt;dos.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main()
{   
   struct _dosdate_t date;
   unsigned int oldyear; 

   _dos_getdate (&amp; date);
   printf("Date : %2d/%2d/%d\n", date.month, 
	     date.day, date.year); 

   oldyear = date.year;
   date.year = 1990; 
   _dos_setdate (&amp; date);
   _dos_getdate (&amp; date); 

   printf("Date : %2d/%2d/%d\n", date.month,
	     date.day, date.year); 
   date.year = oldyear;
   _dos_setdate (&amp; date); 
   _dos_getdate (&amp; date); 
   printf("Date : %2d/%2d/%d\n", date.month,
   date.day, date.year); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Date : 6/22/1994
Date : 6/22/1990
Date : 6/22/1994 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_getdiskfree">_dos_getdiskfree</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h<br>
errno.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_getdiskfree( unsigned drive, struct _diskfree_t *diskspace);<br>
unsigned _getdiskfree( unsigned drive, struct _diskfree_t *diskspace); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_getdiskfree function obtains information on the disk 
drive specified by drive, using system call 0x36. The default drive 
is 0, drive A is 1, drive B is 2, and so on. Disk information is 
returned in _diskfree_t structure pointed to by diskspace.<br><br>

The format of the _diskfree_t structure is:<br>
<pre class="ccode">struct _diskfree_t
{ 
   unsigned total_clusters; /* on disk*/
   unsigned avail_clusters; /* on disk*/ 
   unsigned sectors_per_clusters;
   unsigned bytes_per_sector; 
} 
</pre>
</dd>

<dt><b>Synonym</b></dt> <dd>Type: diskfree_t 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if successful. Otherwise, returns non-zero and sets errno 
to EINVAL to indicate that an invalid drive was specified. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_setdrive">_dos_setdrive</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* Example for _dos_getdiskfree
*/ 
#include &lt;dos.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main()
{   
   unsigned ret; struct diskfree_t free; 

   ret = _dos_getdiskfree (0, &free);
   if (ret != 0) 
	perror("_dos_getdiskfree");
   else 
   {
      printf("% u avaliable clusters\n", 
	       free. avail_clusters);
      printf("out of %u clusters.\n",
	       free. total_clusters);
      printf("% u sectors per cluster,\n",
	       free. sectors_per_cluster);
      printf("% u bytes per sector.\n",
	       free. bytes_per_sector); 
   } 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">14437 avaliable clusters
out of a total of 32914 clusters.
16 sectors per cluster,
512 bytes per sector. 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="dos_getdiskfreespace">dos_getdiskfreespace</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>long dos_getdiskfreespace( int drive); 
</tt></dd>

<dt><b>Description</b></dt> <dd>Returns a long integer of available disk space. drive is an integer 
value where the default drive is 0; drive A is 1, drive B is 2, and so 
on. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns the number of free bytes on the disk. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_getdiskfree">_dos_getdiskfree</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for dos_getdiskfreespace 
	DISKFREE. C
*/ 

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt; 
#include &lt;stdlib.h&gt;

void main (int argc, char *argv[])
{   
   int drive; 

   if (argc &lt; 2)
      drive = 0; 

   else
      drive = toupper (* argv[ 1]) -'A' + 1; 
   if (drive &lt; 0 || drive &gt; 26)
   {   
      fprintf(stderr,
	     "Usage: DISKFREE [drive-letter]\ n"); 
      exit (EXIT_FAILURE);
   } 
   printf(" Free space is %ld bytes\ n",
	     dos_getdiskfreespace (drive)); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">C:\SC\EXAMPLES&gt; diskfree j
Free space is 28119040 bytes 
</pre>
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="_dos_getdrive">_dos_getdrive</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _dos_getdrive( unsigned *driveptr); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_getdrive function uses system call 0x19 to get the 
identity of the current disk drive and stores it in the unsigned integer pointed to by driveptr. The drive is reported as an integer 
number where 1 =A, 2 = B, 3 = C, and so on. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: dos_getdrive 
</dd>

<dt><b>Return Value</b></dt> <dd>None 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_setdrive">_dos_setdrive</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_getdrive */ 

#include &lt;dos.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main()
{   
   unsigned driveno; 

   _dos_getdrive (&amp; driveno);
   printf("The current drive is %c\n", 
	     driveno-1+ 'a');
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">The current drive is c 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_getfileattr">_dos_getfileattr</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h<br>
errno.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_getfileattr( const char *filepath, unsigned *att); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_getfileattr function gets the current file attributes of 
the named file and places them in the unsigned integer pointed to by 
att. The char pointer filepath references a standard DOS path 
and filename as a null terminated string. Individual file attributes can be
checked by logically ANDing them with the appropriate masks.<br><br>

File attributes are listed in the dos_setfileattr description. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: dos_getfileattr 
</dd>

<dt><b>Return Value</b></dt> <dd>0 if succesful. Otherwise returns the DOS error code. In addtion, 
_dos_getfileattr sets errno to ENOENT, indicating that the 
target file or directory was not found. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_setfileattr">_dos_setfileattr</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_getfileattr,
	   and _dos_setfileattr 
	Also demonstrates _dos_creat
*/ 
#include &lt;dos.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main()
{   
   int handle, result;
   unsigned attrib; 

   result = _dos_creat ("temp.dat", _A_RDONLY,
			 &handle); 
   if (result == 0)
   {   
	_dos_getfileattr ("temp.dat", &attrib);
	if (attrib &amp; _A_RDONLY) 
	   printf("File is read only\n");
	else 
	   printf("File is not read only\n"); 
	if (attrib &amp; _A_ARCH)
	   printf("File has archive bit set\n"); 
	else
	   printf("File does not have archive bit
		     set\n"); 

	_dos_setfileattr ("temp.dat", _A_NORMAL);
	_dos_getfileattr ("temp.dat", &attrib); 

	if (attrib &amp; _A_RDONLY)
	   printf("File is read only\n"); 
	else
	   printf("File is not read only\n"); 

	if (attrib &amp; _A_ARCH)
	   printf("File has archive bit set\n"); 
	else
	   printf("File does not have archive bit
		     set\n"); 

	_dos_close (handle);
   } 
   else
	perror ("Error creating file"); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">File is read only
File has archive bit set
File is not read only
File does not have archive bit set
</pre>
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="_dos_getftime">_dos_getftime</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h<br>
errno.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_getftime( int fd, unsigned *date, unsigned *time); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_getftime function gets the time and date of when the 
file (belonging to the file descriptor fd) was last written, and places 
these values in the unsigned integers pointed to by arguments date 
and time. The format of these arguments is:<br><br>
<dl>
<dt>date:
<dd>bits 0 to 4
<dd>Day of month (0-31)<br><br>

<dd>bits 5 to 8
<dd>Month (0-12)<br><br>

<dd>bits 9 to 15
Year (relative to 1980)<br><br>
</dl>
<br>
<dl>
<dt>time:
<dd>bits 0 to 4
<dd>Number of 2 second increments (0-29)<br><br>

<dd>bits 5 to 10<br>
<dd>Minutes (0-59)<br><br>

<dd>bits 11 to 15<br>
<dd>Hours (0-23)<br><br>
</dl>
</dd>

<dt><b>Return Value</b></dt> <dd>0 if successful. Otherwise, returns the DOS error code and set errno 
to EBADF. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS  Windows 3.x  Phar Lap  DOSX  Win32
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_setftime">_dos_setftime</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_getftime and _dos_setftime
	Also demonstrates _dos_open and _dos_close 
*/
#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;io.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{   
   int handle, result;
   int d, m, y, h, mi, s; 
   unsigned date, time, oldtime; 

   result = _dos_open ("temp.dat", _O_RDONLY,
			  &handle); 
   if (result == 0)
   {   
	_dos_getftime (handle, &date, &time); 

	d = date &amp; 0x01F; m = (date &gt;&gt; 5) &amp; 0x0F; 
	y = (( date &gt;&gt; 9) &amp; 0x7F) + 1980;
	s = (time &amp; 0x1F)* 2; 
	mi = (time &gt;&gt; 5) &amp; 0x3F;
	h = (time &gt;&gt; 11) &amp; 0x1F; 

	printf("temp.dat date = %2d/%2d/%4d\n",
		  m, d, y); 
	printf("temp.dat time = %2d:%2d:%2d\n",
		  h, mi, s); 

	oldtime = time;
	time = 6; 
	_dos_setftime (handle, date, time);
	_dos_getftime (handle, &date, &time); 

	s = (time &amp; 0x1F)* 2;
	mi = (time &gt;&gt; 5) &amp; 0x3F; 
	h = (time &gt;&gt; 11) &amp; 0x1F; 

	printf("\ntemp.dat time = 
		%2d:%2d:%2d\n\n", h, mi, s); 

	time = oldtime;
	_dos_setftime (handle, date, time); 
	_dos_getftime (handle, &date, &time); 

	d = date &amp; 0x01F;
	m = (date &gt;&gt; 5) &amp; 0x0F; 
	y = (( date &gt;&gt; 9) &amp; 0x7F) + 1980; 
	s = (time &amp; 0x1F)* 2;
	mi = (time &gt;&gt; 5) &amp; 0x3F; 
	h = (time &gt;&gt; 11) &amp; 0x1F; 

	printf("temp.dat date = %2d/%2d/%4d\n",
		  m, d, y); 
	printf("temp.dat time = %2d:%2d:%2d\n",
		  h, mi, s); 

	_dos_close( handle);
   } 
   else
	perror ("Error creating file"); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">temp.dat date = 6/27/1994
temp.dat time = 11:22:36

temp.dat time = 0:0:12

temp.dat date = 6/27/1994
temp.dat time = 11:22:36
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_gettime">_dos_gettime</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _dos_gettime( struct dos_time_t *time); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_gettime function gets the current system time via
system call 0x2C and place it in the structure pointed to by time.
The format of the time structure is: <br><br>
<pre class="ccode">struct dos_time_t
{   
   unsigned char hour; /* hours (0-23)*/ 
   unsigned char minute; /* minutes (0-59)*/ 
   unsigned char second; /* seconds (0-59) */ 
   unsigned char hsecond; /* seconds/ 100 (0-99)*/ 
} 
</pre>
</dd>

<dt><b>Synonym</b></dt> <dd>Function: dos_gettime 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_settime">_dos_settime</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_gettime, _dos_settime */ 

#include &lt;dos.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main()
{   
   struct _dostime_t time;
   char oh; 

   _dos_gettime(&amp; time); 

   printf("Time is %02d:% 02d:% 02d\n",
	     time.hour, time. minute, time. second); 

   oh = time.hour;
   time.hour = 4; 

   _dos_settime(&amp; time);
   _dos_gettime(&amp; time); 

   printf("Time is %02d:% 02d:% 02d\n",
	     time.hour, time. minute, time. second); 

   time.hour = oh;
   _dos_settime(&amp; time); 
   _dos_gettime(&amp; time); 

   printf("Time is %02d:% 02d:% 02d\n",
	     time.hour, time. minute, time. second); 
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Time is 11: 49: 21
Time is 04: 49: 21
Time is 11: 49: 21 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_getvect">_dos_getvect</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void (__cdecl __interrupt __far *_dos_getvect( unsigned intnum))(); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_getvect function gets the current value of the target 
interrupt vector specified by intnum. The function uses DOS system 
call 0x35. To replace an interrupt vector: <br><br>

<ol>
<li> Save the interrupt's current vector using _dos_getvect.<br>

<li> Set the vector to a user-defined interrupt routine using _dos_setvect.<br><br>
</ol>

If necessary, restore the saved vector by using _dos_setvect. 
</dd>

<dt><b>Return Value</b></dt> <dd>A far pointer for the target interrupt vector to the current handler, if one
exists. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_setvect">_dos_setvect</a><br>
<a href="dos2.html#_chain_intr">_chain_intr</a>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_keep">_dos_keep</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _dos_keep( unsigned retcode, unsigned memsize); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_keep function uses system call 0x31 to install a TSR 
(terminate and stay resident program). This causes the current calling 
process to exit, while keeping it resident in memory. The retcode 
is the low order byte of the exit status code. The memsize specifies 
the amount of resident memory (in 16-byte paragraphs) that 
_dos_keep allocates for the program. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="process.html#_c_exit">_c_exit, _cexit</a><br>
<a href="stdlib.html#_exit">_exit</a>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_lock">_dos_lock</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_lock( int handle, int mode, unsigned long offset, unsigned long length); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_lock function locks a region of a file preventing other 
processes from accessing that region. The handle argument must 
be a handle to an open file. Values for mode are:<br><br>
<dl>
<b>Value/Meaning</b>
<dt>0 
<dd>Locks the region
<dt>1 
<dd>Unlocks the region
</dl>
<br><br>

The beginning of the region is specified by offset. Its length is 
specified by length.<br><br>

The offset and length values of the unlocked region must be 
the exact same values of the region when it was locked. It is valid to 
lock a region that extends beyond the end of the file.<br><br>

For DOS, Windows 3.x, and Phar Lap, a DOS system call 0x5c is 
used to lock and unlock the region. For these systems, the 
SHARE. EXE program must be installed to use file sharing. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if successful, otherwise returns the operating system error 
code and sets errno. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="io.html#_locking">_locking</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_lock
	Also demonstrates _dos_open, _dos_close 

	LOCKER. C 

	Locks 10 bytes of this file starting at offset 25,
	making them inaccessable to LOCKEE. EXE. 
*/ 
#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;share.h&gt;
#include &lt;io.h&gt;

static void error (char *message)
{   
   perror (message);
   exit (EXIT_FAILURE); 
} 
void main ()
{   
   int handle; 
   if (_dos_open ("locker. c",
       _O_RDONLY|_SH_DENYNO, &handle) != 0) 
     error ("Open failed");
   if (_dos_lock (handle, 0, 25L, 10L) != 0) 
     error ("Lock failed (is SHARE running?)");
   printf("LOCKER. C locked. Run LOCKEE. EXE in 
	     another Windows DOS box now.\n"
     "Press any key when ready to unlock: "); 
   getch ();
   if (_dos_lock (handle, 1, 25L, 10L) != 0) 
     error ("Unlock failed");
   printf("\nFile unlocked. Try LOCKEE. EXE 
	   again.\n"); _dos_close (handle); 
} 


/* 	Second part of example for _dos_lock
	Also demonstrates _dos_open, _dos_seek, 
	_dos_close 
	
   LOCKEE. C 

Prints the first 100 characters of LOCKER. C. If
a character can't be accessed, a question mark 
is printed. 
*/ 
#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;share.h&gt;

static void error (char *message)
{   
   perror (message);
   exit (EXIT_FAILURE); 
}
int main () 
{
   int handle, i; 
   char c;
   unsigned actual; 

   if (_dos_open ("LOCKER. C",
       _O_RDONLY|_SH_DENYNO, &handle) != 0) 
       error ("Open failed");
   for (i = 0; i &lt; 100; i += 1) 
   {
      if (_dos_seek (handle, (unsigned long) i, 
	  0) == -1)
	  error ("Seek error"); 
      if (_dos_read (handle, &c, 1, &actual) !=
	  0) 
	  printf("?");
      else 
      {
	  if (actual == 0) 
	      break;
	  printf("% c", c); 
      } 	   
   } 
   _dos_close (handle);
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">---DOS box 1: 
C:\SC\EXAMPLES&gt; locker
LOCKER. C locked. Run LOCKEE. EXE in another 
Windows DOS box now. 
Press any key when ready to unlock: 

---DOS box 2: 

C:\SC\EXAMPLES&gt; lockee 
/* 
   Example for _dos_l?????????? so demonstrates
_dos_open, _dos_close 

LOCKER. C 

Loc 

---DOS box 1: 

C:\SC\EXAMPLES&gt; locker
LOCKER. C locked. Run LOCKEE. EXE in another 
Windows DOS box now.
Press any key when ready to unlock: 
File unlocked. Try LOCKEE. EXE again. 

---DOS box 2: 

C:\SC\EXAMPLES&gt; lockee 
/* 
   Example for _dos_lock
   Also demonstrates _dos_open, _dos_close 

   LOCKER. C 

   Loc 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_open">_dos_open</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h<br>
errno.h<br>
fcntl.h<br>
share.h<br>
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_open( const char *pathname, unsigned mode, int *handle); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_open function uses system call 0x3D to open the file 
specified by pathname, and to copy the handle into the location 
pointed to by handle. The mode argument selects the mode in 
which the file is opened. See the dos_open function.<br><br> 

Use the following access and inheritance mode values (defined in 
fcntl.h) and share mode values (defined in share.h). To specify 
more than one mode use the OR operator. You can specify only one 
access mode and one share mode at the same time.<br><br>

<b>Access Mode/Meaning<br></b><dl>
<dt>_O_RDONLY
<dd>Read-only 
<dt>_O_WRONLY
<dd>Write-only 
<dt>_O_RDWR
<dd>Both read and write 
</dl><br><br>

<b>Share Mode/Meaning<br></b><dl>
<dt>_SH_COMPAT
<dd>Compatibility
<dt>_SH_DENYRW
<dd>Deny reading and writing 
<dt>_SH_DENYWR
<dd>Deny writing 
<dt>_SH_DENYRD
<dd>Deny reading 
<dt>_SH_DENYNO
<dd>Deny neither 
</dl><br><br>

<b>Inheritance Mode/Meaning<br></b><dl>
<dt>_O_NOINHERIT
<dd>File is not inherited 
</dl>
</dd>

<dt><b>Synonym</b></dt> <dd>Modes: O_RDONLY, O_WRONLY, O_RDWR, O_NOINHERIT, 
SH_COMPAT, SH_DENYRW, SH_DENYWR, SH_DENYRD, SH_DENYNO 
</dd>

<dt><b>Return Value</b></dt> <dd>0 if successful. Otherwise, returns DOS error code; sets errno to: 
<dl>
<dt>EACESS
<dd>Access denied
<dt>EINVAL
<dd>Sharing mode specified if file sharing not installed
<dt>EMFILE
<dd>Too many open files
<dt>ENOENT
<dd>File not found
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_close">_dos_close</a><br>
<a href="#dos_open">dos_open</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_open, _dos_close */ 

#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt; 
#include &lt;io.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main()
{   
   char *fname;
   unsigned int mode; 
   int handle;
   int result; 

   mode = O_RDONLY;
   fname = "temp.dat"; 
   result = _dos_open( fname, mode, &handle); 

   if (result != 0)
      perror ("Read_only open failed"); 
   else
   {   
      printf("\nFile %s opened for reading\n",
	      fname); 
      _dos_close( handle);
   } 

   mode = O_WRONLY;
   fname = "CON"; 

   result = _dos_open( fname, mode, &handle); 

   if (result != 0)
      perror ("Error opening console"); 
   else
   {   
      printf("\nFile %s opened for writing\n",
		 fname); 
      _dos_close( handle);
   } 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">File temp.dat opened for reading
File CON opened for writing
</pre>
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="dos_open">dos_open</a></h2><dl> 

<dt><b>Header</b></dt> <dd>io.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int dos_open( const char *pathname, int mode); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The dos_open function uses system call 0x3D to open the file 
specified by pathname and returns the handle of the opened file. 
See the _dos_open function.<br><br> 

Use the following access and inheritance mode values (defined in 
fcntl.h) and share mode values (defined in share.h). To specify 
more than one mode use the OR operator. You can specify only one 
access mode and one share mode at the same time.<br><br>

<b>Access Mode/Meaning</b><dl>
<dt>_O_RDONLY
<dd>Read-only 
<dt>_O_WRONLY
<dd>Write-only 
<dt>_O_RDWR
<dd>Both read and write
</dl>
<br><br>

<b>Share Mode/Meaning</b><dl>
<dt>_SH_COMPAT
<dd>Compatibility
<dt>_SH_DENYRW
<dd>Deny reading and writing 
<dt>_SH_DENYWR
<dd>Deny writing 
<dt>_SH_DENYRD
<dd>Deny reading 
<dt>_SH_DENYNO
<dd>Deny neither
<br><br></dl>

<b>Inheritance Mode/Meaning</b><dl>
<dt>_O_NOINHERIT
<dd>File is not inherited
</dl>
</dd>

<dt><b>Synonym</b></dt> <dd>Modes: O_RDONLY, O_WRONLY, O_RDWR, O_NOINHERIT, 
SH_COMPAT, SH_DENYRW, SH_DENYWR, SH_DENYRD, SH_DENYNO 
</dd>

<dt><b>Return Value</b></dt> <dd>The file handle if successful; otherwise, if unsuccessful returns -1 
and the DOS error code, and sets errno to one of the following:<br><br>
<dl>
<dt>EACCESS
<dd>Access denied 
<dt>EINVAL
<dd>Sharing mode specified when file sharing not installed 
<dt>EMFILE
<dd>Too many open files 
<dt>ENOENT
<dd>File not found 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_close">_dos_close</a><br>
<a href="#_dos_open">_dos_open</a>
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="_dos_read">_dos_read</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_read( int handle, void __far *buffer, unsigned count, unsigned *numread); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_read function uses system call 0x3F to read data from 
the file specified in the handle argument. The function attempts to 
read count bytes of data and copy them to the buffer pointed to by 
buffer. The value pointed to by numread shows the actual 
number of bytes that were read. If the value pointed to by numread 
is 0, _dos_read tried to read at the end of the file. 
</dd>

<dt><b>Return Value</b></dt> <dd>If successful, the function returns 0. Otherwise, it returns the DOS 
error code and sets errno to EACCES (access denied) or EBADF 
(invalid file handle). 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_write">_dos_write</a>
</dd>

<dt><b>Example</b></dt> <dd>See dos_commit 
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="_dos_seek">_dos_seek</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned long _dos_seek( int handle, unsigned long offset, int origin); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_seek function moves the file pointer of a file to a 
specified position. The file pointer is the position where the next 
read or write occurs. Argument handle must be a handle to an 
open file. offset is the distance to move the file pointer. origin 
is the starting position of the move; values are:<br><br>
<dl>
<b>Value Starting position</b><br>
<dt>0 
<dd>The beginning of the file
<dt>1 
<dd>The current position
<dt>2 
<dd>The end of the file
</dl>
<br><br>

For DOS, Windows 3.x, and Phar Lap, a DOS system call 0x42 is 
used to seek. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns the resulting offset from the beginning of the file. If 
unsuccessful, returns -1L and sets errno. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="stdio.html#fseek">fseek</a><br>
<a href="io.html#_lseek">_lseek</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_seek
	Also demonstrates _dos_open, _dos_read 

    _DOS_SEE. C 
*/ 
#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;share.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt;

static void error (char *message)
{   
   perror (message);
   exit (EXIT_FAILURE); 
} 
void main ()
{   
    int handle;
    char buffer[20]; 
    unsigned actual; 

    if (_dos_open ("_DOS_SEE. C",
	_O_RDONLY|_SH_DENYNO, &handle) != 0) 
       error ("Open failed"); 

    if (_dos_seek (handle, -20, 2) == -1)
       error ("Couldn't seek from end"); 

    if (_dos_read (handle, buffer, 20, &actual) != 0) 
       error ("Couldn't read from end");
    printf("The 20 bytes at the end 
	      are\n\n%. 20s\n\n", buffer); 

    if (_dos_seek (handle, 20, 0) == -1)
       error ("Couldn't seek from beginning"); 
    if (_dos_read (handle, buffer, 20, &actual)
	!= 0) 
       error ("Couldn't read from beginning");
    printf("20 bytes 20 from the beginning 
	      are\n\n%. 20s\n\n", buffer); 

    if (_dos_seek (handle, 20, 1) == -1)
       error ("Couldn't seek from the current 
		position");
    if (_dos_read (handle, buffer, 20, &actual) 
	!= 0)
       error ("Couldn't read from the current 
		position");
    printf("20 bytes 20 from the current 
	      position are\n\n%. 20s\n\n", buffer);
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">The 20 bytes at the end are

\n\n", buffer);
}

20 bytes 20 from the beginning are

   Also de 

20 bytes 20 from the current position are 

   _D 
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_setblock">_dos_setblock</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_setblock( unsigned newsize, unsigned seg, unsigned *maxsize); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_setblock function uses system call 0x4A to change the 
size of a memory segment allocated by a previous call to 
dos_allocmem, dos_alloc, or dos_calloc. The newsize 
argument is the new number of paragraphs requested, seg is the 
segment address of the allocated memory whose size is to be 
changed. This function is the same as dos_setblock except in 
how values are returned. 
</dd>

<dt><b>Return Value</b></dt> <dd>The _dos_setblock function uses system call 0x4A to change the 
size of a memory segment allocated by a previous call to 
dos_allocmem, dos_alloc, or dos_calloc. The newsize 
argument is the new number of paragraphs requested, seg is the 
segment address of the allocated memory whose size is to be 
changed. This function is the same as dos_setblock except in 
how values are returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_allocmem">_dos_allocmem</a><br>
<a href="#dos_alloc">dos_alloc</a><br>
<a href="#dos_calloc">dos_calloc</a><br>
<a href="#_dos_setblock">_dos_setblock</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_setblock
	Also demonstrates _dos_allocmem 
	  and _dos_freemem
*/ 
#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main()
{   
   unsigned newseg;
   unsigned maxsize; 
   int result; 

   result = _dos_allocmem( 10,&amp; newseg);
   if (result == 0) 
   {
      printf("Memory allocated at %u\n", 
		newseg); result = _dos_setblock( 20, newseg, 
		&maxsize);
	if (result == 0) 
	{   
	  printf("Memory successfully expanded\n"); 
	  result = _dos_freemem (newseg);
	  if (result == 0) 
	     printf("Memory successfully freed\n");
	  else 
	     perror ("Error freeing memory");
	} 
	else
	{   
	  printf("_dos_setblock failed: ");
	  printf("only %u available at %u\n", 
		    maxsize, newseg); 

	  result = _dos_freemem (newseg);
	  if (result == 0) 
	     printf("Memory successfully freed\n"); 
	  else
	     perror ("Error freeing memory"); 
	}
   } 
   else
      perror ("_dos_allocmem failed"); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Memory allocated at 13988d
Memory successfully expanded
Memory successfully freed
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="dos_setblock">dos_setblock</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned dos_setblock( unsigned newsize, unsigned seg); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The dos_setblock function is like the _dos_setblock function 
except in the way it returns values. 
</dd>

<dt><b>Return Value</b></dt> <dd>If dos_setblock is successful, it returns the segment address of 
the allocated memory. Otherwise, the function sets _doserrno, 
does not change the block size, and returns the maximum possible 
block size. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_allocmem">_dos_allocmem</a><br>
<a href="#dos_alloc">dos_alloc</a><br>
<a href="#dos_calloc">dos_calloc</a><br>
<a href="#_dos_setblock">_dos_setblock</a>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="dos_set_ctrl_break">dos_set_ctrl_break</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void dos_set_ctrl_break( int on_off) 
</tt></dd>

<dt><b>Description</b></dt> <dd>Turns the control break checking on or off. A non-zero value for the 
on_off argument turns control break checking on and a zero value 
turns off control break checking. This function has the same effect as 
the BREAK command does for the DOS command processor. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#dos_get_ctrl_break">dos_get_ctrl_break</a>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_setdate">_dos_setdate</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_setdate( struct _dosdate_t *date) 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_setdate function uses the DOS system call 0x2B to 
set the current date to the date specified in the date argument. The 
format of the _dosdate_t structure is as follows: <br><br>
<pre class="ccode">struct _dosdate_t
{   
   unsigned char day; 		/* day of month( 1-31) */
   unsigned char month; 	/* month (1-12) */ 
   unsigned int year; 		/* year (1980-2099) */
   unsigned char dayofweek; 	/* day of week (0 = Sunday) */
} 
</pre>
</dd>

<dt><b>Synonym</b></dt> <dd>Function: dos_setdate<br>
Type: dos_date_t 
</dd>

<dt><b>Return Value</b></dt> <dd>0 if successful. Otherwise, returns a non-zero value and sets errno 
to EINVAL, if the date passed was invalid. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_getdate">_dos_getdate</a>
</dd>

<dt><b>Example</b></dt> <dd>See _dos_getdate 
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_setdrive">_dos_setdrive</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _dos_setdrive( unsigned drive, unsigned *no_of_drives); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_setdrive function uses system call 0x0E to change the 
currently logged drive to that requested in the drive argument. This 
argument is supplied as an unsigned integer where 1 refers to drive 
A, 2 refers to drive B, 3 refers to drive C, and so on. Argument 
no_of_drives is the total number of logical drives in the system.<br><br> 

The term logical drives refers to all block transfer devices in the 
system. This includes diskette (floppy disk) drives, ram disks, CD-ROM 
disks, and hard disks  including those that are partitioned 
into separate drives. A system fitted with a single diskette drive 
returns a value of 2 in no_of_drives. This is because a single 
diskette drive can be accessed as either of two logical drives, A or B. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: dos_setdrive 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_getdrive">_dos_getdrive</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _dos_setdrive */ 

#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{   
   unsigned numdrives; 
   _dos_setdrive(1, &amp;numdrives);
   printf("Total number of drives is:%d\n", 
	     numdrives);
   printf("Current drive is now a:\n"); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Total number of drives is: 32
Current drive is now a:
</pre>
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_setfileattr">_dos_setfileattr</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_setfileattr( const char *filepath, unsigned att) 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_setfileattr function gets the current file attributes of 
the named file and places them in the unsigned integer pointed to by 
att. The char pointer filepath references a standard DOS path 
and filename as a null terminated string. Individual file attributes can be set
by logically ORing them with the appropriate masks. <br><br>

The following names, defined in dos.h, can specify attributes: <br><br>

<b>Name Meaning</b><br><dl>
<dt>_A_RDONLY
<dd>Read only file 
<dt>_A_HIDDEN
<dd>Hidden file 
<dt>_A_SYSTEM
<dd>System file 
<dt>_A_ARCH
<dd>Archive file 
<dt>_A_NORMAL
<dd>Normal file; can be read or written to 
</dl>
</dd>

<dt><b>Synonym</b></dt> <dd>Function: dos_setfileattr 
Modes: FA_RDONLY, FA_HIDDEN, FA_SYSTEM, FA_ARCH, 
FA_NORMAL 
</dd>

<dt><b>Return Value</b></dt> <dd>0 if successful, Otherwise, returns the DOS error code and sets 
errno to EACCESS or ENOENT. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_getfileattr">_dos_getfileattr</a>
</dd>

<dt><b>Example</b></dt> <dd>See _dos_getfileattr 
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_setftime">_dos_setftime</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_setftime( int fd, unsigned date, unsigned time); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_setftime function uses system call 0x57 to set the time 
and date of the file attatched to the file descriptor fd to those 
specified in the arguments date and time. The format of these 
arguments is shown below: <br><br>
<dl>
<dt>date:
<dd>bits 0 to 4 
<dd>day of month (1-31)<br><br>
<dd>bits 5 to 8 
<dd>month (1-12)<br><br> 
<dd>bits 9 to 15 
<dd>year (relative to 1980) <br><br>

<dt>time:
<dd>bits 0 to 4 
<dd>number of 2-second increments (0-29)<br><br>
<dd>bits 5 to 10 
<dd>minutes (0-59)<br><br>
<dd>bits 11 to 15 
<dd>hours (0-23) 
</dl>
</dd>

<dt><b>Synonym</b></dt> <dd>Function: dos_setftime 
</dd>

<dt><b>Return Value</b></dt> <dd>0 if successful. Otherwise returns the DOS error code and sets 
errno to EBADF, indicating the file descriptor was invalid. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_getftime">_dos_getftime</a>
</dd>

<dt><b>Example</b></dt> <dd>See _dos_getftime 
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_dos_settime">_dos_settime</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_settime( struct _dostime_t *time); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_settime function uses system call 0x2D to set the 
current system time to the values passed in the structure pointed to 
by time. <br><br>

The format of the time structure is: <br><br>
<pre class="ccode">struct _dostime_t
{   
 unsigned char hour; 		/* hours (0-23) */
 unsigned char minute; 		/* minutes (0-59) */ 
 unsigned char second; 		/* seconds (0-59) */
 unsigned char hsecond;		/* seconds/ 100 (0-99)*/ 
} 
</pre>
</dd>

<dt><b>Synonym</b></dt> <dd>Function: dos_settime<br>
Type: dos_time_t 
</dd>

<dt><b>Return Value</b></dt> <dd>0 if successful. If an invalid time is passed, returns the DOS error 
code. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_gettime">_dos_gettime</a>
</dd>

<dt><b>Example</b></dt> <dd>See _dos_gettime 
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="_dos_setvect">_dos_setvect</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _dos_setvect( unsigned intnum, void (__interrupt __far *handler)()); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_setvect function uses DOS system call 0x25 to set the 
current value of the target interrupt vector intnum to a handler 
routine pointed to by handler. When a subsequent interrupt 
(intnum) is generated, the handler routine is called. If handler 
is a C routine, it must first be declared with the __interrupt 
attribute. To replace an interrupt vector, see the _dos_getvect 
function. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="dos2.html#_chain_intr.html">_chain_intr</a><br>
<a href="#_dos_getvect">_dos_getvect</a><br>
<a href="#_dos_keep">_dos_keep</a>
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="dos_set_verify">dos_set_verify</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void dos_set_verify(int on_off); 
</tt></dd>

<dt><b>Description</b></dt> <dd>Sets automatic read-after-write verification on (1) or off (0).  this functions has the same effect as the MS-DOS commands VERIFY ON and VERIFY OFF.
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#dos_get_verify">dos_get_verify</a>
</dd>
 </dl>



<!-- =================================================== -->

<hr> <h2><a name="_dos_write">_dos_write</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _dos_write( int handle, const void __far *buffer, unsigned count, 
unsigned *numwrt); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _dos_write function uses system call 0x40 to write data to a 
file. The handle argument specifies the file to write to, the buffer 
argument points to the data to write, the count argument indicates 
the number of bytes to write, and the numwrt indicates the number 
of bytes that were actually written. 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0 if successful. Otherwise, the function returns the DOS 
error code and sets errno to EACCESS (access denied) or EBADF 
(invalid file handle). 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_dos_read">_dos_read</a><br>
</dd>

<dt><b>Example</b></dt> <dd>See dos_commit
</dd>
 </dl>


<!-- =================================================== -->

<hr> <h2><a name="_x386_coreleft">_x386_coreleft</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _x386_coreleft(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>This function returns the largest memory block that are allocated using
functions such as malloc or calloc. If Virtual Memory is in use, _x386_coreleft
checks free disk space and adjusts free memory, allowing for changes in free
disk space caused by adding or deleting files on the drive containing the swap
file.<br><br>

This function is implemented for the X memory model only. 
</dd>

<dt><b>Return Value</b></dt> <dd>The size of the largest contiguous block of memory. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>calloc<br>
malloc<br>
<a href="#_x386_free_protected_ptr">_x386_free_protected_ptr</a>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_x386_free_protected_ptr">_x386_free_protected_ptr</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _x386_free_protected_ptr(void __far *fptr); 
</tt></dd>

<dt><b>Description</b></dt> <dd>This function is implemented for the X memory model only. It frees a protected mode far pointer that has been previously allocated with _x386_mk_protected_ptr. A maximum of 8 protected mode pointers can exist at any time, unused.
</dd>

<dt><b>Return Value</b></dt> <dd>Returns 0. If unsuccessful, no action is taken and -1 is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_x386_mk_protected_ptr">_x386_mk_protected_ptr</a>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_x386_get_abs_address">_x386_get_abs_address</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned long _x386_get_abs_address(void __far *address); 
</tt></dd>

<dt><b>Description</b></dt> <dd>This function, implemented for the X memory model only, returns a 
32-bit address relative to zero with a protected mode segment 
selector and a 32-bit offset for inputs. Use it to find the starting 
address of DGROUP as follows:<br><br>

<pre class="ccode">dgroup_address = _x386_get_abs_address ((void *) getDS());
</pre>
</dd>

<dt><b>Return Value</b></dt> <dd>A 32-bit protected mode address relative to zero.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_x386_map_physical_address">_x386_map_physical_address</a>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_x386_map_physical_address">_x386_map_physical_address</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *_x386_map_physical_address(void *abs_addr, unsigned size); 
</tt></dd>

<dt><b>Description</b></dt> <dd>This function maps specific physical addresses. The abs_addr
argument specifies the start address of the physical memory to map.
The size argument indicates the size of the region, in bytes. The
function is implemented for the X memory model only.<br><br>

Typically, you use this function to access memory mapped I/ O 
devices. The region to be mapped must be completely above or 
completely below the 1MB boundary; it cannot lap over the 
boundary itself. The function will fail and return -1 if memory is 
insufficient or if the DPMI host refuses service. X-32 must allocate a 
minimum of 4 KB for each _x386_map_physical_address call. 
</dd>

<dt><b>Return Value</b></dt> <dd>A near pointer that can be used to access the actual physical address requested.
The device will not be accessible at the actual physical address; it will appear
to be at the address returned by this function. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_x386_get_abs_address">_x386_get_abs_address</a>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_x386_memlock">_x386_memlock</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _x386_memlock(void *__far pointer, unsigned int length); 
</tt></dd>

<dt><b>Description</b></dt> <dd>This function locks a region of memory in a virtual memory 
environment. Argument pointer points to the region of memory to 
lock; argument length is the size of the region, in bytes. This 
function is implemented for X memory model only.<br><br>

On systems where virtual memory is enabled, use this function to 
lock all code, data, and stack accessed by hardware interrupt 
handlers, or INT 1BH, 23H, OR 24H handlers. This function can be 
called with or without a Virtual Memory manager; the function 
returns successfully if no Virtual Memory manager is present. 
</dd>

<dt><b>Return Value</b></dt> <dd>If successful, 0 is returned. If unsuccessful, -1 is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_x386_memunlock">_x386_memunlock</a>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_x386_memunlock">_x386_memunlock</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _x386_memunlock(void __far *pointer, unsigned int length); 
</tt></dd>

<dt><b>Description</b></dt> <dd>Unlocks a region of memory in a 
virtual memory environment. The pointer argument points to the 
region of memory to lock; the length argument is the size of the 
region, in bytes. This function can be called at any time, but it is only
effective when a Virtual Memory manager is running.<br><br>

This function is implemented for the X memory model only. 
</dd>

<dt><b>Return Value</b></dt> <dd>If successful, 0 is returned. If unsuccessful, -1 is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOSX
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_x386_memlock">_x386_memlock</a>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_x386_mk_protected_ptr">_x386_mk_protected_ptr</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void __far *_x386_mk_protected_ptr(unsigned long abs_addr);
</tt></dd>

<dt><b>Description</b></dt> <dd>This function is implemented for the X memory model only. With 
this function, the absolute address is given and the function returns a 
protected mode far pointer that can be used to access the memory at 
<i>abs_addr</i>. A maximum of 8 protected mode pointers can exist at 
any time. Unused, although previously allocated, pointers can be 
freed with _x386_free_protected_ptr. 
</dd>

<dt><b>Return Value</b></dt> <dd>A protected mode far pointer. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_x386_free_protected_ptr">_x386_free_protected_ptr</a>
</dd>
 </dl>



<br><br><br><br>

</td></table>





<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

