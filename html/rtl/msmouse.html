
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - msmouse.h
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:15 2006
</div>
</div>

<!-- Generated by Ddoc from msmouse.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>Mouse - msmouse.h</h1>

This chapter describes:

<ul>
	<li> How to convert mouse coordinates to display coordinates

	<li> How to use msm_functions to:

	<ul>
	<li> initialize the mouse driver
	<li> position the mouse cursor
	<li> set the cursor's shape and size
	<li> adjust mouse response
	<li> test for events and movement
	<li> use the mouse to emulate a light pen
	</ul>
	<li> How a sample program uses the msm_functions
	<li> Mouse function reference
	<ul>
		<li><a href="#msm_condoff"><b>msm_condoff</b></a>
		<li><a href="#msm_getpress"><b>msm_getpress</b></a>
		<li><a href="#msm_getrelease"><b>msm_getrelease</b></a>
		<li><a href="#msm_getstatus"><b>msm_getstatus</b></a>
		<li><a href="#msm_hidecursor"><b>msm_hidecursor</b></a>
		<li><a href="#msm_init"><b>msm_init</b></a>
		<li><a href="#msm_lightpen"><b>msm_lightpenoff</b></a>
		<li><a href="#msm_lightpen"><b>msm_lightpenon</b></a>
		<li><a href="#msm_readcounters"><b>msm_readcounters</b></a>
		<li><a href="#msm_setarea"><b>msm_setareax</b></a>
		<li><a href="#msm_setarea"><b>msm_setareay</b></a>
		<li><a href="#msm_setcurpos"><b>msm_setcurpos</b></a>
		<li><a href="#msm_setgraphcur"><b>msm_setgraphcur</b></a>
		<li><a href="#msm_setratio"><b>msm_setratio</b></a>
		<li><a href="#msm_settextcur"><b>msm_settextcur</b></a>
		<li><a href="#msm_setthreshhold"><b>msm_setthreshhold</b></a>
		<li><a href="#msm_showcursor"><b>msm_showcursor</b></a>
		<li><a href="#msm_signal"><b>msm_signal</b></a>
		<li><a href="#msm_term"><b>msm_term</b></a>
	</ul>
</ul>

Digital Mars msm_functions provide a C interface to the Microsoft 
mouse and require that a Microsoft compatible mouse driver be 
installed. Keep your mouse programming manual handy; these 
functions work with the information in that manual.

<h3>Converting Mouse Coordinates to Display</h3>

The mouse coordinate system is left-handed for both text and 
graphics modes, with 0, 0 being the upper left corner.
<p>

The Display functions use a left-handed coordinate system. The 
mouse coordinates in text mode are not in character coordinates.
<p>

To convert from display (character) coordinates to mouse 
coordinates use:
<pre>
	if (40 column mode)
		mouse_x = display_x * 16; 
	else
		mouse_x = display_x * 8; 
	mouse_y = display_y * 8; 
</pre>

The mouse driver sometimes gets the number of screen rows wrong 
in text mode, so the recommended method of initializing the mouse 
if the display package is also used is: 
<pre>
	disp_open();		/* initialize display	*/
	msm_init();		/* initialize mouse	*/ 
	/* Mouse driver sometimes gets the number of screen rows wrong,
	   so here we force it to whatever disp_open() discovered.
	 */ 
	msm_setareay(0,(disp_numrows -1) * 8);
	msm_showcursor();	/* mouse cursor on	*/ 
</pre>

<h3>Using msm_Functions</h3>

The following sections describe how to use the msm_functions. For 
more information on specific functions, see Chapter 3.

<h3>Initializing and Terminating the Mouse Driver</h3>

Functions that initialize and terminate the mouse driver are:

<ul>
	<li> msm_init
	<li> msm_term
</ul>

The msm_init function must be called before any of the other 
mouse functions. It initializes the mouse driver and performs a 
number of operations, including setting the default cursor shape.<br><br>

The msm_term function terminates the mouse driver and cleans up 
the display by removing the mouse cursor. Once msm_term has 
been called, another msm_init is required to restart the driver.</font><br><br>

<font size=4><b>
Positioning the Mouse Cursor</font></b><br><br>

<font size=3>
Functions that position the mouse cursor are:<br><br>

<ul>
	<li> msm_setareax
	<li> msm_setareay
	<li> msm_setcurpos
</ul>

Use msm_setareax and msm_setareay to restrict mouse cursor 
movements to a particular rectangle, normally the screen 
coordinates. msm_init sets these to reflect the screen size, unless a 
fault exists in the mouse driver.<br><br>

Use msm_setcurpos to position the mouse cursor at an arbitrary 
position on the screen.</font><br><br>

<font size=4><b>
Setting Mouse Cursor Shape and Size</font></b><br><br>

<font size=3>
Functions that set the shape and size of the mouse cursor are:<br><br>

<ul>
	<li> msm_setgraphcur
	<li> msm_settextcur
</ul>

Use msm_setgraphcur to set the graphics cursor shape, and 
msm_settextcur to set the text cursor shape. The graphics cursor 
is the most flexible; it is bit mapped on a 16x16 matrix. The text 
cursor can be used only as a valid character and attribute 
combination. A zero character with a blinking attribute mask allows 
a flashing see-through block cursor to be used.</font><br><br>

<font size=4><b>
Controlling the Display of the Mouse Cursor</font></b><br><br>

<font size=3>
Functions that control display of the mouse cursor are:<br><br>

<ul>
	<li> msm_hidecursor
	<li> msm_showcursor
	<li> msm_condoff
</ul>

Use msm_hidecursor and msm_showcursor to turn the mouse 
cursor off and on unconditionally. They are useful to bracket an 
instruction that updates the display. Because a time penalty is 
involved, enclose a series of updates if possible, rather than each 
individual update.<br><br>

The msm_condoff function turns off the cursor only when it is in a 
specified area of the screen and is useful for an area of the screen 
that is being continually updated. However, any call to 
msm_showcursor disables this automatic hiding facility.<br><br>

The mouse cursor must be hidden when writing to or updating the 
screen. Otherwise, you risk screen corruption.</font><br><br>

<font size=4><b>
Adjusting Mouse Response</font></b><br><br>

<font size=3>
Functions that modify mouse response to movement are:<br><br>

<ul>
	<li> msm_setratio
	<li> msm_setthresholdf
</ul>

Use msm_setratio to set the sensitivity of the mouse. Higher 
values mean the mouse must be moved further to get the same 
relative cursor movement. Generally, the higher the screen 
resolution, the lower this ratio needs to be.<br><br>

Use msm_setthreshold to set the threshold speed for mouse 
movement. This threshold is where the mouse/ cursor ratio is 
temporarily halved so that the mouse appears to move twice as 
quickly. This is used to provide fast movement of the mouse cursor 
without sacrificing precision when working on detail. For example, 
this is useful when a user wants to go to a menu.</font><br><br>

<font size=4><b>
Testing for Mouse Events and Movement</font></b><br><br>

Functions that test for mouse events and movement are:

<ul>
	<li> msm_readcounters<br>
	<li> msm_getstatus<br>
	<li> msm_getpress<br>
	<li> msm_getrelease<br>
	<li> msm_signal<br><br>
</ul>

Use msm_readcounters to detect motion; it reports how far the 
mouse has moved since the last call, and in what direction. The 
movement is in mouse units (mickeys) and must be converted into 
pixels with the aid of the mickey/ pixel ratio as used by 
msm_setratio.<br><br>

Use msm_getstatus to return the current cursor position in pixels, 
and the current state of the mouse buttons, for example, whether 
they were up or down at the time the call was made.<br><br>

Use the msm_getpress and msm_getrelease functions for event 
counts. These functions count the number of times the specified 
button has been pressed (for msm_getpress) or released (for 
msm_getrelease) since the last time the function was called. They 
also indicate the cursor position when the last event was recorded. 
These functions are useful when you need to determine whether the 
user is clicking a mouse button or attempting a drag. For example, 
you could write a routine that uses these functions to test a button. 
When a button press is detected, the function waits a fixed interval 
for a release. If it does not get one it assumes a drag is in progress.<br><br>

Use the msm_signal function to install a user routine as a handler 
which is then called whenever a mouse event occurs. This facility 
allows mouse events to be handled asynchronously. When a mouse 
event occurs, information is passed to the user's function detailing 
the event that caused the signal, the current button status and the 
position of the mouse cursor.</font><br><br>

<font size=4><b>
Emulating a Light Pen</font></b><br><br>

<font size=3>
Functions that cause the mouse to emulate a light pen are:<br><br>

<ul>
	<li> msm_lightpenon
	<li> msm_lightpenoff
</ul>

When light pen emulation is on (the default), movement of the 
mouse, and left and right buttons being simultaneously pressed are 
reflected in the appropriate settings in the light pen registers of the 
IBM PC BIOS.</font><br><br>

<font size=4><b>
Sample Program</font></b><br><br>

<font size=3>
The following example uses msm_functions.<br>
<pre>

	#include &lt;stdio.h&gt;
	#include &lt;msmouse.h&gt; 
	#include &lt;stdlib.h&gt;

	int main()
	{ 
	    if (msm_init() == -1) { 
	       printf("Mouse initialization succeeded\n"); 

	       msm_showcursor(); 

	       while (1) { 
		  int status; 
		  unsigned x, y; 
		  status = msm_getstatus(&amp; x, &y); 

		  if (status &amp; LEFT_BUTTON) { 
		     msm_hidecursor(); 
		     printf("x = %u, y = %u\n", x, y); 
		     msm_showcursor(); 
		  } 

		  if (status &amp; RIGHT_BUTTON) 
		     break; 
	       } 

	       msm_term(); 
	    } 
	    else { 
	       printf("Mouse initialization failed\n"); 
	       return EXIT_FAILURE; 
	    } 

	    return EXIT_SUCCESS;
	} 
</pre>


<hr><!-- =========================================== -->

<a name="msm_condoff">
<h2>msm_condoff</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_condoff(unsigned upperx, unsigned uppery, unsigned lowerx, 
unsigned lowery); 

<br><br>

<b>
Description
</b><br><br>
The msm_condoff function defines an area in which the mouse cursor is hidden.  The parameters define a rectangular region on the screen.  When the mouse is in that region, the mouse cursor is hidden.  This is useful if a portion of the screen is to be updated.  A call to msm_showcursor displays the cursor again.
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a><br>
<a href="#msm_showcursor">msm_showcursor</a><br>
<a href="#msm_term">msm_term</a>
<br><br>


<hr><!-- =========================================== -->

<a name="msm_getpress">
<h2>msm_getpress</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmmouse.h
<br><br>

<b>
Prototype
</b><br><br>
int msm_getpress(unsigned *count, unsigned *curposx, unsigned *curposy); 
<br><br>

<b>
Description
</b><br><br>
The msm_getpress function gets mouse button press information. 
The count parameter points to an integer designating which button 
to get information about (0 = left button, 1 = right button, 2 = middle 
button). The function places the number of times that the button has 
been pressed since the last call to msm_getpress into count and 
the mouse position at the last press into curposx and curposy. 
Values can be in the range 0 to 32767.<br><br>

Before using msm_getpress call msm_init. 
<br><br>

<b>
Return Value
</b><br><br>
Returns the state of all of the buttons as a bit pattern.<br><br>
<dl>
<b>Bit/Button</b>
<dt>0 
<dd>left button (1 == down, 0 == up)
<dt>1 
<dd>right button
<dt>2 
<dd>middle button
</dl>
<br><br> 

All other bits should be ignored. 
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a><br>
<a href="#msm_getrelease">msm_getrelease</a><br>
<a href="#msm_getstatus">msm_getstatus</a><br>
<a href="#msm_term">msm_term</a>
<br><br>


<hr><!-- =========================================== -->

<a name="msm_getrelease">
<h2>msm_getrelease</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
int msm_getrelease(unsigned *count, unsigned *curposx, unsigned *curposy); 
<br><br>

<b>
Description
</b><br><br>
The msm_getrelease function gets mouse button release 
information. The count argument points to an integer designating 
the button about whichyou require information (0 = left button, 1 = 
right button, 2 = middle button). The function places into count the 
number of times the button has been released since the last call to 
msm_getrelease, and places into curposx and curposy the 
mouse position at the time of release. Values range from 0 to 32767. 
<br><br>

<b>
Return Value
</b><br><br>
Returns the state of all of the buttons as a bit pattern.<br><br>
<dl>
<b>Bit/Button</b>
<dt>0 
<dd>left button (1 == down, 0 == up)
<dt>1 
<dd>right button
<dt>2 
<dd>middle button
</dl>
<br><br>

All other bits should be ignored. <br><br>

Before using msm_getrelease initialize the mouse driver by 
calling msm_init. 
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>

<b>
Example
</b><br><br><pre>
See msm_init
</pre><br><br>


<hr><!-- =========================================== -->

<a name="msm_getstatus">
<h2>msm_getstatus</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
int msm_getstatus(unsigned *curposx, unsigned *curposy); 
<br><br>

<b>
Description
</b><br><br>
The msm_getstatus function obtains the status of the mouse and 
places the current cursor position in the variables pointed to by 
curposx and curposy. 
<br><br>

<b>
Return Value
</b><br><br>
Returns the state of all of the buttons as a bit pattern.<br><br>
<dl>
<b>Bit/Button</b>
<dt>0 
<dd>left button (1 == down, 0 == up)
<dt>1 
<dd>right button
<dt>2 
<dd>middle button
</dl>
<br><br>

Ignore the other bits.
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 <br><br>

Before using msm_getstatus initialize the mouse driver by calling 
msm_init. 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>

<b>
Example
</b><br><br><pre>
See msm_init
</pre><br><br>



<hr><!-- =========================================== -->

<a name="msm_hidecursor">
<h2>msm_hidecursor</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_hidecursor(void); 
<br><br>

<b>
Description
</b><br><br>
The msm_hidecursor function hides the cursor and decrements 
the cursor flag. Before using msm_hidecursor initialize the mouse 
driver by calling msm_init. 
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a><br>
<a href="#msm_showcursor">msm_showcursor</a>
<br><br>



<hr><!-- =========================================== -->

<a name="msm_init">
<h2>msm_init</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
int msm_init(void); 
<br><br>

<b>
Description
</b><br><br>
The msm_init function initializes the mouse driver. You must call 
msm_init before using any other mouse functions. To terminate 
the mouse driver, call msm_term.
<p>

In graphics mode, msm_init sets the cursor to be an arrow; in text 
mode, msm_init sets the cursor to be inverse video. In addition, 
msm_init sets the following cursor attributes: the cursor is 
positioned in the middle of the screen. the cursor display is turned 
off and the min/max cursor position is set to the full screen 
dimensions. Finally, the mickey/pixel ratio is set to 1/1 in the x 
direction and 2/1 in the y direction. 

<h4>Return Value</h4>

Returns -1 if successful. Otherwise, returns 0 if initialization failed.
Failure might indicate no mouse driver is present. 

<h4>Compatibility</h4>

DOS Windows 3.x Phar Lap DOSX Win32 

<h4>See Also</h4>

<a href="#msm_term">msm_term</a>

<h4>Example</h4>

<pre>
	/* 	Example for msm_init */ 

	#include &lt;stdio.h&gt;
	#include &lt;stdlib.h&gt;
	#include &lt;msmouse.h&gt;

	void main ()
	{ 
	   int status, oldstatus = -1;
	   unsigned x, y; 

	   if (! msm_init ())
	   { 
		fprintf (stderr, "Unable to initialize
		         mouse system\n"); 
		exit (EXIT_FAILURE);
	   } 

	   printf (" Mouse initialization succeeded\n"); 

	   msm_showcursor (); 

	   while (1)
	   { 
	
		status = msm_getstatus (&amp; x, &y);
		if ((status &amp; LEFT_BUTTON) &amp;&amp; (status != 
		      oldstatus))
		{ 
		      msm_hidecursor ();
		      printf (" x = %u, y = %u\n", x, y); 
		      msm_showcursor ();
		} 

		if (status &amp; RIGHT_BUTTON)
		   break; 

		oldstatus = status;
	   } 
	
	   msm_term ();
	} 
</pre>

<hr><!-- =========================================== -->

<a name="msm_lightpen">
<h2>msm_lightpenon, msm_lightpenoff</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_lightpenon(void);<br>
void msm_lightpenoff(void); 
<br><br>

<b>
Description
</b><br><br>
These functions turn on or off light pen emulation mode. The mouse 
emulates a light pen; the "pen" is off the screen when the left and 
right buttons are up, and the "pen" is down when both buttons are 
down. Before using these functions, initialize the mouse driver by 
calling msm_init. 
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>

<b>
Example
</b><br><br><pre>
See msm_init
</pre><br><br>


<hr><!-- =========================================== -->

<a name="msm_readcounters">
<h2>msm_readcounters</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_readcounters(int *countx, int *county);  
<br><br>

<b>
Description
</b><br><br>
The msm_readcounters function reads the mouse motion 
counters in mickeys. A mickey is 1/ 200 of an inch. Before using 
msm_readcounters, call msm_init to initialize the mouse driver. 
<br><br>

<b>
Return Value
</b><br><br>
On returning the variables pointed to by countx and county 
contain the mickey count since the last call; values can range 
from -32768 to 32767. 
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>

<b>
Example
</b><br><br><pre>
See msm_init
</pre><br><br>

<hr><!-- =========================================== -->

<a name="msm_setarea">
<h2>msm_setareax, msm_setareay</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_setareax(unsigned minx, unsigned maxx);<br>
void msm_setareay(unsigned miny, unsigned maxy); 
<br><br>

<b>
Description
</b><br><br>
The msm_setareax function sets a minimum and maximum 
horizontal position for the cursor. If maxx &lt; minx, the values are 
exchanged. The mouse horizontal motion is restricted to within these 
values. <br><br>

The msm_setareay function sets minimum and maximum vertical 
position for the cursor. If maxy &lt; miny, the values are exchanged. 
The mouse vertical motion is restricted to within these values. <br><br>

Before using these functions initialize the mouse driver by calling 
msm_init. 
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>

<b>
Example
</b><br><br><pre>
See msm_init
</pre><br><br>


<hr><!-- =========================================== -->

<a name="msm_setcurpos">
<h2>msm_setcurpos</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_setcurpos(unsigned curposx, unsigned curposy); 
<br><br>

<b>
Description
</b><br><br>
The msm_setcurpos function sets the cursor position. The upper 
left corner of the screen is 0, 0. The values for curposx and 
curposy must be within the screen. <br><br>

Before using msm_setcurpos initialize the mouse driver by calling 
msm_init. 
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>

<b>
Example
</b><br><br><pre>
See msm_init
</pre><br><br>



<hr><!-- =========================================== -->

<a name="msm_setgraphcur">
<h2>msm_setgraphcur</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_setgraphcur(int hotx, int hoty, int *pmasks);  
<br><br>

<b>
Description
</b><br><br>
The msm_setgraphcur function sets the graphics cursor block. On 
entry to the function hotx and hoty should point to the location of 
the 'hot spot' of cursor. Values must be in the range -16 through 16. 
Location 0, 0 is the upper left corner of the cursor with positive 
values extending right and down. The variable pmasks should point 
to an array of 32 words which contain bit masks defining the cursor. 
The first 16 words define the mask — the bits of the background 
which 'shine' through the cursor. A 1 means shine through, a 0 
means not. The second 16 words define the bitmap of the cursor, 1 
being on and 0 being off. The cursor is 16* 16, the first word forms 
the top row, bit 15 forms the left-most column. <br><br>

Initialize the mouse driver by calling msm_init. 
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>

<b>
Example
</b><br><br><pre>
See msm_init
</pre><br><br>

<hr><!-- =========================================== -->

<a name="msm_setratio">
<h2>msm_setratio</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_setratio(unsigned ratiox, unsigned ratioy); 
<br><br>

<b>
Description
</b><br><br>
The msm_setratio function sets the mickey/ pixel ratio (the 
sensitivity of the mouse). Higher values mean less cursor movement 
for corresponding mouse movement. The default values are 8, 16. 
Values for ratiox and ratioy must be in the range 1 to 32767. 
Before using msm_setratio call msm_init. 
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>




<hr><!-- =========================================== -->

<a name="msm_settextcur">
<h2>msm_setttextcur</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_settextcur(int select, int scanstart, int scanstop); 
<br><br>

<b>
Description
</b><br><br>
The msm_settextcur function sets the text cursor. On entry to the 
function, select is used to indicate whether or not to use a 
hardware cursor. If select is 1, then the hardware text cursor is 
used. If select is 0, then an attribute cursor is used. The 
parameters scanstart and scanstop have different uses 
depending on the value in select. If select is 1, then these 
values form the starting and ending scan lines of the hardware text 
cursor. If select is 0, then these values form the screen mask and 
cursor mask, respectively, for the attribute cursor. <br><br>

Before using msm_settextcur initialize the mouse driver by 
calling msm_init. 
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>


<hr><!-- =========================================== -->

<a name="msm_setthreshhold">
<h2>msm_setthreshhold</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_setthreshhold(unsigned speed); 
<br><br>

<b>
Description
</b><br><br>
The msm_setthreshhold function sets the double speed 
threshold, the speed at which the mickey/ pixel ratio is temporarily 
halved, so that the mouse apparently moves faster. Speed is in 
mickeys/ second. The default speed is 64. <br><br>

Before using msm_setthreshhold initialize the mouse driver by 
calling msm_init. 
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>



<hr><!-- =========================================== -->

<a name="msm_showcursor">
<h2>msm_showcursor</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_showcursor(void); 
<br><br>

<b>
Description
</b><br><br>
The msm_showcursor function shows cursor. That is, this function 
increments the cursor flag. If the cursor flag is 0, then the cursor is 
displayed. msm_showcursor must be called after msm_init in 
order for the cursor to appear. msm_showcursor and 
msm_hidecursor can be nested. If msm_hidecursor is called n 
times, msm_showcursor must be called n times in order to show 
the cursor. Generally, remove the cursor before any screen I/ O is 
performed, and then restore the cursor. <br><br>

Before using msm_showcursor initialize the mouse driver by 
calling msm_init. 
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>

<b>
Example
</b><br><br><pre>
See msm_init
</pre><br><br>

<hr><!-- =========================================== -->

<a name="msm_signal">
<h2>msm_signal</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_signal(unsigned mask, void(* func)(unsigned mask, unsigned state, unsigned curposx, unsigned curposy), void *stack); 
<br><br>

<b>
Description
</b><br><br>
The msm_signal function sets up a user-defined subroutine input 
mask. Use msm_signal to set a function to be called whenever 
input is available from the mouse. Before using msm_signal call 
msm_init. On input, mask defines when to call the user routine (1 
is yes): <br><br>
<dl>
<b>Bit/Description</b>
<dt>0 
<dd>Mouse moved
<dt>1 
<dd>Left button is pressed
<dt>2 
<dd>Left button is released
<dt>3 
<dd>Right button is pressed
<dt>4 
<dd>Right button is released
<dt>5 
<dd>Middle button is pressed
<dt>6 
<dd>Middle button is released
</dl>
<br><br>

Other bits are not used. The parameter func is a pointer to the 
application-defined interrupt service routine to call whenever a 
mouse button is pressed or released, or the mouse moves, according 
to the bits in mask. The parameter stack contains the value to set 
the stack pointer to when func is called. The stack value should 
point just past the end of an area that is at least 256 bytes long. 
When func is called, it is passed the following information: <br><br>
<dl>
<dt>mask
<dd>Event that occurred is indicated with the 
bit set as defined above. <br><br>

<dt>state
<dd>If button event, this is the button 
number of the button that changed (0 = 
left, 1 = right, 2 = middle). <br><br>

<dt>curposx, curposy 
<dd>Current mouse position. 
</dl>
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>



<hr><!-- =========================================== -->

<a name="msm_term">
<h2>msm_term</h2>
</a>

<font size=3><b>
Header
</b><br><br>
msmouse.h
<br><br>

<b>
Prototype
</b><br><br>
void msm_term(void); 
<br><br>

<b>
Description
</b><br><br>
The msm_term function terminates the mouse driver. You should 
call this function before the program exits if you used msm_init to 
initialize the mouse driver. 
<br><br>

<b>
Return Value
</b><br><br>
None
<br><br>

<b>
Compatibility
</b><br><br>
DOS Windows 3.x Phar Lap DOSX Win32 
<br><br>

<b>
See Also
</b><br><br>
<a href="#msm_init">msm_init</a>
<br><br>

<h3>Example</h3>
See msm_init



<br><br><br><br>

</td></table>





<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

