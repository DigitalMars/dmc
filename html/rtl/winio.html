
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - winio.h
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:16 2006
</div>
</div>

<!-- Generated by Ddoc from winio.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>WINIO</h1>

This chapter describes:

<ul>
	<li> The reasons and origins for using WINIO
	<li> Compiling and linking with WINIO
	<li> What the WMHANDLER functions are
	<li> How a sample program uses WINIO
	<li> Converting DOS and WINC programs to WINIO
	<li> Function reference
	<ul>
	<li><a href="#ungets"><b>ungets</b></a>
	<li><a href="#winio_about"><b>winio_about</b></a>
	<li><a href="#winio_bufsize"><b>winio_bufsize</b></a>
	<li><a href="#winio_clear"><b>winio_clear</b></a>
	<li><a href="#winio_close"><b>winio_close</b></a>
	<li><a href="#winio_closeall"><b>winio_closeall</b></a>
	<li><a href="#winio_current"><b>winio_current</b></a>
	<li><a href="#winio_defwindowsize"><b>winio_defwindowsize</b></a>
	<li><a href="#winio_end"><b>winio_end</b></a>
	<li><a href="#winio_getinfo"><b>winio_getinfo</b></a>
	<li><a href="#winio_hmenufile"><b>winio_hmenufile</b></a>
	<li><a href="#winio_hmenuhelp"><b>winio_hmenuhelp</b></a>
	<li><a href="#winio_hmenumain"><b>winio_hmenumain</b></a>
	<li><a href="#winio_home"><b>winio_home</b></a>
	<li><a href="#winio_init"><b>winio_init</b></a>
	<li><a href="#winio_onclose"><b>winio_onclose</b></a>
	<li><a href="#winio_onpaintentry"><b>winio_onpaintentry</b></a>
	<li><a href="#winio_onpaintexit"><b>winio_onpaintexit</b></a>
	<li><a href="#winio_openwindows"><b>winio_openwindows</b></a>
	<li><a href="#winio_resetbusy"><b>winio_resetbusy</b></a>
	<li><a href="#winio_setbufsize"><b>winio_setbufsize</b></a>
	<li><a href="#winio_setbusy"><b>winio_setbusy</b></a>
	<li><a href="#winio_setcurrent"><b>winio_setcurrent</b></a>
	<li><a href="#winio_setecho"><b>winio_setecho</b></a>
	<li><a href="#winio_setfont"><b>winio_setfont</b></a>
	<li><a href="#winio_setlinefn"><b>winio_setlinefn</b></a>
	<li><a href="#winio_setmenufunc"><b>winio_setmenufunc</b></a>
	<li><a href="#winio_setpaint"><b>winio_setpaint</b></a>
	<li><a href="#winio_settitle"><b>winio_settitle</b></a>
	<li><a href="#winio_warn"><b>winio_warn</b></a>
	<li><a href="#winio_window"><b>winio_window</b></a>
	<li><a href="#wmhandler_create"><b>wmhandler_create</b></a>
	<li><a href="#wmhandler_destroy"><b>wmhandler_destroy</b></a>
	<li><a href="#wmhandler_get"><b>wmhandler_get</b></a>
	<li><a href="#wmhandler_hwnd"><b>wmhandler_hwnd</b></a>
	<li><a href="#wmhandler_set"><b>wmhandler_set</b></a>
	</ul>
</ul>

WINIO library functions are declared in winio.h. WINIO is an easy-to-
use, higher level library built on top of the standard Windows 3.x 
API. You use it to write Windows programs, as well as to port DOS 
programs to Windows.<p>

For in-depth information on how to use WINIO for all kinds of 
applications, see the book, <i>Undocumented Windows</i> by Andrew 
Shulman, David Maxey, and Matt Pietrek, copyright 1992 by 
Addison-Wesley Publishing Company.</font><p>

<font size=4><b>
Introduction to WINIO</font></b><p>

<font size=3>
WINIO is a higher level, easy-to-use library built on top of the 
standard Windows 3.x API. It provides a DOS-like procedure based 
wrapper over event-driven Windows 3 application code.<p>

WINIO supports a subset of the standard C stdio.h library 
functions under protected mode Windows 3.x, plus a set of 
extensions for handling events, manipulating windows, building 
menus, and more. It converts low level stdio.h library calls to 
Windows API calls.</font><p>

<font size=4><b>
Why Use WINIO?</font></b><p>

<font size=3>
You use WINIO for writing Windows programs, not just for porting 
DOS programs to Windows. WINIO makes Windows applications 
easier to read and code, because basic operations are not 
complicated or obscured by direct use of the Windows API calls.<p>


WINIO applications let the user scroll and resize windows, click 
lines of text, and choose menu items. And WINIO properly handles 
many Windows WM_messages automatically. Your WINIO 
applications can also call the Windows API directly.</font><p>

<font size=4><b>
The Origin of WINIO</font></b><p>

<font size=3>
WINIO (sometimes called WINDOS) was developed by industry 
expert Andrew Shulman, and is described in his best-selling book, 
<i>Undocumented Windows</i> (copyright 1992 by Addison-Wesley 
Publishing Company, co-authored with David Maxey and Matt 
Pietrek). This book is recommended reading for those interested in 
looking under the hood of Windows.<p>

Andrew Shulman used the WINIO library to write nearly all the 
sample programs in <i>Undocumented Windows</i>, and the book offers 
numerous examples and detailed discussions on how to use WINIO 
for all kinds of programs.</font><p>

<font size=4><b>
Compiling and Linking with WINIO</font></b><p>

<font size=3>
To compile with WINIO:<p>

° Specify the -D_WINIO option on the SC command line, 
or define _WINIO in your code<p>

° Make your project a WINIO project in the IDDE<p>

In addition, you need to include stdio.h in your compilation. 
Digital Mars's version of stdio.h includes winio.h automatically if 
the predefined macro _WINIO is defined. winio.h in turn includes 
windows. h automatically. If you use any of the wmhandler_
functions, you need to include wmhandler.h.<p>

You can also compile with WINIO by replacing #include 
"stdio.h" with #include windows.h and #include 
winio.h, as described on page 671 of Andrew Shulman's book, 
<i>Undocumented Windows</i>.</font><p>

<font size=4><b>
Linking with WINIO</font></b><p>

<font size=3>
WINIO resides in a separate .lib file that you must link with your 
application. The library you use depends on the memory model 
you're compiling with:<p>
<dl>
<dt>swindos.lib 
<dd>Small model
<dt>mwindos.lib 
<dd>Medium model 
<dt>cwindos.lib 
<dd>Compact model 
<dt>lwindos.lib 
<dd>Large model 
</dl><br>
Note <br>

WINIO is supported for 16-bit compilations only. If 
you include winio.h in a 32-bit compilation, a 
compile time error is generated.</font><p>

<font size=4><b>
WINIO Resources</font></b><p>

<font size=3>
If you want your program to have the "Windows meets stdio" icon, 
use the windos.rc resource file. This file is included by default in 
WINIO projects created with the IDDE. If you create your own 
resource script, write #include <window.rc> to use the standard 
icon.</font><p>

<font size=4><b>
WMHANDLER Functions</font></b><p>

<font size=3>
You use the WMHANDLER functions to install and use handlers for 
WM_messages. The WMHANDLER functions are declared in 
wmhandlr. h. These functions are typically used along with the 
WINIO functions, although it is possible to create a WMHANDLER 
application that does not use WINIO calls. Most WINIO applications 
only need to call wmhandler_set() and/ or wmhandler_yield.</font><p>

<font size=4><b>
A Basic WINIO Program</font></b><p>

<font size=3>
WINIO programs begin with a call to main() rather than 
WinMain(). Standard argc, argv parameter passing is supported. 
Before main() is called, WINIO creates a window with a 32Kb 
buffer (see winio_window).<p>

Here is an example of a WINIO program:<br>
<pre>
	/* hello. c */
	#define _WINIO 1 
	#include "stdio.h" 

	int main(int argc, char *argv[])
	{   
	    int i;
	    winio_settitle(winio_current(), 
		"Hello from WINIO"); 
	    
		for (i= 0; i&lt; argc; i++)
		printf(% d\t% s\n", i, argv[i]); 
	    return 0;
	} 
</pre></font><br>

<font size=4><b>
Accessing WinMain() Parameters</font></b><p>

<font size=3>
Though WINIO programs include a call to main(), you still 
have access to WinMain() parameters. WINIO saves them in global 
variables, along with other basic information.<p>

WINIO defines the following global variables:<p>
<dl>
<dd>HANDLE __hInst;
<dd>int __nCmdShow; 
<dd>HANDLE __hPrevInst;
<dd>HWND __hMainWnd; 
<dd>LPSTR __lpCmdLine;
<dd>char szModule[]; 
</dl></font><p>

<font size=4><b>
How the Compiler Generates WINIO Programs</font></b><p>

<font size=3>
When it compiles a program, the compiler generates symbols to call 
different versions of the C++ startup function. These startup 
functions are:<p>
<dl>
<dt>_arctused 
<dd>MS-DOS, Windows 3, and Windows NT executables 
<dt>_arctused_winc 
<dd>WINIO executables 
<dt>_arctused_dll 
<dd>Windows 3 and Windows NT DLLs
</dl></font><p>

The compiler determines what symbols to generate by examining 
the entry point, if any, it finds in a source file. If it finds a main() 
entry point, and the compilation is a Windows compilation, the 
compiler generates the external variable _arctused_winc, which 
is defined in the WINIO startup code. The WINIO startup code 
contains a WinMain() entry point that in turns calls your program's 
main().<p>

<b>Converting DOS Programs to WINIO</b><br>
To get a DOS program working as a WINIO program you simply 
compile it for Windows (either with the -W compiler option or by 
making it a Windows project in the IDDE), define the _WINIO 
macro, and link with the appropriate WINIO library.<p>

<b>Converting WINC Programs to WINIO</b><br>
The Digital Mars C++ run-time library no longer supports WINC. To 
convert your WINC programs to WINIO,<p>

° Convert all stdio.h function calls to the subset of 
stdio.h that WINIO supports (see "WINIO's 
Implementation of stdio.h Functions" below for a list).<p>

° Convert winc_variables to their corresponding winio_
function calls.</font><p>

<font size=4><b>
WINIO's Implementation of stdio.h Functions</font></b><p>

<font size=3>
WINIO's versions of gets(), printf(), and other stdio.h 
functions call the standard Windows message retrieval functions. 
WINIO supports the following functions from stdio.h:<br>

fgetchar<br>
fputchar<br>
getchar<br>
gets<br>
kbhit<br>
printf<br>
puts<br>
putchar<br>
ungets<br>
vprintf<p>

In WINIO programs, all input and output to and from stdio must 
go through the functions above. For example, you can use 
fgetchar(), but not fgetc(stdin). Also, stderr is not 
supported. scanf() is not supported, but you can use sscanf() 
in combination with gets(), like this:<br>
<pre>
	HWND hwnd;
	char buf[80]; 
	gets(buf);
	sscanf(buf, "% 04X", &hwnd); 
</pre>

<b>How WINIO Implements gets()</b><br>
Generally, the WINIO versions of these functions are similar to their 
stdio.h counterparts, and do not require additional 
documentation. However, the WINIO version of gets() differs 
significantly from the standard version, and is documented 
separately. Some other important differences are:<p>

° getchar() behaves differently by default than it does 
under DOS. The C construct<p>
<pre>
	int c; 
	while ((c = getchar()) != EOF) 
	    putchar(c); 
</pre>
does not work as expected under WINIO because 
characters input via getchar() are echoed to the screen 
by default. Thus the code above echoes each character 
twice. You could remove the call to putchar(), or call 
winio_setecho(FALSE).<p>

° Tests for EOF might now be inappropriate, because the 
user can double click on the window's Close box. You 
can code a standard C echo loop for WINIO like this:<p>
<pre>
	for (;;) 
	    getchar(); 
</pre>
° DOS displays the ASCII control codes 1 through 26 using 
the strings ^A through ^Z, except for 8 (backspace), 9 
(tab), 10 (line feed), 11 (vertical tab), 16 (toggle print), 
and 19 (stop output); these are interpreted but not 
displayed. WINIO does not print anything below ASCII 
code 32, (space). With the exception of ^P and ^S, 
WINIO does interpret the same characters in the same 
way as DOS, including interpreting ASCII 26 as EOF.</font><p>

<font size=4><b>
WINIO Functions</font></b><p>

<font size=3>
The WINIO and WMHANDLER functions are categorized by name in 
Chapter 2, and are also alphabetized and described along with the 
other Digital Mars C++ functions in this manual. 







<hr><!-- =========================================== -->

<a name="fail"><h2>fail</h2></a>


<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void fail(const char *fmt, ...); 
<p>

<b>
Description
</b><p>
The fail function displays a message box and terminates a WINIO 
program. fmt is a zero-terminated format string; fail accepts a 
variable number of arguments, which are interpreted according to 
fmt. <p>

The format string is a sequence of characters with embedded 
commands to manipulate the arguments that follow. For a list of 
valid commands see the documentation for fprintf. 
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
fprintf<br>
<p>

<hr><!-- =========================================== -->

<a name="ungets"><h2>ungets</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
char *ungets(char *string); 
<p>

<b>
Description
</b><p>
The WINIO version of the ungets function works like ungetc 
(which WINIO does not support), except that it pushes a string into 
the input stream, rather than a single character.<p> 

Calling ungets is equivalent to sending a WM_CHAR message to 
the current window for each character in the string. 
<p>

<b>
Return Value
</b><p>
A pointer to string if successful, or EOF if string cannot be 
pushed back. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#ungetc">ungetc</a>
<p>



<hr><!-- =========================================== -->

<a name="winio_about"><h2>winio_about</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_about(char *string);
<p>

<b>
Description
</b><p>
The winio_about function lets you edit the text in the default WINIO About dialog box. The string argument becomes the text displayed inside the About box. It can include newline characters.  Characters beyond the 512th character in the string are truncated.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_bufsize"><h2>winio_bufsize</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
WORD winio_bufsize(HWND hwnd);
<p>

<b>
Description
</b><p>
The winio_bufsize function returns the size in bytes of the buffer associated with the window hwnd.<p>

By default, the buffer for a WINIO program's main window is 32Kb.  For child windows, the default size is 8Kb. You set the size of the buffer with winio_setbufsize.
<p>

<b>
Return Value
</b><p>
The size of the buffer allocated for hwnd.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#winio_setbufsize">winio_setbufsize</a>
<p>

<hr><!-- =========================================== -->

<a name="winio_clear"><h2>winio_clear</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_clear(HWND hwnd);
<p>

<b>
Description
</b><p>
The winio_clear function clears the contents of the buffer associated with the window hwnd. Calling this function reinitializes the window and causes it to be redisplayed (blank).
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#winio_bufsize">winio_bufsize</a><br>
<a href="#winio_setbufsize">winio_setbufsize</a>
<p>

<hr><!-- =========================================== -->

<a name="winio_close"><h2>winio_close</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_close(HWND hwnd);
<p>

<b>
Description
</b><p>
The winio_close function closes the window hwnd by calling the Windows API function DestroyWindow(). Buffer space allocated for the window is freed.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_closeall"><h2>winio_closeall</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_closeall();
<p>

<b>
Description
</b><p>
The winio_closeall function closes all a WINIO application's windows by closing the main window. All associated buffer space is freed.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_current"><h2>winio_current</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
HWND winio_current();
<p>

<b>
Description
</b><p>
The winio_current function returns the handle of the current (active) WINIO window.
<p>

<b>
Return Value
</b><p>
The handle of the active window.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#winio_setcurrent">winio_setcurrent</a>
<p>

<hr><!-- =========================================== -->

<a name="winio_defwindowsize"><h2>winio_defwindowsize</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
DWORD winio_defwindowsize(DWORD size);
<p>

<b>
Description
</b><p>
The winio_defwindowsize function sets the default height and width in characters for all windows subsequently created via calls to winio_window(). The high order word holds the height and the low order word holds the width.
<p>

<b>
Return Value
</b><p>
The default window size that was in effect prior to the call to winio_defwindowsize.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_end"><h2>winio_end</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_end();
<p>

<b>
Description
</b><p>
The winio_end function signals WINIO that a task is terminating. It calls wmhandler_yield() until the number of windows is zero (meaning that the user has closed all the application's windows).  winio_end will only be called from WinMain() on return from main().
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_getinfo"><h2>winio_getinfo</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_getinfo(HWND hwnd, PWINIOINFO pwinfo);
<p>

<b>
Description
</b><p>
The winio_getinfo function returns information about the WINIO window hwnd in a WINIOINFO structure of the form:<br>
<pre>
typedef struct { 
   POINT dimChar;    // Character cell dimensions 
   POINT posCurr;    // Current position of text 
		     // cursor from top of buffer 
   RECT rectView;    // Visible part of buffer 
		     // (ht. lines, wid. chars) 
   long cDiscarded;  // Lines taken from buffer 
   }  WINIOINFO, *PWINIOINFO, FAR *LPWINIOINFO; 
</pre>

where RECT and POINT are standard Windows defined types defined in windows.h.<p>

The dimensions of a character cell depend on the window's font (see winio_setfont() for information).<p>

The current cursor position refers to the number of characters to the right of the first character in the buffer, and the number of lines down from the first line. The first position is 0, 0 (the top left corner).<p>

The visible part of the buffer is described in relation to the top left corner of the buffer; the left and right fields contain the numbers of the leftmost and rightmost visible columns in characters, and the top and bottom fields contain the line numbers of the topmost and bottommost visible lines.<p> 

The cDiscarded member refers to the number of lines of the display that have been discarded from the top of the buffer to create space for new text lines.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>


<hr><!-- =========================================== -->

<a name="winio_hmenufile"><h2>winio_hmenufile</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
HMENU winio_hmenufile(HWND hwnd);
<p>

<b>
Description
</b><p>
The winio_hmenufile function lets you modify a WINIO window's File menu.<p>

If hwnd was created with the WW_HASDMENU flag, winio_hmenufile returns the menu handle of the File pop-up menu. You can pass the handle to the Windows API functions InsertMenu() and AppendMenu() to add additional choices to the menu.<br>
<pre>
Note 
	You must use winio_setmenufunc() to register 
	the IDs of any menu items you add to a WINIO 
	application's File menu with a handler function. 
	Otherwise the application cannot regain control 
	after the user chooses that menu item.
</pre>

<b>
Return Value
</b><p>
The handle of the File menu on hwnd's menu bar, or NULL if the window has no menu.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#winio_setmenufunc">winio_setmenufunc</a><br>
<a href="#winio_window">winio_window</a>
<p>

<hr><!-- =========================================== -->

<a name="winio_hmenuhelp"><h2>winio_hmenuhelp</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
HMENU winio_hmenuhelp(HWND hwnd);
<p>

<b>
Description
</b><p>
The winio_hmenuhelp function lets you modify a WINIO window's Help menu.<p>

If hwnd was created with the WW_HASDMENU flag, winio_hmenuhelp returns the menu handle of the Help main menu item. You can pass the handle to the Windows API functions InsertMenu() and AppendMenu() to add choices to the menu.<br>
<pre>
Note 
      You must use winio_setmenufunc() to register 
      the IDs of any menu items you add to a WINIO 
      application's Help menu with a handler function. 
      Otherwise the application cannot regain control 
      after the user chooses that menu item.
</pre>

<b>
Return Value
</b><p>
The handle of the Help menu on hwnd's menu bar, or NULL if the window has no menu.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#winio_setmenufunc">winio_setmenufunc</a><br>
<a href="#winio_window">winio_window</a>
<p>

<hr><!-- =========================================== -->

<a name="winio_hmenumain"><h2>winio_hmenumain</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
HMENU winio_hmenumain(HWND hwnd);
<p>

<b>
Description
</b><p>
The winio_hmenumain function lets you modify a WINIO window's main menu.<p>

If hwnd was created with the WW_HASMENU flag, winio_hmenumain returns the menu handle of the main menu bar.
<p>

<b>
Return Value
</b><p>
The handle of hwnd's main menu, or NULL if the window has no menu.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#winio_setmenufunc">winio_setmenufunc</a><br>
<a href="#winio_window">winio_window</a>
<p>

<hr><!-- =========================================== -->

<a name="winio_home"><h2>winio_home</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_home(HWND hwnd);
<p>

<b>
Description
</b><p>
A call to the winio_home function is equivalent to the user pressing the HOME key. You use it to reposition the current text cursor position to the start (the top left corner) of hwnd's buffer.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#winio_setmenufunc">winio_setmenufunc</a><br>
<a href="#winio_window">winio_window</a>
<p>

<hr><!-- =========================================== -->

<a name="winio_init"><h2>winio_init</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
int winio_init();
<p>

<b>
Description
</b><p>
The winio_init function is used internally by the WINIO library to register the WINIO class and initialize global variables. Typically, it should only be called from WinMain() before main() is called.
<p>

<b>
Return Value
</b><p>
TRUE if successful; otherwise it returns FALSE and issues a warning. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_onclose"><h2>winio_onclose</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_onclose(HWND hwnd,<br>
DESTROY_FUNC exitfunc); 
<p>

<b>
Description
</b><p>
The winio_onclose function lets you handle situations where the user has closed the window from which the application expected input. It calls the WINIO library's WM_DESTROY handler. You need to call this function to inform you when the user clicks the system menu bar.<p>

hwnd is the handle of the window that closed. exitfunc is a callback function; its prototype must look like this:<p>

void callback(HWND hwnd);<p>

If exitfunc is NULL, the current callback function is disabled.<p>

winio_onclose is invoked after the window is closed. To ask the user whether he or she really wants to close hwnd, establish a WMHANDLER for the WM_CLOSE message.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_onpaintentry"><h2>winio_onpaintentry</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
PAINT_FUNC winio_onpaintentry(HWND hwnd,<br>
PAINT_FUNC paintfunc);
<p>

<b>
Description
</b><p>
The winio_onpaintentry function gives WINIO programs access to Graphic Device Interface (GDI). It allows an application to gain control after WINIO has obtained a display context, but before the internal winio_wmpaint() function starts painting the window.<p>

hwnd is the handle of the window that closed. paintfunc is a callback function; its prototype must look like this:<p>

BOOL callback(HWND hwnd, HDC hdc, PAINTSTRUCT<br>
*pps, PWINIOINFO pwi);<p>

where hwnd is the window to be updated, hdc is the display context returned by the Windows API BeginPaint() function, pps is a
pointer to the PAINTSTRUCT filled in by the BeginPaint() call, and pwi is a
pointer to a WINIOINFO structure (see winio_getinfo()).<p>

paintfunc can modify any display context or painting operation. If it returns TRUE, WINIO updates the window; if it returns FALSE, WINIO will not update the window, leaving it empty of buffer text. If paintfunc is NULL, the current callback function is disabled.
<p>

<b>
Return Value
</b><p>
PAINT_FUNC
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_onpaintexit"><h2>winio_onpaintexit</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
PAINT_FUNC winio_onpaintexit(HWND hwnd,<br>
PAINT_FUNC paintfunc);
<p>

<b>
Description
</b><p>
The winio_onpaintexit function works like<br>
winio_onpaintentry, except that it is called just before WINIO calls the Windows API function EndPaint to release the display context.<p>

Unless a callback function registered using winio_onpaintentry has returned FALSE, winio_onpaintexit() is invoked after the window has been updated with text from the window's buffer.<p>

hwnd is the handle of the window that closed. paintfunc is a callback function; its prototype must look like this:<p>

BOOL callback(HWND hwnd, HDC hdc, PAINTSTRUCT<br>
*pps, PWINIOINFO pwi);<p>

where hwnd is the window to be updated, hdc is the display context returned by
the Windows API BeginPaint() function, pps is a pointer to the PAINTSTRUCT
filled in by the BeginPaint() call, and pwi is a pointer to a WINIOINFO
structure (see winio_getinfo()).<p>

paintfunc can modify any display context or painting operation.  Its return
value is ignored. If paintfunc is NULL, the current callback function is
disabled.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_openwindows"><h2>winio_openwindows</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
int winio_openwindows();
<p>

<b>
Description
</b><p>
The winio_openwindows function returns the number of WINIO windows that are open when it is called.
<p>

<b>
Return Value
</b><p>
The number of open WINIO windows.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_resetbusy"><h2>winio_resetbusy</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_resetbusy();
<p>

<b>
Description
</b><p>
The winio_resetbusy function resets the WINIO cursor to the shape it had prior to the call, and releases the cursor. You use it in combination with winio_setbusy to block user input.<p>

When you call winio_setbusy, an internal counter is incremented. Calling winio_resetbusy decrements the counter.  winio_resetbusy only releases the cursor if the counter's value is zero. 
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#winio_setbusy">winio_setbusy</a>
<p>

<hr><!-- =========================================== -->

<a name="winio_setbufsize"><h2>winio_setbufsize</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
WORD winio_setbufsize(HWND hwnd, WORD bufsize, BOOL clear); 
<p>

<b>
Description
</b><p>
The winio_setbufsize function sets the size of the buffer for the window hwnd. If clear is FALSE, the buffer cannot be smaller than hwnd's current buffer size.. If clear is TRUE, hwnd's buffer is cleared, and it can be any size greater than 4Kb.<p>

The default buffer size for a WINIO main window is 32Kb, and 8Kb for a child window.
<p>

<b>
Return Value
</b><p>
The size in bytes of the new buffer. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_setbusy"><h2>winio_setbusy</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_setbusy(); 
<p>

<b>
Description
</b><p>
The winio_setbusy function lets you block user input during an operation. It captures the cursor and changes its shape to the standard Windows "hourglass." To release the capture and return the cursor to its previous shape, call winio_resetbusy.<p>

When you call winio_setbusy, an internal counter is incremented. Calling winio_resetbusy decrements the counter.  winio_resetbusy only releases the cursor if the counter's value is zero.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#winio_resetbusy">winio_resetbusy</a>
<p>

<hr><!-- =========================================== -->

<a name="winio_setcurrent"><h2>winio_setcurrent</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
HWND winio_setcurrent(HWND hwnd);
<p>

<b>
Description
</b><p>
The winio_setcurrent function makes hwnd the current window. Calls to stdio operate on the current window.
<p>

<b>
Return Value
</b><p>
The handle that was current prior to the winio_setcurrent call.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_setecho"><h2>winio_setecho</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
BOOL winio_setecho(HWND hwnd, BOOL bEcho);
<p>

<b>
Description
</b><p>
The winio_setecho function controls echoing of the standard input to the standard output.hwnd is the window you want to be stdout (the active window). If bEcho is TRUE, stdin is echoed to stdout (the WINIO default). If bEcho is FALSE, echoing to stdout is disabled.
<p>

<b>
Return Value
</b><p>
The setting for bEcho that was in effect before the call to winio_setecho. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_setfont"><h2>winio_setfont</h2></a>

<font size=3><b>
Header
</b><p>
winio.h 
<p>

<b>
Prototype
</b><p>
WORD winio_setfont(HWND hwnd, WORD wFont);
<p>

<b>
Description
</b><p>
The winio_setfont function changes the font currently in use in the window hwnd. Only standard Windows system fonts are supported.<p>

wFont can be one of the following constants defined in windows.h: ANSI_FIXED_FONT, OEM_FIXED_FONT, and SYSTEM_FIXED_FONT.
<p>

<b>
Return Value
</b><p>
The font that was in effect before the call to winio_setfont. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_setlinefn"><h2>winio_setlinefn</h2></a>

<font size=3><b>
Header
</b><p>
winio.h 
<p>

<b>
Prototype
</b><p>
LINEHANDLER winio_setlinefn(HWND hwnd, LINEHANDLER linefunc);
<p>

<b>
Description
</b><p>
The winio_setlinefn function installs a handler, which is invoked when the user double-clicks on a line of text in hwnd. You can disable such a handler with a call to winio_linefn(hwnd, NULL).<p>

linefunc is a callback function of type LINEHANDLER; its prototype must look like this:<p>

void callback(HWND hwnd, LPSTR lpstrLine,<br>
int nLineNo);<p>

where lpstrLine is a pointer to the line of text in the buffer that the user double-clicked on, and nLineNo is the line number of that line, where line 0 is the first line in the buffer. If text is discarded from the top of the buffer to create space for new text lines, nLineNo will decrease accordingly. However, you can use the cDiscarded member of the WINIOINFO structure (see winio_getinfo) to obtain a line number that will not change when text is discarded.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_setmenufunc"><h2>winio_setmenufunc</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
MENU_FUNC winio_setmenufunc(HWND hwnd, int nID, MENU_FUNC menufunc); 
<p>

<b>
Description
</b><p>
The winio_setmenufunc function installs a handler, which is 
invoked when the user selects a menu item that you added to the 
default WINIO main menu or File menu. If you do not set up a 
handler for a new menu item, your WINIO application cannot know 
the user has chosen it.hwnd is the window where the item was 
added.<p>

nID is the item's ID. menufunc is a callback function of type 
MENU_FUNC; its prototype must look like this:<p>

   void callback(HWND hwnd, int nID);<p>
 
where hwnd is a window and nID is a menu ID.<p>

Note<br>
	You must allocate menu ids in order from 1 through 
	32. This permits a total of up to 32 additional menu 
	items per window.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_setpaint"><h2>winio_setpaint</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
BOOL winio_setpaint(HWND hwnd, BOOL bPaint); 
<p>

<b>
Description
</b><p>
The winio_setpaint function turns automatic updating of the display on and off. It lets you delay updating the text in a window, so WINIO applications can repaint the display less frequently (and more smoothly).<p>

If bPaint is FALSE, hwnd is not updated when new text is added to the buffer. The text is updated (using the stdio functions) when winio_setpaint is called again with bPaint set to TRUE.<p>

WINIO does not yield control to other applications between a winio_setpaint(FALSE) and a winio_setpaint(TRUE).  You can call this function if your code is working with a data structure that can be changed by other applications (for example, the Windows global heap).
<p>

<b>
Return Value
</b><p>
The setting for bPaint that was in effect before the call to winio_setpaint.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<hr><!-- =========================================== -->

<a name="winio_settitle"><h2>winio_settitle</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
void winio_settitle(HWND hwnd, char *strTitle); 
<p>

<b>
Description
</b><p>
The winio_settitle function lets you change the title bar text for hwnd to strTitle. The default title bar text is the module name; if the window is a main window, any command line arguments are also included.<p>

winio_settitle works by calling the Windows API function SetWindowText().
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32
<p>

<hr><!-- =========================================== -->

<a name="winio_warn"><h2>winio_warn</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
BOOL winio_warn(BOOL bConfirm, char *strCaption, const char *fmt, ...); 
<p>

<b>
Description
</b><p>
The winio_warn function displays a Windows-type message box.  If bConfirm is FALSE, the message box will have only an OK button, and winio_warn will always return TRUE. If bConfirm is TRUE, the message box will have both an OK button and a Cancel button, and winio_warn will return FALSE if the user chooses Cancel, and TRUE otherwise.<p>

strCaption specifies the title bar text for the message box. fmt is a zero-terminated format string; winio_warn accepts a variable number of arguments, which are interpreted according to fmt. fmt is a sequence of characters with embedded commands. For a list of valid commands see the fprintf function.
<p>

<b>
Return Value
</b><p>
TRUE if the user chooses OK; FALSE if the user chooses Cancel. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
fprintf
<p>

<hr><!-- =========================================== -->

<a name="winio_window"><h2>winio_window</h2></a>

<font size=3><b>
Header
</b><p>
winio.h
<p>

<b>
Prototype
</b><p>
HWND winio_window(LPSTR lpstrTitle, WORD wBufSize, WORD wFlags);
<p>

<b>
Description
</b><p>
The winio_window function lets a WINIO application create additional windows other than its main window.<p>

lpstrTitle specifies the window's title bar text. wBufSize specifies the size in bytes of the buffer to allocate for the window. The buffer is allocated from global memory and determines how much information about the window's display history is maintained. If wBufSize is 0, WINIO uses the default buffer size of 8Kb; otherwise the specifed number of bytes are allocated. If wBufSize is less than 4Kb, it is rounded up to 4Kb.<p>

wFlags is a combination of zero or more of the following lags, combined in a series of logical OR operations:<p>

<dl>
<dt>WW_HASMENU(0x0001) 
<dd>Give the new window a default WINIOmenu (see winio_setmenufunc() forinformation on modifying a default menu).
<dt>WW_EXITALLOWED (0x0002) 
<dd>Enable the Exit option on the File popup menu. If this flag is used, the user can exit the application from any window. If WW_HASMENU is not used, this flag is ignored. 
<dt>WW_STAYSONTOP (0x0004) 
<dd>By default, WINIO windows are "owned pop-ups," not child windows. Thus, when the main WINIO window is active, it can cover part or all of its pop-ups, and minimizing the main window does not automatically minimize the pop-ups. Use this flag to make all new windows true child windows and avoid these behaviors.
</dl><p>

<b>
Return Value
</b><p>
The new window's handle. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#winio_setmenufunc">winio_setmenufunc</a><br>
<p>

<hr><!-- =========================================== -->

<a name="wmhandler_create"><h2>wmhandler_create</h2></a>

<font size=3><b>
Header
</b><p>
winio.h<br>
wmhandlr.h
<p>

<b>
Prototype
</b><p>
WMTAB wmhandler_create();
<p>

<b>
Description
</b><p>
The wmhandler_create function allocates memory for the arrays that WMHANDLER applications use to store pointers to the functions installed to handle messages for a window. (In other words, it allocates and initializes a WM_handler table.)<p>

Your code should store the pointer that wmhandler_create returns in the wmTab field in the CREATEPARAMS structure (see wmhandler_wndproc()). The wmhandler_wndproc() function retrieves this pointer along with a 32-bit value (usually a far pointer) supplied by the application when the application receives a WM_CREATE message, and places them in the extra-data area associated with the window. Thus, wmhandler_wndproc() uses the WMTAB pointer returned by wmhandler_create to locate a handler for all messages a window receives.
<p>

<b>
Return Value
</b><p>
A pointer to the memory area where the message handlers are stored.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#wmhandler_wndproc">wmhandler_wndproc</a><br>
<p>

<hr><!-- =========================================== -->

<a name="wmhandler_destroy"><h2>wmhandler_destroy</h2></a>

<font size=3><b>
Header
</b><p>
winio.h<br>
wmhandlr.h
<p>

<b>
Prototype
</b><p>
void wmhandler_destroy(HWND hwnd); 
<p>

<b>
Description
</b><p>
The wmhandler_destroy function works in combination with wmhandler_create. It retrieves the WMTAB pointer from hwnd that wmhandler_create returns, and frees the associated memory.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#wmhandler_create">wmhandler_create</a><br>
<p>

<hr><!-- =========================================== -->

<a name="wmhandler_get"><h2>wmhandler_get</h2></a>

<font size=3><b>
Header
</b><p>
winio.h<br>
wmhandlr.h
<p>

<b>
Prototype
</b><p>
WMHANDLER wmhandler_get(HWND hwnd, WORD wMsg); 
<p>

<b>
Description
</b><p>
The wmhandler_get function returns a pointer to the function that is currently handling the message wMsg for hwnd.<p>

wmhandler_get never returns NULL; messages for which handlers have not been installed are handled by an internal function that passes them to the Windows API function DefWindowProc().
<p>

<b>
Return Value
</b><p>
A pointer to the handler for wMsg. (See wmhandler_set for a description of the WMHANDLER type).
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#wmhandler_set">wmhandler_set</a><br>
<p>

<hr><!-- =========================================== -->

<a name="wmhandler_hwnd"><h2>wmhandler_hwnd</h2></a>

<font size=3><b>
Header
</b><p>
winio.h<br>
wmhandlr.h
<p>

<b>
Prototype
</b><p>
HWND wmhandler_hwnd(char *strTitle); 
<p>

<b>
Description
</b><p>
The wmhandler_hwnd function creates a window that a WMHANDLER application uses internally (it is not visible to the user). strTitle is the internal name for the window.<p>

A table of message handlers is associated with the window. You can send messages to the window, and use its handle in calls to wmhandler_set(). A window created with wmhandler_hwnd is useful when you want to handle events without a corresponding user interface element.
<p>

<b>
Return Value
</b><p>
The handle to the newly created window. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<p>

<hr><!-- =========================================== -->

<a name="wmhandler_set"><h2>wmhandler_set</h2></a>

<font size=3><b>
Header
</b><p>
winio.h<br>
wmhandlr.h
<p>

<b>
Prototype
</b><p>
WMHANDLER wmhandler_set(HWND hwnd, WORD message, WMHANDLER wmhandler); 
<p>

<b>
Description
</b><p>
The wmhandler_set function installs a function wmhandler to handle messages of type message that are sent to the window hwnd. message can be any number, even a number greater than WM_USER (0x400). message can also be a number returned by the Windows API function RegisterWindowMessage(). However, a WMHANDLER program can install no more than 16 handlers for messages whose numbers are greater than 0x400. wmhandler is a callback function of type WMHANDLER; its prototype must look like this:<br>
<pre>
     long wmhandler(HWND hwnd, unsigned message,
     WORD wParam, DWORD lParam); 
</pre>
The callback function should return whatever is appropriate for the type of WM_message it is handling. If wmhandler is NULL, an internal handler passes the message to the Windows API function DefWIndowProc().<p>

The callback function can chain onto the handler wmhandler_set returns if required. If a WMHANDLER application handles one of the WM_messages also handled by WINIO, the callback function must chain. WINIO installs handlers for the following messages:<br>
<pre>
WM_CHAR 	WM_KEYDOWN 	  WM_SETFOCUS 
WM_COMMAND  	WM_KILLFOCUS 	  WM_SIZE 
WM_DESTROY 	WM_LBUTTONDBLCLK  WM_VSCROLL 
WM_HSCROLL 	WM_PAINT 
</pre>
If wmhandler_set() is used in a non-WINIO program, hwnd must use wmhandler_wndproc() as its window proceudre, and it must have a WMTAB pointer as the first four bytes of associated user data (see wmhandler_create).
<p>

<b>
Return Value
</b><p>
The handler in effect before the call to wmhandler_set. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 




<br><br><br><br>

</td></table>





<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

