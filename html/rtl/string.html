
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - string.h
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:16 2006
</div>
</div>

<!-- Generated by Ddoc from string.d -->



<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>string.h</h1>

<ul>
	<li><a href="#memchr"><b>memchr, _fmemchr</b></a>
	<li><a href="#memcmp"><b>memcmp, _fmemcmp</b></a>
	<li><a href="#_memccpy"><b>_memccpy, _fmemccpy</b></a>
	<li><a href="#memcpy"><b>memcpy, _fmemcpy</b></a>
	<li><a href="#_memicmp"><b>_memicmp, _fmemicmp</b></a>
	<li><a href="#memmove"><b>memmove, _fmemmove</b></a>
	<li><a href="#memset"><b>memset, _fmemset, setmem</b></a>
	<li><a href="#_movedata"><b>_movedata</b></a>
	<li><a href="#movmem"><b>movmem</b></a>
	<li><a href="#_strdup"><b>_strdup, _fstrdup</b></a>
	<li><a href="#_stricmp"><b>_stricmp, _fstricmp</b></a>
	<li><a href="#_strlwr"><b>_strlwr, _fstrlwr</b></a>
	<li><a href="#strncmpi"><b>strncmpi, strncmpl, _strnicmp, _fstrnicmp</b></a>
	<li><a href="#_strnset"><b>_strnset _fstrnset</b></a>
	<li><a href="#_strrev"><b>_strrev, _fstrrev</b></a>
	<li><a href="#_strset"><b>_strset, _fstrset</b></a>
	<li><a href="#_strtime"><b>_strtime</b></a>
	<li><a href="#_strupr"><b>_strupr, _fstrupr</b></a>
	<li><a href="#_swab"><b>_swab</b></a>
	<li><a href="#stpcpy"><b>stpcpy</b></a>
	<li><a href="#strcat"><b>strcat, _fstrcat</b></a>
	<li><a href="#strchr"><b>strchr, _fstrchr</b></a>
	<li><a href="#strcmp"><b>strcmp Functions</b></a>
	<li><a href="#strcoll"><b>strcoll</b></a>
	<li><a href="#strcpy"><b>strcpy, _fstrcpy</b></a>
	<li><a href="#strcspn"><b>strcspn, _fstrcspn</b></a>
	<li><a href="#strerror"><b>strerror</b></a>
	<li><a href="#strlen"><b>strlen, _fstrlen</b></a>
	<li><a href="#strncat"><b>strncat, _fstrncat</b></a>
	<li><a href="#strncmp"><b>strncmp, _fstrncmp</b></a>
	<li><a href="#strncmpi"><b>strncmpi, strncmpl, _strnicmp, _fstrnicmp</b></a>
	<li><a href="#strncpy"><b>strncpy, _fstrncpy</b></a>
	<li><a href="#strpbrk"><b>strpbrk, _fstrpbrk</b></a>
	<li><a href="#strrchr"><b>strrchr, _fstrrchr</b></a>
	<li><a href="#strspn"><b>strspn, _fstrspn</b></a>
	<li><a href="#strstr"><b>strstr, _fstrstr</b></a>
	<li><a href="#strtok"><b>strtok, _fstrtok</b></a>
	<li><a href="#strxfrm"><b>strxfrm</b></a>
	<li><a href="#_sys_errlist"><b>_sys_errlist</b></a>
	<li><a href="#_sys_nerr"><b>_sys_nerr</b></a>
</ul>

<!-- =========================================== -->

<hr> <h2><a name="memchr">memchr, _fmemchr</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h<br>
memory.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *memchr(const void *buf1, int c, size_t count);<br>
void __far *__far _fmemchr(const void __far *buf1, int c, size_t count); 
</tt></dd>

<dt><b>Description</b></dt> <dd>memchr searches in the buffer, buf, for a byte with the value of c. 
The search continues for count bytes or until a value of c is 
encountered. _fmemchr is a model-independent (large-model) form 
of the memchr function. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fmemchr
</dd>

<dt><b>Return Value</b></dt> <dd>memchr and _fmemchr return a pointer (or a far pointer) to the first 
location of c in buf. Otherwise, these functions return NULL. 
</dd>

<dt><b>Compatibility</b></dt> <dd>memchr: DOS, Windows 3. x, Phar Lap/ DOSX, Win32<br>
_fmemchr: DOS, Windows 3. x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#memcpy">memcpy</a><br>
<a href="#memcmp">memcmp</a><br>
<a href="#memset">memset</a><br>
<a href="#strcmp Functions">strcmp Functions</a><br>
<a href="#strcat">strcat</a><br>
<a href="#_strset">_strset</a><br>
<a href="#strrchr">strrchr</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for memchr */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char test[] = "Test String"; 

void main ()
{   
   char search = 'S', *result; 

   printf (" The test string is \"% s\"\n", test);
   printf (" memchr() looking for 'S'\n"); 
   result = memchr(test, search, 12);
   if (result != NULL) 
      printf (" Character 'S' found at (% d)\n",
		result -test + 1); 

   else
      printf (" Character 'S' was not found in 
		search string\n");
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">The test string is "Test String"
memchr() looking for 'S'
Character 'S' found at (6) 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="memcmp">memcmp, _fmemcmp</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h<br>
memory.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int memcmp(const void *buf1, const void *buf2, size_t count);
int __far _fmemcmp(const void __far *buf1, const void __far *buf2, size_t count);
</tt></dd>

<dt><b>Description</b></dt> <dd>memcmp compares each successive byte pointed to by pointer buf1 
with the corresponding byte pointed to by buf2 until they do not 
have the same value or until the number of bytes specified in count 
have been compared. memcmp returns an integer less than, equal to, 
or greater than zero, depending on whether the last byte compared 
in the buffer pointed to by buf1 is less than, equal to, or greater 
than the corresponding byte pointed to by buf2.<p>

_fmemcmp is a model-independent (large-model) form of the 
memcmp function. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fmemcmp
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return the following types of values: less than 0 (if 
buf1 is less than buf2), 0 (if buf1 equals buf2), or greater than 0 
(if buf1 is greater than buf2.) 
</dd>

<dt><b>Compatibility</b></dt> <dd>memcmp: DOS, Windows 3. x, Phar Lap/ DOSX, Win32<br>
_fmemcmp: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#memset">memset</a><br>
<a href="#_memicmp">_memicmp</a><br>
<a href="#memchr">memchr</a><br>
<a href="#strcat">strcat</a><br>
<a href="#strrchr">strrchr</a><br>
<a href="#strcmp Functions">strcmp Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for memcmp */ 

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char test1[] = "This is test string 1";
char test2[] = "This is test string 2"; 

void main ()
{   
   int result; 

   printf (" Test string 1 is \"% s\"\n", test1);
   printf (" Test string 2 is \"% s\"\n", test2); 

   printf ("\nComparing 1 and 2 for 20 bytes\n");
   result = memcmp(test1, test2, 20); 
   if (! result)
      printf (" 1 and 2 are"); 
   else
      printf (" 1 and 2 are not"); 
   printf (" the same for 20 bytes\n"); 

   printf ("\nComparing 1 and 2 for 21 bytes\n");
   result = memcmp(test1, test2, 21); 
   if (! result)
      printf (" 1 and 2 are"); 
   else
      printf (" 1 and 2 are not"); 
   printf (" the same for 21 bytes\n");
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Test string 1 is "This is test string 1"
Test string 2 is "This is test string 2"

Comparing 1 and 2 for 20 bytes
1 and 2 are the same for 20 bytes

Comparing 1 and 2 for 21 bytes
1 and 2 are not the same for 21 bytes 
</pre></dd>

 </dl>

<!-- =========================================== -->


<hr> <h2><a name="_memccpy">_memccpy, _fmemccpy</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h<br>
memory.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *_memccpy(void *dest, void *src, int c, unsigned int count);<br>
void __far *__far _fmemccpy(void __far *dest, void __far *src, int c, unsigned int count);
</tt></dd>

<dt><b>Description</b></dt> <dd>These functions copy a block of memory from src to dest. The 
copy operation stops when either the character c has been copied, 
or count bytes have been copied. <p>

The _fmemccpy function is a model-independent (large-model) 
form of the _memccpy y function. 
</dd>

<dt><b>Synonym</b></dt> <dd>Functions:  memccpy, fmemccpy
</dd>

<dt><b>Return Value</b></dt> <dd>If the character c is copied, these functions return a pointer to the 
byte in dest immediately following the byte that contains c. If c is 
not copied, these functions return NULL. 
</dd>

<dt><b>Compatibility</b></dt> <dd>_memccpy: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br>
_fmemccpy: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="memchr">memchr</a><br>
<a href="memcpy">memcpy</a><br>
<a href="memset">memset</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _memccpy */ 

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char string[60] = "Now is the time for all good
men"; 

void main ()
{   

   char buf[61];
   char *dest; 

   dest = _memccpy (buf, string, 'l', 60);
   if (dest != NULL) 
      *dest = '\0'; 

   printf (" Should have copied to the first
	   \" l\" or until the end, "); 
   printf (" which evercame first.
	     Result is:\n% s\n", buf); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Should have copied to the first "l" or until the end, which evercame first. Result is:

Now is the time for al 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="memcpy">memcpy, _fmemcpy</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h<br>
memory.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *memcpy(void *buf1, const void *buf2, size_t count);<br>
void __far *__far _fmemcpy(void __far *buf1, const void __far *buf2, size_t count); 
</tt></dd>

<dt><b>Description</b></dt> <dd>memcpy copies the number of characters specified in count from 
buf2 to buf1. buf1 is returned. Although memcpy is faster than 
memmove, memcpy does not ensure that the source bytes in the 
overlapping region are copied before being overwritten. In this 
situation, use memmove. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fmemcpy
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return buf1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>_memcpy: DOS, Windows 3. x, Phar Lap/ DOSX, Win32<br>
_fmemcpy: DOS, Windows 3. x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#memcmphtml">memcmp</a><br>
<a href="#memset">memset</a><br>
<a href="#memcmp">memcmp</a><br>
<a href="#memmove">memmove</a><br>
<a href="#strcmp Functions">strcmp Functions</a><br>
<a href="#strcat">strcat</a><br>
<a href="#_strset">_strset</a><br>
<a href="#strrchr">strrchr</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for memcpy */ 

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char test1[] = "Sample String.";
char test2[15]; 

void main ()
{   
   printf (" Copying test1 to test2\n");
   memcpy (test2, test1, 15); 
   printf (" Result is \"% s\"\n", test2);
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Copying test1 to test2
Result is "Sample String." 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_memicmp">_memicmp, _fmemicmp</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h<br>
memory.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _memicmp(const void *buf1, const void *buf2, size_t count);<br>
int __far _fmemicmp(const void __far *buf1, const void __far *buf2, size_t count); 
</tt></dd>

<dt><b>Description</b></dt> <dd>These functions compare the first count characters from buf1 with 
those in buf2 on a byte for byte basis, without reference to the case 
of the letters being compared. Uppercase and lowercase letters are 
considered to be equivalent. All uppercase (capital) letters in both 
buf1 and buf2 are converted to lowercase before the comparison 
is done. This function is identical to memcmp except it ignores case.<p>

Function _fmemicmp is a model-independent (large-model) form 
of the _memicmp function. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fmemicmp
</dd>

<dt><b>Return Value</b></dt> <dd>These functions return an integer value which depends on the 
relationship of buf1 to buf2, as follows:
<p>
<dl>
<b>Returns a value. . ./if. . .</b>
<dt>&lt;0
<dd>buf1 less than buf2
<dt>=0
<dd>buf1 identical to buf2
<dt>&gt;0
<dd>buf1 greater than buf2 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>_memicmp: DOS, Windows 3. x, Phar Lap/ DOSX, Win32<br>
_fmemicmp: DOS, Windows 3. x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#memchr">memchr</a><br>
<a href="#memcpy">memcpy</a><br>
<a href="#memcmp">memcmp</a><br>
<a href="#memset">memset</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _memicmp */ 

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char test1[] = "this is test string 1";
char test2[] = "THIS IS TEST STRING 2"; 

void main ()
{   
   int result; 

   printf (" Test string 1 is \"% s\"\n", test1);
   printf (" Test string 2 is \"% s\"\n", test2); 

   printf ("\nComparing 1 and 2 for 20 bytes\n");
   result = _memicmp(test1, test2, 20); 
   if (! result)
      printf (" 1 and 2 are"); 
   else
      printf (" 1 and 2 are not"); 

   printf (" the same for 20 bytes\n"); 
   printf ("\nComparing 1 and 2 for 21 bytes\n");
   result = _memicmp(test1, test2, 21); 
   if (! result)
      printf (" 1 and 2 are"); 
   else
      printf (" 1 and 2 are not"); 
   printf (" the same for 21 bytes\n");
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Test string 1 is "this is test string 1"<br>
Test string 2 is "THIS IS TEST STRING 2"<p>

Comparing 1 and 2 for 20 bytes<br>
1 and 2 are the same for 20 bytes<p>

Comparing 1 and 2 for 21 bytes<br>
1 and 2 are not the same for 21 bytes
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="memmove">memmove, _fmemmove</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *memmove(void *buf1, const void *buf2, size_t count);<br>
void __far *__far _fmemmove(void __far *buf1, const void __far *buf2, size_t count); 
</tt></dd>

<dt><b>Description</b></dt> <dd>memmove copies the number of characters specified in count from 
buf2 to buf1. memmove, slower than memcpy, can handle 
overlapping moves.<p>

_fmemmove is a model-independent (large-model) form memmove. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fmemmove
</dd>

<dt><b>Return Value</b></dt> <dd>buf1 is returned. 
</dd>


<dt><b>Compatibility</b></dt> <dd>memmove: DOS, Windows 3. x, Phar Lap/ DOSX, Win32<br>
_fmemmove: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#memcpy">memcpy</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for memmove */ 

#include &lt;string.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

char test1[] = "Sample String.";
char test2[15]; 

void main ()
{   
   printf (" Copying test1 to test2\n");
   memmove (test2, test1, 15); 
   printf (" Result is \"% s\"\n", test2); } 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Copying test1 to test2<br>
Result is "Sample String." 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="memset">memset, _fmemset, setmem</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h<br>
memory.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void *memset(void *buf, int val, size_t count);<br>
void __far *__far _fmemset(void __far *buf, int val, size_t count);<br>
void setmem(void *buf, size_t count, int val);
</tt></dd>

<dt><b>Description</b></dt> <dd>memset sets the first count characters pointed to by buf to the 
value specified by val. It returns buf. Function_fmemset is a 
model-independent (large-model) form memset. setmem is just a macro
for memset, reversing the second and third parameters. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fmemset
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return buf. 
</dd>

<dt><b>Compatibility</b></dt> <dd>memset: DOS, Windows 3. x, Phar Lap/ DOSX, Win32<br>
_fmemset: DOS, Windows 3. x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#strcat">strcat</a><br>
<a href="#_strset">_strset</a><br>
<a href="#strrchr">strrchr</a><br>
<a href="#strcmp">strcmp Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for memset */ 

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char buffer[20]; 

void main ()
{   
   printf (" buffer before memset: \"% s\"\n", buffer); 
   memset (buffer, 'x', 6);
   printf (" buffer after memset: \"% s\"\n", 
	     buffer);
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">buffer before memset:<br>
"" buffer after memset: "xxxxxx" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_movedata">_movedata</a></h2><dl> 

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _movedata(unsigned srcseg, unsigned srcoff, unsigned dstseg, unsigned dstoff, size_t numbytes); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _movedata function moves numbytes bytes from the source 
address specified by segment srcseg and offsets srcoff to the 
destination address specified by segment dstseg and offset 
dstoff.<p>

Use _movedata to move data between segments. For normal intra-segment 
movement of data, use memcpy or memmove instead. 
_movedata does not handle overlapping moves correctly. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  movedata
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>_FP Functions<br>
<a href="#memcpy">memcpy</a><br>
<a href="#memmove">memmove</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _movedat */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;dos.h&gt;

void main ()
{   
   char __far *src = "this is a test";
   char __far *dest; 

   if ((dest = malloc (80)) != NULL)
   {   
      _movedata (_FP_SEG(src), _FP_OFF(src),
      _FP_SEG(dest), _FP_OFF(dest), 
      strlen(src) + 1);
   printf (" The source is %p and contains 
	      \"% s\"\n", src, src);
   printf (" The destination is %p and contains 
	      \"% s\"\n", dest, dest);
   free(dest); 
   }
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The source is 207B: 0042 and contains "this is a test"<br> 
The destination is 307C: 01CA and contains "this is a test" 
</pre></dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="movmem">movmem</a></h2><dl> 

<dt><b>Header</b></dt> <dd>memory.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void movmem(const void *src, void *dest, size_t length);  
</tt></dd>

<dt><b>Description</b></dt> <dd>The movmem function moves a block of data from src to dest. The 
length argument indicates the number of bytes to copy. This 
function moves the data correctly, even if the blocks overlap. 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_movedata">_movedata</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for movmem */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;mem.h&gt;

void main ()
{   
   char *src = "This is a test";
   char *dest; 
   int len; 

   len = strlen (src) + 1;
   dest = malloc (len); 
   movmem(src, dest, len);
   printf(" The source string is \"% s\".\nThe 
	    destination string is \"% s\"\n", src, dest); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The source string is "This is a test".<br>
The destination string is "This is a test" 
</pre></dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_strdup">_strdup, _fstrdup</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_strdup(const char *string);<br>
char __far *__far _fstrdup(<br> 
const char __far *string); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _strdup and _fstrdup functions allocate memory with a call 
to malloc, copy the string into this memory, and return a pointer 
to the memory containing the string. The functions return NULL if 
memory cannot be allocated.<p>

The _fstrdup function provides additional control over the heap 
used for string duplication. The function returns a far pointer to a 
copy of the string allocated from the far heap. 
</dd>

<dt><b>Synonym</b></dt> <dd>Functions:  strdup, fstrdup
</dd>

<dt><b>Return Value</b></dt> <dd>All functions return a pointer to the allocated memory containing the 
string. NULL is returned if memory cannot be allocated. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strdup: DOS Windows 3.x Phar Lap/ DOSX Win32<br>
_fstrdup: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _strdup */ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt; 

void main () 
{   
   char *str1 = "This is a test string"; 
   char *str2; 

   printf (" The original string: 
	   \"% s\"\n", str1); 
   str2 = _strdup (str1); 
   printf (" The string from _strdup(): 
	   \"% s\"\n", str2); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The original string: "This is a test string"<br>
The string from _strdup(): "This is a test<br> 
string" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_stricmp">_stricmp, _fstricmp</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _stricmp(const char *string1, const char *string2);<br>
int __far _fstricmp(const char __far *string1, const char __far *string2); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _stricmp function compares the lowercase versions of the strings specified in string1 and string 2. The comparison begins with the first character of each string and continues until corresponding characters differ or until the ends of the strings are reached.<p>

The _fstricmp function is a model-independent (large model) form of _stricmp. The functions are identical, except that the _fstricmp arguments are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  stricmp, fstricmp
</dd>

<dt><b>Return Value</b></dt> <dd><dl>
<b>Returns... /if...</b>
<dt>&lt; 0 
<dd>string1 is less than string2 
<dt>= 0 
<dd>string1 is equal to string2 
<dt>&gt; 0 
<dd>string1 is greater than string2 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>stricmp: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br>
_fstricmp: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#strcat">strcat</a><br>
<a href="#strcpy">strcpy</a><br>
<a href="#strncat">strncat</a><br>
<a href="#strncmp">strncmp</a><br>
<a href="#strncpy">strncpy</a><br>
<a href="#strncmpi">strncmpi</a><br>
<a href="#strncmpl">strncmpl</a><br>
<a href="#_strnicmp">_strnicmp</a><br>
</dd>

<dt><b>Example</b></dt> <dd>
See strcmp
</dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_strlwr">_strlwr, _fstrlwr</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_strlwr(char *string);<br>
char __far *__far _fstrlwr(char __far *string); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _strlwr function converts upper case characters in the 
string argument to lower case.<p>

The _fstrlwr function is a model-independent (large model) form 
of _strlwr. They are identical, except that the _fstrlwr 
argument and return values are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  strlwr, fstrlwr
</dd>

<dt><b>Return Value</b></dt> <dd>Return a pointer to the converted string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strlwr: DOS Windows 3.x Phar Lap/ DOSX Win32<br>
_fstrlwr: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _strlwr */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void main () 
{   
   char *str = "Mixed Case String"; 

   printf (" The original string: \"% s\"\n", str); 
   _strlwr (str); 
   printf (" The string after _strlwr: 
	   \"% s\"\n", str); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The original string: "Mixed Case String"<br>
The string after _strlwr: "mixed case string" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strncmpi">strncmpi, strncmpl, _strnicmp, _fstrnicmp</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int strncmpi(const char *str1, const char *str2, size_t n);<br>
int strncmpl(char *str1, char *str2, int n);<br>
int _strnicmp(const char *str1, const char *str2, size_t n);<br>
int __far _fstrnicmp(const char __far *str1, const char __far *str2, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>These functions are case-insensitive versions of strncmp. The first n 
characters of each string are compared. If either is less than n 
characters long, the comparison terminates; the return value is the 
result of the comparison up until the termination. The returned value 
is zero for a successful match; a positive or negative number 
represents the difference in the mismatched characters.<p>

The _fstrnicmp function is a model-independent (large model) 
form of _strnicmp. They are identical, except that the 
_fstrnicmp arguments and return values are far. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  strnicmp
</dd>

<dt><b>Return Value</b></dt> <dd><dl>
<b>Returns... /if...</b> 
<dt>&lt; 0 
<dd>string1 is less than string2 
<dt>= 0 
<dd>string1 is equal to string2 
<dt>&gt; 0 
<dd>string1 is greater than string2 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>_strn*/ strn*: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br>
_fstrnicmp: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#strncmp">strncmp</a><br>
<a href="#strcmp">strcmp Functions</a>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_strnset">_strnset _fstrnset</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_strnset(char *string, int ch, size_t n);<br>
char __far *__far _fstrnset(char __far *string, int ch, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>These functions set, at most, n characters of string to ch 
(converted to char) and return a pointer to the altered string. If n is 
greater than the length of string, the length of string is used in 
place of n. The _fstrnset function is a model-independent (large 
model) form of _strnset. They are identical, except that the 
_fstrnset arguments and return values are far. 
</dd>

<dt><b>Synonym</b></dt> <dd>Functions:  strnset, fstrnset
</dd>

<dt><b>Return Value</b></dt> <dd>These functions return a pointer to a string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>_strnset: DOS Windows 3.x Phar Lap/ DOSX Win32<br>
_fstrnset: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_strset">_strset</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _strnset */ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt;

void main () 
{   
   char *str = "_strnset Example string"; 

   printf (" This is the string: \"% s\"\n", str); 
   printf (" After _strnset(str, 'x', 10): 
	   \"% s\"\n", _strnset(str, 'x', 10)); 
   printf (" After _strnset(str, 'x', 100): 
	   \"% s\"\n", _strnset(str, 'x', 100)); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">This is the string: "_strnset Example string"<br>
After _strnset(str, 'x', 10)</pre>: "xxxxxxxxxxxample<br> 
string"<br> 
After _strnset(str, 'x', 100):<br>
"xxxxxxxxxxxxxxxxxxxxxxx" 
</dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_strrev">_strrev, _fstrrev</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_strrev(char *string);<br>
char __far *__far _fstrrev(char __far* string); 
</tt></dd>

<dt><b>Description</b></dt> <dd>These functions reverse the order of characters in string, leaving a 
terminating '\0' at the end.<p>

The _fstrrev function is a model-independent (large model) form 
of strrev. These functions are identical, except that the _fstrrev 
argument and return value are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  strrev, fstrrev 
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return a pointer to the altered string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>_strrev: DOS Windows 3.x Phar Lap/ DOSX Win32 
_fstrrev: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _strrev */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt; 

void main() 
{   
   char str[80]; 

   printf (" Enter a string: "); 
   gets(str); 

   printf ("\nThe results of _strrev are:\n 
\"% s\"\n", _strrev(str)); 
} 

</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter a string: So much time, so little to do<p>

The results of _strrev are:<br>
"od ot elttil os ,emit hcum oS" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_strset">_strset, _fstrset</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_strset(char *string, int ch);<br>
char __far *__far _fstrset(char __far *string, int ch); 
</tt></dd>

<dt><b>Description</b></dt> <dd>These functions set all the characters in string to ch except the 
terminating null character.<p> 

The _fstrset function is a model-independent (large model) form 
of _strset. These functions are identical, except that the 
_fstrset pointer arguments and return value are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: strset, fstrset 
</dd>

<dt><b>Return Value</b></dt> <dd>These functions return a pointer to the altered string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>_strset: DOS Windows 3.x Phar Lap/ DOSX Win32 
_fstrset: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	
	Example for _strset 
*/ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void main () 
{   
   char *str = "_strset Example string"; 

   printf (" This is the string: \"% s\"\n", str); 
   printf (" After _strset(str, 'x'): \"% s\"\n", 
_strset(str, 'x')); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">This is the string: "_strset Example string"<br>
After _strset(str, 'x'): "xxxxxxxxxxxxxxxxxxxxxx" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_strtime">_strtime</a></h2><dl> 

<dt><b>Header</b></dt> <dd>time.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_strtime(char *timestr); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _strtime function copies the current time to the buffer 
pointed to by the timestr argument.<p>

The time string has the following format:<p>

hh: mm: ss<p>

where hh represents the hour in 24-hour notation, mm represents the 
minutes past the hour, and ss represents the seconds.<p>

The buffer must be at least 9 bytes long. 
</dd>

<dt><b>Return Value</b></dt> <dd>A pointer to the text string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#asctime">asctime</a><br>
<a href="#ctime">ctime</a><br>
<a href="#localtime">localtime</a>
</dd>

<dt><b>Example</b></dt> <dd>See _strdate 
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_strupr">_strupr, _fstrupr</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_strupr(char *string);<br>
char __far *__far _fstrupr(char *string); 
</tt></dd>

<dt><b>Description</b></dt> <dd>These functions convert lowercase characters in string to 
uppercase.<p> 

The _fstrupr function is a model-independent (large model) form 
of _strupr. They are identical, except that the _fstrupr 
argument and the return value are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Functions:  strupr, fstrupr
</dd>

<dt><b>Return Value</b></dt> <dd>Returns string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strupr: DOS Windows 3.x Phar Lap/ DOSX Win32 
_fstrupr: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_strlwr">_strlwr</a><br>
_tolower<br>
_toupper<br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _strupr */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt; 

void main () 
{   
   char *str = "Mixed Case String"; 

   printf (" The original string: \"% s\"\n", str); 
   _strupr (str); 
   printf (" The string after _strupr: 
	    \"% s\"\n", str); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The original string: "Mixed Case String"<br>
The string after _strupr: "MIXED CASE STRING" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="_swab">_swab</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdlib.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _swab(char *source, char *destination, int n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _swab function copies n bytes from source, swapping each 
pair of adjacent bytes. destination stores the converted string. 
The integer n should be even as pairs of characters are swapped. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  swab
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _swab */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt; 
void main() 
{   
   char str[80]; 
   char dst[80]; 
   int len; 

   printf (" Enter a string: "); 
   gets (str); 
   strcpy (dst, str); 

   len = (strlen (str)); 
   len -= len % 2; 

   _swab (str, dst, len); 

   printf ("\nThe results of _swab are:\n 
	    \"% s\"\n", dst); 
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter a string: It's a Push-me-pull-you<p>

The results of _swab are:<br>
"tIs'a P su-hemp-lu-loyu" 
</pre></dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="stpcpy">stpcpy</a></h2><dl> 

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *stpcpy(char *s1, const char *s2); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The stpcpy function copies the string pointed to by s2 into the	buffer pointed to by s1. It is similar to the normal library strcpy function except that it returns a pointer to the end of the copied string. This is useful when concatenating strings. 
</dd>

<dt><b>Return Value</b></dt> <dd>A pointer to the end of the copied string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#strcpy">strcpy</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for stpcpy */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt;

void main ()
{   
    char s1[8], *s2 = "Eu", *s3 = "re", 
		 *s4 = "ka"; 

    stpcpy (stpcpy (stpcpy (stpcpy (s1, s2), 
	    s3), s4), "!"); 
    printf ("This is the string from stpcpy 
	    \"% s\"\n", s1); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">This is the string from stpcopy "Eureka!"
</pre></dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="strcat">strcat, _fstrcat</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *strcat(char *string1, const char *string2);<br>
char __far *__far _fstrcat(char __far *string1, const char __far *string2); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The strcat function appends a copy of string2 onto the end of 
string1 and terminates the resulting string with a null character. 
The application code is responsible for ensuring that there is enough 
space in the string to hold the result.<p>

The _fstrcat function is a model-independent (large model) form 
of strcat. These functions are identical, except that the _fstrcat 
arguments and return values are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fstrcat
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return a pointer to string1.
</dd>

<dt><b>Compatibility</b></dt> <dd>strcat: DOS Windows 3.x Phar Lap/ DOSX Win32
_fstrcat: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strcat */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void main () 
{   
   char str1[50] = "This is string 1..."; 
   char str2[50] = "And this is string 2."; 

   printf (" String 1: \"% s\"\nString 2: 
	   \"% s\"\n", str1, str2); 
   printf (" Result of strcat: \"% s\"\n", 
	   strcat(str1, str2)); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">String 1: "This is string 1..." <br>
String 2: "And this is string 2." <br>
Result of strcat: "This is string 1... And this is string 2." 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strchr">strchr, _fstrchr</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *strchr(const char *string, int ch);<br>
char __far *__far _fstrchr(const char __far *string, int ch); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The strchr function finds the first occurrence of the character ch 
in string and returns a pointer to this character. strchr is 
identical to the function index (which is no longer in this library).<p>

The _fstrchr function is a model-independent (large model) form 
of strchr. These functions are identical, except that the _fstrchr 
arguments and return values are far. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fstrchr
</dd>

<dt><b>Return Value</b></dt> <dd>Pointer to character ch.  A NULL pointer is returned if not found.
</dd>

<dt><b>Compatibility</b></dt> <dd>strchr: DOS Windows 3.x Phar Lap/ DOSX Win32<br>
_fstrch: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#memchr">memchr</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strchr */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void main () 
{   
   char *str = "string example"; 
   char *res; 

   printf (" Looking for 'x' in 
	     string \"% s\"\n", str); 
   res = strchr(str, 'x'); 
   if (! res) 
      printf (" 'x' was not found in 
	      the search string\n"); 
   else 
      printf (" 'x' was found in the search 
	      string at offset %d\n", res -str); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Looking for 'x' in string "string example"<br>
'x' was found in the search string at offset 8 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strcmp">strcmp Functions</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int strcmp(const char *string1, const char *string2);<br>
int __far _fstrcmp(const char __far *string1, const char __far *string2);<br>
int _strcmpi(const char *string1, const char *string2);<br>
int strcmpl(const char *string1, const char *string2);<br>
int __far _fstrcmpl(const char __far *string1, const char __far *string2); 
</tt></dd>

<dt><b>Description</b></dt> <dd>strcmp, _strcmpi, and strcmpl compare two strings, character 
by character. strcmp is case sensitive whereas strcmpi and 
strcmpl are not.<p>

The _fstrcmp and _fstrcmpl functions are model-independent 
(large model) form of strcmp and strcmpl. These functions are 
identical, except that the _fstrcmp and _fstrcmpl arguments are 
far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Functions:  fstrcmp, strcmpi
</dd>

<dt><b>Return Value</b></dt> <dd><dl>
<dt><b>Return.../if ...</b>
<dt>&lt;0 
<dd>stiring1 is less than string2 
<dt>=0 
<dd>string1 is equal to string2 
<dt>&gt;0 
<dd>string1 greater than string2 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>strcmp*: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br>
_fstrcmp*: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#memcmp">memcmp</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strcmp 
	Also demonstrates _stricmp 
*/ 

#include &lt;string.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

char test1[] = "this is a test string"; 
char test2[] = "THIS IS A TEST STRING"; 

void main () 
{   
   int result; 

   printf (" Test string 1 is \"% s\"\n", test1); 
   printf (" Test string 2 is \"% s\"\n", test2); 

   printf ("\nComparing 1 and 2 using strcmp\n"); 
   result = strcmp(test1, test2); 
   if (! result) 
      printf (" string 1 is equal to string 2\n"); 
   else if (result &lt; 0) 
      printf (" string 1 is less than 
		string 2\n"); 
   else 
      printf (" string 1 is greater than 
		string 2\n"); 

   printf ("\nComparing 1 and 2 using 
	   _stricmp\n"); 
   result = _stricmp(test1, test2); 
   if (! result) 
      printf (" string 1 is equal to string 2\n"); 
   else if (result &lt; 0) 
      printf (" string 1 is less than string 2\n"); 
   else 
      printf (" string 1 is greater than 
		string 2\n"); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Test string 1 is "this is a test string"<br>
Test string 2 is "THIS IS A TEST STRING"<p>

Comparing 1 and 2 using strcmp<br>
string 1 is greater than string 2<p> 

Comparing 1 and 2 using _stricmp<br>
string 1 is equal to string 2 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strcoll">strcoll</a></h2><dl> 

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int strcoll(const char *string1, const char *string2);
</tt></dd>

<dt><b>Description</b></dt> <dd>The strcoll function compares the two strings specified in the 
string1 and string2 arguments, using the collating sequence 
specified by the setlocale function. Then, the function returns a 
value indicating the relationship between the strings. 
</dd>

<dt><b>Return Value</b></dt> <dd>The following values are returned:
<p>
<dl>
<dt><b>Returns.../if ...</b>
<dt>&lt;0 
<dd>string1 is less than string2 
<dt>0 
<dd>string1 is equal to string2 
<dt>&gt;0 
<dd>string1 is greater than string2 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#setlocale">setlocale</a><br>
<a href="#strcmp Functions">strcmp Functions</a>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="strcpy">strcpy, _fstrcpy</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *strcpy(char *string1, const char *string2);<br>
char __far *__far _fstrcpy(char __far *string1, const __far char *string2); 
</tt></dd>

<dt><b>Description</b></dt> <dd>strcpy copies string2, including the terminating null character, 
into the object pointed to by string1. The _fstrcpy function is a 
model-independent (large model) form of strcpy. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fstrcpy
</dd>

<dt><b>Return Value</b></dt> <dd>Returns the new string pointed to by string1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strcpy: DOS Windows 3.x Phar Lap/ DOSX Win32<br>
_fstrcpy: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#stpcpy">stpcpy</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strcpy */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt;

void main () 
{   
   char str1[50] = "This is the first string"; 
   char str2[50] = "This is the second string"; 

   printf (" str1 = \"% s\"\n", str1); 
   printf (" str2 = \"% s\"\n", str2); 

   strcpy (str1, str2); 
   printf ("\nAfter strcpy(str1, str2)...\n\n"); 

   printf (" str1 = \"% s\"\n", str1); 
   printf (" str2 = \"% s\"\n", str2); 
{
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">str1 = "This is the first string"<br>
str2 = "This is the second string"<p>

After strcpy(str1, str2)...<p>

str1 = "This is the second string"<br>
str2 = "This is the second string" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strcspn">strcspn, _fstrcspn</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t strcspn(const char *string1, const char string2);<br>
size_t __far _fstrscpn(const char __far *string1, const char __far *string2); 
</tt></dd>

<dt><b>Description</b></dt> <dd>strcspn searches string1 for the first occurrence of a character 
belonging to the set of characters in string2 and returns the index 
of this character. This value is equivalent to the length of the initial substring of string1 consisting entirely of charcters not in 
string2.<p> 

The _fstrcspn function is a model-independent (large model) 
form of strcspn. These functions are identical, except that the 
_fstrcspn arguments and return values are far. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fstrcspn
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return the length of the initial segment of string1 
that consists of characters not found in string2. If string1 
begins with a character from string2, strcspn returns 0. If no 
character in string2 appears in string1, then the total length of 
string1, not counting the null character terminator, is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strcspn: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br> 
_fstrcspn: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strcspn */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt; 

void main () 
{   
   char *str = "The quick brown fox jumped 
		over the lazy dog"; 
   char srch[80]; 
   unsigned res; 

   printf (" The search string is: 
	   \n \"% s\"\n\n", str); 
   printf (" Enter the set of characters 
	   for strcspn(): "); 
   gets (srch); 

   res = strcspn (str, srch); 

   if (res == strlen (str)) 
      printf ("\nSorry but none of those 
	      characters where found.\n"); 
   else 
      printf ("\nMatching character found 
	      at offset %d\n", res); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The search string is:<br>
   "The quick brown fox jumped over the lazy dog"<p>

Enter the set of characters for strcspn(): qzy<p>

Matching character found at offset 4
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strerror">strerror</a></h2><dl> 

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *strerror(int errornum); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The strerror function gets a system error message asociated with 
an error number. It maps errornum to an error message string and 
returns a pointer to that string.<p>

strerror does not print the error message. To print the message 
returned to stderr, use a print statement such as fprintf:
<p>

<pre class="ccode">if ((_access("datafile", 2 )) == -1) 
   fprintf(stderr, _strerror(NULL)); 
</pre>
</dd>

<dt><b>Return Value</b></dt> <dd>Returns a pointer to the error message string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_strerror">_strerror</a><br>
<a href="#clearerr">clearerr</a><br>
<a href="#ferror">ferror</a><br>
<a href="#perror">perror</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strerror */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;io.h&gt; 
#include &lt;string.h&gt; 
#include &lt;fcntl.h&gt; 

void main () 
{   
   int f; 

   if ((f = _open (" nofile. xxx", _O_RDONLY)) &lt; 0) 
	printf (" Error opening file 
	\" nofile. xxx\": %s\n", strerror (errno)); 
   else 
   {   
      printf (" The file is open"); 
      _close (f); 
   } 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Error opening file "nofile. xxx": No such file or directory 
</pre></dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="strlen">strlen, _fstrlen</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t strlen(const char *string);<br>
size_t __far _fstrlen(const char __far *string); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The strlen function returns the length of the string in the string 
argument, excluding the terminating '\0'.<p>

The _fstrlen function is a model-independent (large model) form 
of strlen. These functions are identical, except that the _fstrlen 
argument is a far pointer. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: fstrlen 
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return the length of the string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strlen: DOS Windows 3.x Phar Lap/ DOSX Win32 
_fstrlen: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strlen */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void main () 
{   
   char str[80]; 

   printf (" Enter a string: "); 
   gets (str); 

   printf (" There are %d characters in the 
	   string \"% s\"\n", strlen (str), str); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter a string: The quick brown fox...<br>
There are 22 characters in the string "The quick<br>
brown fox..." 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strncat">strncat, _fstrncat</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *strncat(char *string1, const char *string2, size_t n);<br>
char __far *__far _fstrncat(char __far *string1, const char __far *string2, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>This function appends the lesser of n or strlen(string2) 
characters of string2 onto the end of string1 and adds a 
terminating NULL character. It is the user's responsibility to ensure 
there is enough space in string1 to hold the result.<p>

The _fstrncat function is a model-independent (large model) 
form of strncat. These functions are identical, except that the 
_fstrncat pointer arguments and return values are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fstrncat
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return a pointer to the concatenated string. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strncat: DOS Windows 3.x Phar Lap/ DOSX Win32<br>
_fstrncat: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#strcat">strcat</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strncat */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt;

void main () 
{   
   char str1[25] = "This is string 1..."; 
   char str2[25] = "And this is string 2."; 
   int len; 
   len = 25 -strlen (str1); 
   printf (" String 1: \"% s\"\nString 2: 
	   \"% s\"\n", str1, str2); 
   printf (" Result of strncat(str1, str2, %d): 
	   \"% s\"\n", len, strncat(str1, str2, len)); 
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">String 1: "This is string 1..." <br>
String 2: "And this is string 2." <br>
Result of strncat(str1, str2, 6): "This is <br>
string 1... And th" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strncmp">strncmp, _fstrncmp</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int strncmp(const char *string1, const char *string2, size_t n);<br>
int __far _fstrncmp(const char __far *string1, const char __far *string2, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>Compares n characters of string2 to string1. The comparison 
stops after n characters or the end of string1. The _fstrncmp 
function is a model-independent (large model) form of strncmp. 
These functions are identical, except that the _fstrncmp arguments 
and return values are far. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fstrncmp
</dd>

<dt><b>Return Value</b></dt> <dd><dl>
<b>Return... /if...</b>
<dt>&lt; 0 
<dd>string1 is less than string2 
<dt>= 0 
<dd>string1 is equal to string2 
<dt>&gt; 0 
<dd>string1 is greater than string2 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>strncmp: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br> 
_fstrncmp: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#strcmp Functions">strcmp Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strncmp 
	Also demonstrates _strnicmp 
*/ 

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 

char test1[] = "this is a test string XXXXX"; 
char test2[] = "THIS IS A TEST STRING zzzzz"; 

void main () 
{   
   int result; 

   printf (" Test string 1 is \"% s\"\n", test1); 
   printf (" Test string 2 is \"% s\"\n", test2); 
   printf ("\nComparing 1 and 2 using 
	   strncmp(str1, str2, 21)\n"); 
   result = strncmp (test1, test2, 21); 
   if (! result) 
      printf (" string 1 is equal to string 2\n"); 
   else if (result &lt; 0) 
      printf (" string 1 is less than string 2\n"); 
   else 
      printf (" string 1 is greater than string 
	      2\n"); 

   printf ("\nComparing 1 and 2 using 
	   _strnicmp(str1, str2, 21)\n"); 
   result = _strnicmp (test1, test2, 21); 
   if (! result) 
      printf (" string 1 is equal to string 2\n"); 
   else if (result &lt; 0) 
      printf (" string 1 is less than string 
	      2\n"); 
   else 
      printf (" string 1 is greater than string 
	      2\n"); 

   printf ("\nComparing 1 and 2 using _strnicmp(str1, str2, 100)\n"); 
   result = _strnicmp (test1, test2, 100); 
   if (! result) 
      printf (" string 1 is equal to string 2\n"); 
   else if (result &lt; 0) 
      printf (" string 1 is less than string 2\n"); 
   else
      printf (" string 1 is greater than string 2\n"); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Test string 1 is "this is a test string XXXXX"<br>
Test string 2 is "THIS IS A TEST STRING zzzzz"<p>

Comparing 1 and 2 using strncmp(str1, str2, 21)<br>
string 1 is greater than string 2<p>

Comparing 1 and 2 using _strnicmp(str1, str2, 21)<br>
string 1 is equal to string 2<p>

Comparing 1 and 2 using _strnicmp(str1, str2, 100)<br>
string 1 is less than string 2 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strncmpi">strncmpi, strncmpl, _strnicmp, _fstrnicmp</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int strncmpi(const char *str1, const char *str2, size_t n);<br>
int strncmpl(char *str1, char *str2, int n);<br>
int _strnicmp(const char *str1, const char *str2, size_t n);<br>
int __far _fstrnicmp(const char __far *str1, const char __far *str2, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>These functions are case-insensitive versions of strncmp. The first n 
characters of each string are compared. If either is less than n 
characters long, the comparison terminates; the return value is the 
result of the comparison up until the termination. The returned value 
is zero for a successful match; a positive or negative number 
represents the difference in the mismatched characters.<p>

The _fstrnicmp function is a model-independent (large model) 
form of _strnicmp. They are identical, except that the 
_fstrnicmp arguments and return values are far. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  strnicmp
</dd>

<dt><b>Return Value</b></dt> <dd><dl>
<b>Returns... /if...</b> 
<dt>&lt; 0 
<dd>string1 is less than string2 
<dt>= 0 
<dd>string1 is equal to string2 
<dt>&gt; 0 
<dd>string1 is greater than string2 
</dl>
</dd>

<dt><b>Compatibility</b></dt> <dd>_strn*/ strn*: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br>
_fstrnicmp: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#strncmp">strncmp</a><br>
<a href="#strcmp">strcmp Functions</a>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="strncpy">strncpy, _fstrncpy</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *strncpy(char *string1, const char *string2, size_t n);<br>
char __far *__far _fstrncpy(char __far *string1, const char __far *string2, size_t n); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The strncpy function copies the first n characters of string2 into 
string1. If string2 is longer than string1 or longer than n, the 
result will not be null terminated. If string2 is less than n 
characters, string1 will be padded to n with null characters.<p>

The _fstrncpy function is a model-independent (large model) 
form of strncpy. These functions are identical, except that the 
_fstrncpy arguments and return values are far. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fstrncpy
</dd>

<dt><b>Return Value</b></dt> <dd>Returns string1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strncpy: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br>
_fstrncpy: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#strcpy">strcpy</a><br>
<a href="#stpcpy">stpcpy</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strncpy */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt;

void main () 
{   
   char str1[50] = "This is the first string"; 
   char str2[50] = "The second string is this"; 

   printf (" str1 = \"% s\"\n", str1); 
   printf (" str2 = \"% s\"\n", str2); 

   strncpy (str1, str2, 10); 
   printf ("\nAfter strncpy(str1, str2, 
	   10)...\n\n"); 

   printf (" str1 = \"% s\"\n", str1); 
   printf (" str2 = \"% s\"\n", str2); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">str1 = "This is the first string"<br>
str2 = "The second string is this"<p> 

After strncpy(str1, str2, 10)...<p>

str1 = "The seconde first string"<br>
str2 = "The second string is this" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strpbrk">strpbrk, _fstrpbrk</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *strpbrk(const char *string1, const char *string2);<br>
char __far *__far _fstrpbrk(const char __far *string1, const char __far *string2); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The strpbrk function finds the first occurrence in string1 of any 
character from string2. The terminating null character is not 
included in the search.<p> 

The _fstrpbrk function is a model-independent (large model) 
form of strpbrk. These functions are identical, except that the 
_fstrpbrk arguments and return values are far. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fstrpbrk
</dd>

<dt><b>Return Value</b></dt> <dd>Returns a pointer to the first occurrence in string1 of any 
character from string2, or NULL if no character from string2 
exists in string1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strpbrk: DOS, Windows 3.x, Phar Lap/ DOSX, Win32<br>
_fstrpbrk: DOS, Windows 3.x, Phar Lap/ DOSX, Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strpbrk */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt; 

void main () 
{   
   char *str = "The quick brown fox jumped 
		over the lazy dog"; 
   char srch[80]; 
   char *res; 

   printf (" The search string is:\n 
	   \"% s\"\n\n", str); 
   printf (" Enter the set of characters 
	   for strpbrk(): "); 
   gets (srch); 

   res = strpbrk (str, srch); 

   if (res == NULL) 
      printf ("\nSorry but none of those 
      characters where found.\n"); 
   else 
   {   
      printf ("\nMatching character found at 
	      offset %d\n", res -str); 
      printf (" The result points to 
	      \"% s\"\n", res); 
   } 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The search sting is:<br>
"The quick brown fox jumped over the lazy dog"<p>

Enter the set of characters for strpbrk(): qrt<p>
 
Matching character found at offset 4<br>
The result points to "quick brown fox jumped<br>
over the lazy dog" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strrchr">strrchr, _fstrrchr</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *strrchr(const char *string, int ch);<br>
char __far *__far _fstrrchr(const char __far *string, int ch); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The strrchr function finds the last occurrence of character ch 
(converted to char) in string. The string's terminating null 
character is included in the search.<p>

The _fstrrchr function is a model-independent (large model) 
form of strrchr. These functions are identical, except that the 
_fstrrchr arguments and return values are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fstrrchr
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return a pointer to the last occurrence of ch in string.
They return a NULL pointer if ch is not found. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strrchr: DOS Windows 3.x Phar Lap/ DOSX Win32<br>
_fstrrchr: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strrchr */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt;

void main () 
{   
   char *str = "Peter piper picked a peck of 
pickled peppers"; 
   char *res; 

   printf (" Using strrchr to look for 'p' in string:\n \"% s\"\n\n", str); 
   res = strrchr(str, 'p'); if (! res) 
   printf (" 'p' was not found in the search string\n"); 
   else 
      printf (" The last occurance of 'p' was found in the search string at " 
	"offset %d\n", res -str); 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">Using strrchr to look for 'p' in string:<br>
"Peter piper picked a peck of pickled peppers"<p>

The last occurance of 'p' was found in the<br>
search string at offset 40 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strspn">strspn, _fstrspn</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t strspn(const char *string1, const char *string2);<br>
size_t __far _fstrspn(const char __far *string1, const char __far *string2);
</tt></dd>

<dt><b>Description</b></dt> <dd>The strspn function returns the length of the initial segment of 
string1 which consists entirely of characters found in string2. 
The null character terminating string2 is not considered in the 
matching process. If string1 begins with a character not in 
string2, strspn returns 0.<p>

The _fstrspn function is a model-independent (large model) form 
of strspn. These functions are identical, except that the _fstrspn 
arguments are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: fstrspn 
</dd>

<dt><b>Return Value</b></dt> <dd>Both functions return the length of the initial segment of string1 
which consists entirely of characters found in string2. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strspn: DOS Windows 3.x Phar Lap/ DOSX Win32 
_fstrspn: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">	/* 	Example of strspn */ 

	#include &lt;stdlib.h&gt; 
	#include &lt;stdio.h&gt; 
	#include &lt;string.h&gt; 

	void main () 
	{ 
	   char *str = "The quick brown fox jumped 
	   over the lazy dog"; 

	   char srch[80]; 
	   unsigned res; 

	   printf (" The search string is:\n 
		   \"% s\"\n\n", str); 
	   printf (" Enter the set of characters 
		   for strspn(): "); 
	   gets (srch); 

	   res = strspn (str, srch); 

	   if (res == 0) 
	      printf ("\nSorry, but not all of those 
			  characters where found.\n"); 
	   else 
	      printf ("\nCharacters match until offset 
			  %d\n", res); 
	} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The search string is:<br>
"The quick brown fox jumped over the lazy dog"<p>

Enter the set of characters for strspn(): ehT<br>
kciqu z<p>

Characters match until offset 10 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strstr">strstr, _fstrstr</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *strstr(const char *string1, const char *string2);<br>
char __far *__far _fstrstr(const char __far *string1, const char __far *string2); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The strstr function returns a pointer to the first occurrence of 
string2 within string1.<p>

The _fstrstr function is a model-independent (large model) form 
of strstr. These functions are identical, except that the _fstrstr 
arguments and return value are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  fstrstr
</dd>

<dt><b>Return Value</b></dt> <dd>These functions return a pointer to the first occurence of string2 
within string1, or they return NULL if no occurrence was found. If 
string2 is of 0 length, the functions return string1. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strstr: DOS Windows 3.x Phar Lap/ DOSX Win32<br>
_fstrstr: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of strstr */ 

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt; 

void main () 
{   
   char *str = "The quick brown fox jumped<br>
		over the lazy dog"; 
   char srch[80]; 
   char *res; 

   printf ("The source string is:\n 
	    \"% s\"\n\n", str); 
   printf ("Enter the search string for 
	    strstr(): "); 
   gets (srch); 

   res = strstr (str, srch); 

   if (res == NULL) 
      printf ("\nSorry, that string was not 
	      found.\n"); 
   else 
   {   
      printf ("\nMatching string found at offset 
	      %d\n", res -str); 
      printf (" Result points to the string: 
	      \n \"% s\"\n", res); 
   } 
} 
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console">The source string is:<br>
"The quick brown fox jumped over the lazy dog"<p>

Enter the search string for strstr(): lazy<p>

Matching string found at offset 36<br>
Result points to the string:<br>
"lazy dog" 
</pre></dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strtok">strtok, _fstrtok</a></h2><dl>

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char * strtok(char * string1, const char * string2);<br>
char __far *__far _fstrtok(char __far *string1, const char __far *string2); 
</tt></dd>

<dt><b>Description</b></dt> <dd>strtok parses string1 into tokens delimited by characters in 
string2. It returns a pointer to the first character in string1, 
which is not one of the delimiting characters, and writes a '\0' at the position of the next delimiter. Because an internal record is stored of the current position within the string, a subsequent strtok call with a NULL value for string1 continues parsing from the position 
reached in the previous call. string2 may change between calls.<p>

The _fstrtok function is a model-independent (large model) form 
of strtok. These functions are identical, except that the _fstrtok 
arguments and return value are far pointers. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: fstrtok 
</dd>

<dt><b>Return Value</b></dt> <dd>The first time these functions are called, they return a pointer to the 
first token in string1. In later calls with the same token string, a 
pointer to the next token is returned. When there are no more 
tokens, a NULL pointer is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>strtok: DOS Windows 3.x Phar Lap/ DOSX Win32<br>
_fstrtok: DOS Windows 3.x Phar Lap/ DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for strtok */ 

#include &lt;stdio.hgt 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt;

#define delim "\n\r\t\v "
char * gettoken (FILE *fp) 
{   
   static char linebuf[128]; 
   static char *res = NULL; 

   do 
   {   
      if (res == NULL) 
      {   
	 fgets (linebuf, 128, fp); 
	 res = strtok (linebuf, delim); 
      } 
      else 
	 res = strtok (NULL, delim); 
   } while (! feof (fp) &amp;&amp; !res); 
   return res; 
} 
void main () 
{   
   char fname[_MAX_PATH]; 
   char *token; 
   FILE *fp; 

   printf (" Enter filename: "); 
   gets (fname); 

   if ((fp = fopen (fname, "r")) == NULL) 
   {   
      perror (" Unable to open file"); 
      exit (EXIT_FAILURE); 
   } 
   do 
   {   
      token = gettoken (fp); 
      printf ("% s\n", token); 
   } while (! feof(fp)); 
}
</pre></dd>

<dt><b>Output</b></dt> <dd><pre class="console"> Enter filename: strtok. c 
 /* 
 Example
 for 
 strtok 
 */ 
 #include 
 &lt;stdio.h&gt;
 #include 
 &lt;stdlib.h&gt;
 . 
 . 
 . 
 = 
 gettoken 
 (fp); 
 printf 
 ("% s\n", 
 token); 
 } 
 while 
 (! feof(fp)); 
 } 
</pre>
</dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="strxfrm">strxfrm</a></h2><dl> 

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>size_t strxfrm(char *string1, const char *string2, size_t count); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The strxfrm function transforms string2 to a differently collated 
form and stores it in string1. The count argument is the maximum 
number of characters placed in string1. The transformation uses 
the collating sequence for the locale, as set by the setlocale 
function.<p>

The size of the array needed to hold the transformation of the source 
string can be expressed as: <p>

1 + strxfrm(NULL, string, 0) 
</dd>

<dt><b>Return Value</b></dt> <dd>The length of the transformed string, not counting the terminating 
null character. The contents of string1 are unpredictable if the 
return value is greater than or equal to count. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#localeconv">localeconv</a><br>
<a href="#setlocale">setlocale</a><br>
<a href="#strcmp Functions">strcmp Functions</a><br>
<a href="#strcoll">strcoll</a>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_sys_errlist">_sys_errlist</a></h2><dl> 

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern char *_sys_errlist[]; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable is an array of error messages indexed by errno 
values. Error messages printed by perror and returned by 
strerror and _strerror are retrieved from this array. It is better 
to use those functions rather than access the array directly because 
the functions handle out-of-range errno values correctly. 
</dd>

<dt><b>Synonym</b></dt> <dd>Variable:  sys-errlist
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>errno<br>
<a href="#_sys_nerr">_sys_nerr</a><br>
perror<br>
<a href="#strerror">strerror</a><br>
</dd>

 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_sys_nerr">_sys_nerr</a></h2><dl> 

<dt><b>Header</b></dt> <dd>string.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern int _sys_nerr; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable tells how many elements the _sys_errlist variable 
contains. 
</dd>

<dt><b>Synonym</b></dt> <dd>Variable:  sys_nerr
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>errno<br>
<a href="#_sys_errlist">_sys_errlist</a>
</dd>

 </dl>



<br><br><br><br>

</td></table>




<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

