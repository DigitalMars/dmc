
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - stdio.h</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:15 2006
</div>
</div>

<!-- Generated by Ddoc from stdio.d -->



<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>stdio.h</h1>

Stdio is the header for the standard functions that deal with input and output
to the console and to files.

<ul>
	<li><a href="#_fcloseall"><b>_fcloseall</b></a>
	<li><a href="#_fdopen"><b>_fdopen</b></a>
	<li><a href="#_fgetchar"><b>_fgetchar</b></a>
	<li><a href="#_fileno"><b>_fileno</b></a>
	<li><a href="#_flushall"><b>_flushall</b></a>
	<li><a href="#_fputchar"><b>_fputchar</b></a>
	<li><a href="#_fsopen"><b>_fsopen</b></a>
	<li><a href="#_getw"><b>_getw</b></a>
	<li><a href="#_okbigbuf"><b>_okbigbuf</b></a>
	<li><a href="#_putw"><b>_putw</b></a>
	<li><a href="#_rmtmp"><b>_rmtmp</b></a>
	<li><a href="#_stdaux"><b>_stdaux</b></a>
	<li><a href="#_stdprn"><b>_stdprn</b></a>
	<li><a href="#_tempnam"><b>_tempnam</b></a>
	<li><a href="#clearerr"><b>clearerr</b></a>
	<li><a href="#fclose"><b>fclose</b></a>
	<li><a href="#feof"><b>feof</b></a>
	<li><a href="#ferror"><b>ferror</b></a>
	<li><a href="#fflush"><b>fflush</b></a>
	<li><a href="#fgetc"><b>fgetc</b></a>
	<li><a href="#fgetpos"><b>fgetpos</b></a>
	<li><a href="#fgets"><b>fgets</b></a>
	<li><a href="#fopen"><b>fopen</b></a>
	<li><a href="#fprintf"><b>fprintf, printf, sprintf, _snprintf</b></a>
	<li><a href="#fputc"><b>fputc</b></a>
	<li><a href="#fputs"><b>fputs</b></a>
	<li><a href="#fread"><b>fread</b></a>
	<li><a href="#freopen"><b>freopen</b></a>
	<li><a href="#fscanf"><b>fscanf, scanf, sscanf</b></a>
	<li><a href="#fseek"><b>fseek</b></a>
	<li><a href="#fsetpos"><b>fsetpos</b></a>
	<li><a href="#ftell"><b>ftell</b></a>
	<li><a href="#fwrite"><b>fwrite</b></a>
	<li><a href="#getc"><b>getc</b></a>
	<li><a href="#getchar"><b>getchar</b></a>
	<li><a href="#gets"><b>gets</b></a>
	<li><a href="#putc"><b>putc</b></a>
	<li><a href="#putchar"><b>putchar</b></a>
	<li><a href="#puts"><b>puts</b></a>
	<li><a href="#rewind"><b>rewind</b></a>
	<li><a href="#setbuf"><b>setbuf</b></a>
	<li><a href="#setvbuf"><b>setvbuf</b></a>
	<li><a href="#stderr"><b>stderr</b></a>
	<li><a href="#stdin"><b>stdin</b></a>
	<li><a href="#stdout"><b>stdout</b></a>
	<li><a href="#tmpfile"><b>tmpfile</b></a>
	<li><a href="#tmpnam"><b>tmpnam</b></a>
	<li><a href="#ungetc"><b>ungetc</b></a>
	<li><a href="#vprintf"><b>vprintf Functions</b></a>
</ul>

<!-- =========================================== -->

<hr> <h2><a name="_fcloseall">_fcloseall</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _fcloseall(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _fcloseall function closes all open streams and files except 
stderr, stdin, and stdout. Any data in the I/ O buffers is flushed 
before closing. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: fcloseall
</dd>

<dt><b>Return Value</b></dt> <dd>The number of streams closed. Returns EOF If an error occurs.
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_close">_close</a><br>
<a href="#fclose">fclose</a><br>
<a href="#fopen">fopen</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* Example for _fcloseall and <a href="#fopen">fopen</a> */
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt; 

int main()
{   
   int closed_count;
   FILE *pfile1, *pfile2; 

   pfile1 = <a href="#fopen">fopen</a>("temp.dat", "w+");
   pfile2 = <a href="#fopen">fopen</a>("temp2.dat", "w+"); 

   if ((pfile1 == NULL) || (pfile2 == NULL)) 
	perror("A data file could not be opened"); 
   else
   {   
	closed_count = <b>_fcloseall</b>();
	printf("Fcloseall closed %d streams\n", 
		  closed_count);
   } 
   return EXIT_SUCCESS;
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Fcloseall closed 2 streams</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_fdopen">_fdopen</a></h2><dl> 

<dt><b>Header</b></dt> <dd>stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>FILE *<b>_fdopen</b>(int fd, const char *mode); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
<b>_fdopen</b> allows a file that has been open for low-level, 
unbuffered I/O (with open) to be associated with an input/output
stream. When the file is associated with a stream, it can be 
buffered and formatted. <p>

The handle of the already opened file is passed as <i>fd</i> 
and the file mode is pointed to by <i>mode</i>.
If the specified mode is an append 
mode, the file pointer is positioned at the end of the file, otherwise 
the file pointer is positioned at the beginning of the file. If the 
specified mode is a write mode, the file is truncated. No checking is 
done to assure that the mode of the buffered file is compatible with 
the mode of the unbuffered file. Incompatibility of file modes will 
give undefined results. <p>

The values for <i>mode</i> are:<p>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<th>Value</th> <th>Meaning</th>
	</tr><tr>
	<td>"r"</td>
	<td>Read only.</td>
	</tr><tr>
	<td>"w"</td>
	<td>Write only with truncation; existing contents are destroyed.</td>
	</tr><tr>
	<td>"a"</td>
	<td>Write only with append.</td>
	</tr><tr>
	<td>"r+"</td>
	<td>Read and write.</td>
	</tr><tr>
	<td>"w+"</td>
	<td>Read and write with truncatation; existing
	contents are destroyed.</td>
	</tr><tr>
	<td>"a+"</td>
	<td>Read and write with append.</td>
	</tr>

	</table>
<p>

Values that can be appended to the mode are:
<p>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<td>t</td>
	<td>Open in text (translated) mode.</td>
	</tr><tr>
	<td>b</td>
	<td>Open in binary (untranslated) mode.</td>
	</tr>
	</table>
</dd>

<dt><b>Synonym</b><p><dd>

Function: fdopen
<p>

<dt><b>Return Value</b></dt> <dd>
A FILE pointer to opened file. NULL is returned is the file could not 
be opened with buffering. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_open">_open</a><br>
<a href="#fopen">fopen</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for <b>_fdopen</b>
	Also demonstrates open, fgets 

*/
#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;<a href="string.html">io.h</a>&gt;
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   int fd;
   FILE *fp; 
   char line[81]; 

   fd = open("temp.dat", O_RDONLY);
   if (fd == -1) 
	perror("Error opening file"); 
   else 
   {
	fp = <b>_fdopen</b>(fd, "r"); 
	if (fp == NULL)
	   perror("Error opening file for read"); 
	else
	{   
	   fgets(line, 80, fp);
	   printf("The first line of temp.dat is:\n%s\n", line);
	} 
   }
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">The first line of temp.dat is:
This is an example. 
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_fgetchar">_fgetchar</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int <b>_fgetchar</b>(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
<b>_fgetchar</b> reads a single character from stdin. The 
character is converted and returned as an integer. 
</dd>

<dt><b>Synonym</b><p><dd>

Function: fgetchar 
<p>

<dt><b>Return Value</b></dt> <dd>
The character that was read. Returns EOF if an error or end-of-file is 
encountered. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fputc">fputc</a><br>
<a href="#getc">getc</a><br>
<a href="#getchar">getchar</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* Example for <b>_fgetchar</b> */
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{ 
   char ch; 
   printf("Enter a character followed by ret:\n"); 
   ch = <b>_fgetchar</b>();
   printf("The character read from stdin is : %c\n", ch);
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter a character followed by ret: j

The character read from stdin is : j
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_fileno">_fileno</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int _fileno(FILE *fp); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
Returns the file descriptor associated with stream fp. The fp 
argument must point to a file which is already open. The fileno 
function converts a file pointer to a file descriptor for use with the 
low-level file functions such as close, read, and write. Mixing of 
high and low level functions is not recommended. 
</dd>

<dt><b>Synonym</b><p><dd>

Function: fileno 
<p>

<dt><b>Return Value</b></dt> <dd>
Returns the file descriptor; no error return. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fopen">fopen</a><br>
<a href="#freopen">freopen</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _fileno */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   printf("The handle for stdin is %d\n",
	     _fileno(stdin)); 
   printf("The handle for stdout is %d\n",
	     _fileno(stdout)); 
   printf("The handle for stderr is %d\n",
	     _fileno(stderr)); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">The handle for stdin is 0
The handle for stdout is 1 
The handle for stderr is 2 
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_flushall">_flushall</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int _flushall(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The _flushall function flushes the I/O buffers for all open 
streams. Output buffers are written to their associated files and input 
buffers are cleared. All streams remain open after a call to 
_flushall. Any read operation reads new data into the buffers. 
</dd>

<dt><b>Synonym</b><p><dd>

Function:  flushall
<p>

<dt><b>Return Value</b></dt> <dd>
The number of open streams. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fflush">fflush</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _flushall */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   int tf; 

   tf = _flushall ();
   printf("%d streams flushed\n", tf); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">5 streams flushed</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_fputchar">_fputchar</a></h2><dl> 


<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int _fputchar(int c);  
</tt></dd>

<dt><b>Description</b></dt> <dd>
The _fputchar function is equivalent to fputc, except that 
_fputchar writes the character to standard output. 
</dd>

<dt><b>Synonym</b><p><dd>

Function:  fputchar
<p>

<dt><b>Return Value</b></dt> <dd>
The last character output to the stream. An EOF is returned on error. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fgetc">fgetc</a><br>
<a href="#fputc">fputc</a><br>
<a href="#getchar">getchar</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for fputchar */ 
#include &lt;stdio.h&gt;


int main() 
{   
   char *str = "All the king's horses and all 
   the king's men", *ptr; 

   ptr = str; 
   while (* ptr &amp;&amp; (fputchar(*(ptr++)) != EOF)); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">All the king's horses and all the king's men</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_fsopen">_fsopen</a></h2><dl> 


<dt><b>Header</b></dt> <dd>
stdio.h<br>
share. h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
FILE *_fsopen(const char *filename, const char *mode, int shflag); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The _fsopen function opens filename as a stream and returns 
the associated stream pointer. The mode argument specifies the type 
of access that is allowed; the shflag argument specifies the sharing 
mode. Values for the mode argument are:<p>
<dl>
<dt><b>Value/Meaning</b>
<dt>"r" 
<dd>Read only; file must exist or call will fail. 
<dt>"w" 
<dd>Write only and truncate; if file exists, existing contents 
are destroyed. 
<dt>"a" 
<dd>Write only and append; if file does not exist, it is created. 
<dt>"r+" 
<dd>Read and write; file must exist or call will fail. 
<dt>"w+" 
<dd>Read, write, and truncate; if file exists, existing contents 
are destroyed. 
<dt>"a+" 
<dd>Read, write, and append; if file does not exist, it is 
created. 
</dl><br>

Values that can be appended to the mode argument are:<br>
<dl>
<dt>t 
<dd>Open in text (translated) mode. 
<dt>b 
<dd>Open in binary (untranslated) mode 
</dl><br>

The following values can be specified for the shflag argument and 
are are defined in share. h. If share.com (or share. exe, for 
some DOS versions) is not installed, shflag is ignored.<p>
<dl>
<dt>_SH_COMPAT 
<dd>Sets compatibility mode 
<dt>_SH_DENYNO 
<dd>Permits read and write access 
<dt>_SH_DENYRD 
<dd>Denies read access to file 
<dt>_SH_DENYRW 
<dd>Denies read and write access to file 
<dt>_SH_DENYWR 
<dd>Denies write access to the file 
</dl>
<br>
A pointer to the stream. A NULL pointer value indicates an error. 
</dd>

<dt><b>Return Value</b></dt> <dd>
A pointer to the stream. A NULL pointer value indicates an error. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fclose">fclose</a><br>
<a href="#_fcloseall">_fcloseall</a><br>
<a href="#_fdopen">_fdopen</a><br>
<a href="#fopen">fopen</a><br>
<a href="#freopen">freopen</a><br>
<a href="#_open">_open</a><br>
<a href="#_setmode">_setmode</a><br>
<a href="#_sopen">_sopen</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _fsopen */ 
#include &lt;dos.h&gt;
#include &lt;<a href="string.html">io.h</a>&gt;
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;
#include &lt;fcntl.h&gt;
#include &lt;share.h&gt;

int main() 
{   
   FILE *fp; 
   char fn[_MAX_PATH]; 

   printf("Enter a filename: "); 
   gets(fn); 

   if ((fp = _fsopen(fn, "r", _SH_DENYRW)) == 
	  NULL) 

   {   
      perror("Cannot open file"); 
      exit (EXIT_FAILURE); 
   } 
   printf("File opened successfully, no one 
	     else can read or write to it.\n"); 
   <a href="#fclose">fclose</a>(fp); 
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter a filename: _fsopen.c
File opened successfully, no one else can read
or write to it. 
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_getw">_getw</a></h2><dl> 


<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int _getw(FILE *stream); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The _getw function returns the next binary value of type int from 
the file associated with the stream argument. The file pointer is 
incremented to point to the next unread character. Do not use this 
function on a file that was opened in text mode. 
</dd>

<dt><b>Synonym</b><p><dd>

Function:  getw
<p>

<dt><b>Return Value</b></dt> <dd>
The next integer in the file. If an error occurs or the end-of-file is 
read, EOF is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_putw">_putw</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _getw
	Also demonstrates _putw, <a href="#fopen">fopen</a>, <a href="#fclose">fclose</a>, rand 

*/ 

#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   FILE *fp; 
   int n, i; 

   fp = <a href="#fopen">fopen</a>("testfile", "wb"); 
   if (fp == NULL) 
   {   
      perror("Couldn't open TESTFILE to write"); 
      exit (EXIT_FAILURE); 
   } 
   printf("Writing "); 
   for (i = 10; i &gt; 0; i -= 1) 
   {   
      n = rand (); 
      printf("%d ", n); 
      _putw (n, fp); 
   } 
   printf("\n"); 
   <a href="#fclose">fclose</a>(fp); 
   fp = <a href="#fopen">fopen</a>("testfile", "rb"); 
   if (fp == NULL) 
   {   
      perror("Couldn't open TESTFILE to read"); 
      exit (EXIT_FAILURE); 
   } 
   printf("Read "); 
   for (;;) 	
   {   
      n = _getw(fp); 
      if (n == EOF) 
	 break; 
      printf("%d ", n); 
   } 
   printf("\n"); 
   <a href="#fclose">fclose</a>(fp); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Writing 16838 5758 10113 17515 31051 5627 23010
7419 16212 4086

Read 16838 5758 10113 17515 31051 5627 23010
7419 16212 4086
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_okbigbuf">_okbigbuf</a></h2><dl> 


<dt><b>Header</b></dt> <dd>
tsr.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern int _okbigbuf; 
</tt></dd>

<dt><b>Description</b></dt> <dd>
This variable, used in T and S Memory Models only, defines which 
memory allocation method to use: <p>

° Allocate all available memory up to 64 KB to the heap 
upon program startup. This is the default method. <br>
° Allocate memory to the heap only as needed. Use this 
method if a spawn function will be needed. To use, 
declare _okbigbuf as shown below. For more 
information, see the Compiler and Tools Guide. <p>

To prevent the allocation of memory, re-declare _okbigbuf as: <p>

int _okbigbuf = 0; <p>

_okbigbuf != 0 signifies that large disk buffers are used for 
stream I/ O outside the data segment. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_putw">_putw</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int _putw(int binint, FILE *stream); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The _putw function writes the binary value stored in the binint 
argument to the current position of the stream argument. The 
function does not affect the alignment of items in the stream. </dd>

Portability problems can occur with the _putw function because the 
size of an int and ordering of bytes within an int can vary across 
systems. 
<p>

<dt><b>Synonym</b><p><dd>

Function:  putw
<p>

<dt><b>Return Value</b></dt> <dd>
Both functions return the value that is written. If an error occurs, 
EOF is returned. EOF may also be a legitimate integer value. 
Therefore, use ferror to verify an error. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_getw">_getw</a>
</dd>

<dt><b>Example</b></dt> <dd>
See getw
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_rmtmp">_rmtmp</a></h2><dl> 


<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int _rmtmp(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The _rmtmp function closes and deletes all temporary files created 
by tmpfile in the current directory. The current directory must be 
the same directory in which the files were created. 
</dd>

<dt><b>Return Value</b></dt> <dd>
The number of temporary files closed and deleted. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_flushall">_flushall</a><br>
<a href="#tmpfile">tmpfile</a><br>
<a href="#tmpnam">tmpnam</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _rmtmp */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   FILE *fp; 
   int i; 

   for (i = 1; i &lt;= 10; i++) 
      if ((fp = tmpfile ()) == NULL) 
	 perror("Could not open temp file"); 
      else 
	 printf("Temp file %d created\n", i); 

   i = _rmtmp ();
   printf("Removed %d temp files\n", i); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Temp file 1 created
Temp file 2 created 
Temp file 3 created
Temp file 4 created 
Temp file 5 created
Temp file 6 created 
Temp file 7 created
Temp file 8 created 
Temp file 9 created
Temp file 10 created 
Removed 10 temp files 
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_stdaux">_stdaux</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h		
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern File *_stdaux;
</tt></dd>

<dt><b>Description</b></dt> <dd>
_stdaux is a constant FILE pointer to the standard auxiliary stream, which is usually the first serial port. I/ O through _stdaux is usually 
unbuffered
</dd>

<dt><b>Synonym</b><p><dd>

stdaux
<p>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#stderr">stderr</a><br>
<a href="#stdin">stdin</a><br>
<a href="#stdout">stdout</a><br>
<a href="#_stdprn">_stdprn</a>
</dd>

 </dl>




<!-- =========================================== -->

<hr> <h2><a name="_stdprn">_stdprn</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern FILE *_stdprn;
</tt></dd>

<dt><b>Description</b></dt> <dd>
_stdprn is a constant FILE pointer to the standard print stream, which is usually the first parallel port. I/ O through _stdaux is usually unbuffered. 
</dd>

<dt><b>Synonym</b><p><dd>

stdprn
<p>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_stdaux">_stdaux</a><br>
<a href="#stderr">stderr</a><br>
<a href="#stdin">stdin</a><br>
<a href="#stdout">stdout</a>
</dd>

 </dl>




<!-- =========================================== -->

<hr> <h2><a name="_tempnam">_tempnam</a></h2><dl> 


<dt><b>Header</b></dt> <dd>
stdio.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
char *_tempnam(char *dir, char *prefix); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The _tempnam function generates a unique temporary filename that 
is valid, but not the same as, the name of any existing file. The 
function is similar to tmpnam, except the string returned is always 
malloc'ed. The dir argument is the directory in which to create 
the temporary file. If dir is NULL, the current directory specified by 
the P_tmpdir constant is used. The prefix argument is a 5 
character prefix string used for the start of the temporary filename. 
</dd>

<dt><b>Synonym</b><p><dd>

Function:  tempnam
<p>

<dt><b>Return Value</b></dt> <dd>
A malloc'ed string containing the temporary file name. If tempnam 
is unable to create the temporary filename for any reason a NULL 
pointer is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#tmpnam">tmpnam</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _tempnam */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   char *name; 

   if ((name = _tempnam (NULL, "abcde")) == NULL) 
   {   
      perror("Unable to create temporary filename"); 
      exit (EXIT_FAILURE); 
   } 

   printf("Temporary filename \"%s\" 
	     created.\n", name); 

   free (name); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Temporary filename "abcdeCCE. tmp" created. 
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="clearerr">clearerr</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
void clearerr(FILE *fp); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The clearerr function clears error and EOF (end-of-file) flags associated with the stream fp. Once the error flag on a stream is set, any operation carried out on that stream will return an error status unless a call is made to clearerr. Flag EOF is cleared with each input from the stream.
</dd>

<dt><b>Return Value</b></dt> <dd>
None
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#feof">feof</a><br>
<a href="#ferror">ferror</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for clearerr	*/ 

#include &lt;stdio.h&gt; 
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt; 

int main() 
{   
   FILE *stream; 
   char *string = "Sample Data"; 

   stream = <a href="#fopen">fopen</a>("temp.dat", "r"); 
   fprintf(stream, "%s\n", string); 
   if (ferror(stream)) 
   {   
      printf("Write File Error"); 
      clearerr(stream); 
      <a href="#fclose">fclose</a>(stream); 
   } 
   else 
   {   
      printf("No error writing to stream"); 
      <a href="#fclose">fclose</a>(stream); 
   } 
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Write File Error
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="fclose">fclose</a></h2><dl> 


<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int fclose(FILE *fp);
</tt></dd>

<dt><b>Description</b></dt> <dd>
fclose closes the file associated with the stream fp. Any data in 
the output buffer for fp is flushed (written to the file) before closing. 
</dd>

<dt><b>Return Value</b></dt> <dd>
fclose returns 0 if the stream successfully closed. A -1 is returned 
on error. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_close">_close</a><br>
<a href="#fopen">fopen</a><br>
<a href="#freopen">freopen</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for fclose		Also demonstrates <a href="#fopen">fopen</a> 

*/
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt; 

int main()
{   
   FILE *pfile; 

   pfile = <a href="#fopen">fopen</a>("temp.dat", "w+"); 

   if (pfile == NULL)
	perror("Data file not opened"); 
   else
   {   
	<a href="#fclose">fclose</a>(pfile);
	printf("Data file closed using fclose\n"); 
   }
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Data file closed using fclose
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="feof">feof</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int feof(FILE *fp);
</tt></dd>

<dt><b>Description</b></dt> <dd>
feof determines if the stream fp is at the end of file. After the EOF 
indicator is set no further read operations are allowed. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns non-zero if current position is at the end of the file (which 
sets the EOF flag in the FILE structure). No read operations are 
allowed after the flag is set. The flag is cleared if rewind or fseek 
are called, or when the file is closed. Returns 0 if the the EOF flag is 
not set. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#clearerr">clearerr</a><br>
<a href="#ferror">ferror</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for feof		Also demonstrates <a href="#fopen">fopen</a>, fgets 

*/
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

#define BUFSIZE 128
char buffer[BUFSIZE]; 

int main()
{   
   FILE *fp; 

   fp = <a href="#fopen">fopen</a>("temp.dat", "r"); 

   if (fp != NULL)
   {   
	while (! feof(fp))
	{   
	   fgets (buffer, BUFSIZE, fp);
	   printf("%s", buffer); 
	}
   } 
   else 
	perror("Error opening file"); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">This program types the contents of temp.dat to the screen. 
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="ferror">ferror</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int ferror(FILE *fp); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
ferror checks the error flag on the stream fp. The error flag 
remains set until a call to clearerr, or rewind is issued, or the 
stream is closed. No read or write operations can be carried out until 
this flag is cleared. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns non-zero if the error flag is set. Otherwise it returns a zero. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#clearerr">clearerr</a><br>
<a href="#feof">feof</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for ferror		Also demonstrates clearerr 

*/
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   FILE *fp; 
     fp = <a href="#fopen">fopen</a>("temp.dat", "r"); 

     if (fp != NULL)
     {   

	fputs("This is a write error\n", fp);
	if (ferror(fp)) 
	{

	   printf("Stream i/o error"); 
	   clearerr(fp);
	} 
	<a href="#fclose">fclose</a>(fp);

     } 
     else
	perror("Error opening file"); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Stream i/o error
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="fflush">fflush</a></h2><dl> 


<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int fflush(FILE *fp); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
Flushes the buffer associated with stream fp. If fp is NULL, fflush 
flushes the buffers for all open streams. If the file is opened for 
writing, the buffer is written. If the file is opened for reading, the 
buffer is cleared. The fflush function may be used to force the 
data in the file buffer to be written to the file before the buffer 
becomes full. Similarly data read from a file is input a buffer full at a time. Only after every character has been processed does another 
file access occur. The fflush function may be used to clear the 
buffer and thus force the next read operation to occur. 
</dd>

<dt><b>Return Value</b></dt> <dd>
0 if the buffer is successfully flushed. Returns EOF if an error occurs. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fclose">fclose</a><br>
<a href="#_flushall">_flushall</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for fflush */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   FILE *fp; 
   fp = <a href="#fopen">fopen</a>("temp.dat", "w");
   fflush(fp); 
   /* Flush buffer to disk to protect data
      before performing operations that can 
      cause system crash
   */ 
   <a href="#fclose">fclose</a>(fp);
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">This program produces no output.
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="fgetc">fgetc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int fgetc(FILE *fp); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
fgetc reads and returns the next character from the stream fp. The 
character is returned as an integer in the range of 0 to 255. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns the character just read on success, or EOF if end-of-file or a 
read error is encountered. The return value must always be assigned 
to a variable of type int, or an error cannot be detected (as EOF is 
negative). 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fputc">fputc</a><br>
<a href="#putchar">putchar</a><br>
<a href="#getc">getc</a><br>
<a href="#getchar">getchar</a><br>
<a href="#_getche">_getche</a><br>
<a href="#_getch">_getch</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for fgetc, fputc */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   FILE *fp;
   int input; 

   fp = <a href="#fopen">fopen</a>("temp.dat"," w+");
   if (fp!= NULL) 
   {
	printf("Enter data terminated by 
	     ctrl-z:");
	while ((input = fgetc (stdin)) != EOF) 
	{
	   printf("%c",(char) input); 
	   fputc (input, fp);
	} 
	<a href="#fclose">fclose</a>(fp);
   } 
   else
	perror("Error opening temp file"); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd>
This program will echo keyboard input to the screen and put it in the file temp.dat. The program output looks like this: <p>
<pre class="console">Enter data terminated by ctrl-z: Hello from
Digital Mars 
Hello from Digital Mars
^Z 
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="fgetpos">fgetpos</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int fgetpos(FILE *fp, fpos_t *pos); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The function fgetpos gets the current position of the stream fp. 
The position is stored in pos. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns 0 if successful, otherwise returns non-zero with errno set. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fsetpos">fsetpos</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for fgetpos, fsetpos		Also demonstrates 

*/
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   FILE *fp;
   fpos_t fpos; 
   char dump[64]; 

   fp = <a href="#fopen">fopen</a>("temp.dat", "r");
   fread(dump, 1, 64, fp); 

   /* save current position */ 

   if (fgetpos (fp, &fpos) != 0)
      perror("fgetpos failed"); 
   fread(dump, 1, 64, fp); 

   /* back to previous position*/
   if (fsetpos (fp, &fpos) != 0) 
      perror("fsetpos failed"); <a href="#fclose">fclose</a>(fp); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">This program produces no output.
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="fgets">fgets</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
char *fgets(char *str, int n, FILE *fp); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
Reads characters from stream fp into the string pointed to by str. 
The integer argument n indicates the maximum number of 
characters that the buffer str can store. Reading stops when a 
newline is read, end-of-file is encountered, a read error occurs, or n-1 
characters were read. Newlines are included in the string. The 
string read is terminated with a 0. 
</dd>

<dt><b>Return Value</b></dt> <dd>
String str if successful. If no characters have been read into str 
and a read error or EOF is encountered, NULL is returned and the 
string pointed to by str is unchanged. If a read error occurs, NULL 
is returned and str contains garbage. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fputs">fputs</a><br>
<a href="#gets">gets</a><br>
<a href="#puts">puts</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for fgets		Also demonstrates 

*/
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   char buffer[255];
   int buflen; 
   char *result; 

   buflen = 255;
   printf("Enter line of data:\n"); 
   result = fgets (buffer, buflen, stdin);
   if (result == NULL) 
	printf("\nEOF or Error\n");
   else 
	printf("The input was :\n%s\n", buffer);
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd>
<pre class="console">Enter line of data:
The quick brown fox jumped over the lazy dog. 
The input was :
The quick brown fox jumped over the lazy dog. 
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="fopen">fopen</a></h2><dl> 


<dt><b>Prototype</b></dt> <dd><tt>
FILE *<b>fopen</b>(char *<i>name</i>, char *<i>mode</i>);  
</tt></dd>

<dt><b>Description</b></dt> <dd>
<b>fopen</b> opens a file. name gives the filename to be opened. mode is 
a character string indicating how the file is to be opened. Possible 
values for mode are: 
<dl>
<dt>"r" 
<dd>for reading 
<dt>"w" 
<dd>for writing (truncates any existing file with the same 
<dd>name) 
<dt>"a" 
<dd>for appending (if file exists then open for writing at 
<dd>end of file, else create the file) 
<dt>"r+" 
<dd>for reading and writing 
<dt>"w+" 
<dd>for reading and writing (if file exists then truncate it, 
<dd>else create it) 
<dt>"a+" 
<dd>for reading and writing (if file exists, position at end 
<dd>of file, else create it) 
</dl>
<p>
In addition, a "b" may be appended to the mode string to indicate 
that the file is to be opened in binary mode (the default is text 
mode). If a file is opened for reading and writing, only reads or only 
writes can be done at any one time. To switch from reading to 
writing, or vice versa, an fseek must be performed on the stream, 
unless during input an EOF was read.<p>

If you open a file in append mode("a"), your writing is always 
appended to the end of the file, even if you call fseek or fgetpos.
</dd>

<dt><b>Return Value</b></dt> <dd>
<b>fopen</b> returns a FILE pointer to an open file. A NULL return value 
indicates an error
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fclose">fclose</a><br>
<a href="#freopen">freopen</a><br>
<a href="#_open">_open</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* Example for <b>fopen</b> */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   FILE *fp; 
   if ((fp = <b>fopen</b>("file.dat", "w")) == NULL) 
   {   
      perror("Error creating file"); 
      exit(EXIT_FAILURE); 
   } 
   printf("Opened file file.dat\n"); 
   fprintf(fp, "This is the first line\n"); 
   printf("Wrote to file\n"); 
   <a href="#fclose">fclose</a>(fp); 
   printf("Closed file\n"); 
   if ((fp = <b>fopen</b>("file.dat", "a")) == NULL) 
   {
      perror("Error creating file"); 
      exit(EXIT_FAILURE); 
   } 
   printf("Opened file file.dat for appending\n"); 
   fprintf(fp, "This is the second line\n"); 
   printf("Added to file\n"); 
   <a href="#fclose">fclose</a>(fp);
   printf("Closed file\n"); 
   return 0;
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Opened file file.dat
Wrote to file
Closed file
Opened file file.dat for appending
Added to file
Closed file 
</pre>
</dd>

 </dl>



<!-- =========================================== -->

<hr> <h2><a name="fprintf">fprintf, printf, sprintf, _snprintf</a></h2><dl>

<dt><b>Header</b></dt> <dd>stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int <b>fprintf</b>(FILE *fp, const char *format, arg0... argn);<br>
int <b>printf</b>(const char *format, arg0... argn);<br>
int <b>sprintf</b>(char *buffer, const char *format, ...);<br>
int <b>_snprintf</b>(char *buffer, size_t count, const char *format, ...); 
</tt></dd>
<dt><b>Description</b></dt> <dd>
    <b>fprintf</b> writes formatted data to the file stream <i>fp</i>.<br>
    <b>printf</b> writes formatted data to <b>stdout</b>.<br>
    <b>sprintf</b> writes formatted data to <i>buffer</i> and 0 terminates it.<br>
    <b>_snprintf</b> function differs from <b>sprintf</b> in that it stores no 
    more than <i>count</i> characters in <i>buffer</i>. 
    <p>

    Arguments are 
    interpreted according to the null-terminated <i>format</i> string.
    The <i>format</i> string is a sequence of characters with embedded 
    conversion commands. Characters that are not part of the conversion 
    command are output. Conversion commands consist of:

<pre class="bnf">'%'{flag}[<i>field_width</i>]['.' <i>precision</i>][size_and_dist] conversion_char 
</pre>
where a <b>%</b> always signifies the beginning of a conversion command. 
To print a % use <b>%%</b>.<p>
<p>

<b>Flag Characters</b><p>

    <table border=1 cellpadding=4 cellspacing=0 summary="Flag Characters">
	<tr>
	<td><b>-</b>
	<td>Means left justify the conversion
	<tr>
	<td><b>+</b>
	<td>Means that signed conversions always start with a + or -
	<tr>
	<td><i>(Space)</i>
	<td>Means that for positive conversions, the
	conversion will start with a space. The <b>+</b> flag 
	overrides the <i>(Space)</i> flag.
	<tr>
	<td><b>#</b>
	<td>For <b>x</b> or <b>X</b> conversions, if the result is non-zero 
	then a 0x or 0X will be added to the front of it. 
	For <b>o</b> conversions, a leading 0 will be added.
    </table>
<p>

For floating conversions (<b>e</b>, <b>E</b>, <b>f</b>, <b>g</b>, <b>G</b>),
a decimal point will always appear.
If it is <b>g</b> or <b>G</b>, then trailing 0's will not be truncated. 
<p>

<b>Field Width</b><p>

This is a decimal integer controlling the minimum number of 
characters printed. If the actual number of characters is less than the 
<i>field_width</i>, it is padded with blanks. If the <i>field_width</i> digit 
string begins with a 0, it is padded with a 0.
<p>

If the <i>field_width</i> is the character <b>*</b>, the actual <i>field_width</i> 
value is taken from the next int arg. If the <i>field_width</i> is 
negative, it is treated as if the <b>-</b> flag were given and the absolute 
value of the <i>field_width</i> is used.<p>

If there are more characters than allowed for by the <i>field_width</i>, 
then the width is expanded appropriately. 
<p>

<b>Precision</b><p>

Followed by a digit string specifying the precision of the conversion. 
If no digits appear after the <b>.</b>, then the precision is taken as 0.
For integral conversions, this is the minimum number of digits.
For <b>g</b> and <b>G</b>, the precision gives the maximum number of digits appearing after 
the decimal point.
For <b>s</b>, it is the maximum number of characters in a string.
If <i>precision</i> is the character <b>*</b>, the precision is taken from the
next <b>int</b> argument. 
<p>

<b>Size and Distance</b><p>

Size and distance arguments are:<p>

	<table border=1 cellpadding=4 cellspacing=0 summary="Size and Distance">
	<tr>
	<td><b>F</b>
	<td>__far pointer
	<tr>
	<td><b>N</b>
	<td>__near pointer
	<tr>
	<td><b>hh</b>
	<td>char integer
	<tr>
	<td><b>h</b>
	<td>short integer
	<tr>
	<td><b>l</b>
	<td>long integer
	<tr>
	<td><b>ll</b>
	<td>long long integer
	<tr>
	<td><b>j</b>
	<td>intmax_t or uintmax_t integer
	<tr>
	<td><b>z</b>
	<td>size_t integer
	<tr>
	<td><b>t</b>
	<td>ptrdiff_t integer
	<tr>
	<td><b>L</b>
	<td>long double
	</table>
<p>

<b>Conversion Character</b><p>

	One of the characters <b>b</b>, <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>,
	<b>a</b>, <b>A</b>, <b>f</b>, <b>F</b>, <b>e</b>, <b>E</b>, <b>g</b>, <b>G</b>, <b>c</b>, 
	<b>s</b>, <b>p</b>, <b>n</b>, <b>%</b>.
	Other characters cause undefined behavior.<p>

	<table border=1 cellpadding=4 cellspacing=0 summary="Conversion Characters">
	<tr>
	    <td><b>b, d, i, o, u, x, X</b>
	    <td>The argument is an integer and it is converted to a string 
	    of digits according to the conversion character. <b>b</b> is 
	    unsigned binary, <b>o</b> is unsigned octal, <b>u</b> is unsigned 
	    decimal, <b>x</b> and <b>X</b> are unsigned hex, <b>i</b> and <b>d</b> are signed 
	    decimal. For <b>x</b>, lower-case hex letters are used. For <b>X</b>, 
	    upper-case ones are used. If no precision is specified, it 
	    defaults to one. If there are fewer digits than precision, 
	    leading spaces are placed before the digits. If argument 
	    is 0 and precision is 0, no characters are printed. 
	<tr>
	    <td><b>c</b> 
	    <td>The least significant byte of the integer argument is 
	    printed as a character. 
	<tr>
	    <td><b>e</b>, <b>E</b> 
	    <td>The argument is a double, and is printed in scientifc 
	    notation, [-]d.dddddde+-dd. There is one digit before the 
	    decimal point and precision digits after. The precision 
	    defaults to 6. If the precision is 0, the decimal point is not 
	    written. E is used for the exponent instead of e if the <b>E</b> 
	    conversion character was specified. A minimum of two 
	    digits will appear in the exponent. 
	<tr>
	    <td><b>f</b>, <b>F</b> 
	    <td>The argument is a double. It is converted to a decimal 
	    string of the form [-]dd.dddd. The number of digits after 
	    the decimal point is given by the precision, which 
	    defaults to 6. If the precision is 0, no fractional digits or 
	    decimal points appear. The <b>F</b> will result in INF or NAN rather
	    than inf or nan. 
	<tr>
	    <td><b>g</b>, <b>G</b> 
	    <td>The argument is a double. It is printed using f or e (or E 
	    if <b>G</b> was specified) format, depending on the value of the 
	    argument. e will be used if the exponent is less than -3 or greater than the 
	    precision. The precision gives the number of significant 
	    digits; it defaults to 6. The decimal point appears if 
	    followed by a digit; trailing 0's are truncated. 

	<tr>
	    <td><b>a</b>, <b>A</b> 
	    <td> The argument is a floating point number, which is converted
	    to hex in the form [-]0x1.hhhhhp+-d, or 0 if the number is 0.hhhhh
	    are the digits of the mantissa in hex, and d is the exponent in decimal as
	    a power of 2. If no precision is specified, sufficient digits will
	    be generated to produce an exact value. Otherwise, it is rounded to
	    the specified precision. The <b>A</b> format will render the result in
	    all upper case. Trailing zeros are omitted. If the <b>#</b> flag is not
	    specified and the precision is 0, no decimal point is generated. 

	<tr>
	    <td><b>n</b> 
	    <td>The argument is a pointer to an <b>int</b>, into which is 
	    written the number of characters printed so far. No 
	    characters are generated or converted by this. 
	<tr>
	    <td><b>p</b> 
	    <td>The argument is a pointer that for far pointers is printed 
	    as segment:offset or for near pointers as xxxx. 
	<tr>
	    <td><b>s</b> 
	    <td>The argument is a pointer to a string. The characters are 
	    printed until a 0 character is encountered or the number 
	    of characters specified in precision are printed. The 
	    terminating 0 is not printed. The precision defaults to 
	    32767. 
	<tr>
	    <td><b>%</b> 
	    <td>The % character is printed. 
	</table>
</dd>

<dt><b>Return Value</b></dt> <dd>
The number of characters written or a negative value on error.<br>

	For <b>sprintf</b> and <b>_snprintf</b>, the terminating 0 character
	is not counted.<br>
	For <b>_snprintf</b>, if the number of characters required to store
	the data exceeds <i>count</i>, <i>count</i>
	characters of data are stored
	in <i>buffer</i> and -1 is returned.
	</dd>
<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fscanf">fscanf</a><br>
<a href="#vprintf">vprintf Functions</a>
	</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* Example for <b>fprintf</b> */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   char *msg = "Integer formats are: "; 
   int testint = 10; 

   <b>fprintf</b>(stdout, "%sHex: (%X) Dec: (%d) Oct: (%o) Bin: (%b)\n",
	msg, testint, testint, testint, testint); 
   return 0;
} 
</pre>

<dt><b>Output</b></dt> <dd><pre class="console">Integer formats are: Hex: (A) Dec: (10) Oct: (12) Bin: (1010) 
</pre>
</dd>
</dd>

 </dl>

<!-- =========================================== -->

<hr> <h2><a name="fputc">fputc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int fputc(int c, FILE *fp);  
</tt></dd>

<dt><b>Description</b></dt> <dd>fputc writes the character c to the stream fp. 
</dd>

<dt><b>Return Value</b></dt> <dd>
fputc returns the last character output to the stream. An EOF is 
returned on error. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fgetc"fgetc</a><br>
<a href="#_fputchar">_fputchar</a><br>
<a href="#getc">getc</a>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="fputs">fputs</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int fputs(const char *s, FILE *fp);  
</tt></dd>

<dt><b>Description</b></dt> <dd>
fputs writes the string s (excluding the terminating 0) to the stream 
fp. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns non-negative if successful, EOF if a write error occurred. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fgets">fgets</a><br>
<a href="#gets">gets</a><br>
<a href="#puts">puts</a>
</dd>

 </dl>



<!-- =========================================== -->

<hr> <h2><a name="fread">fread</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
size_t fread(const void *p, size_t sizelem, size_t n, FILE *fp);  
</tt></dd>

<dt><b>Description</b></dt> <dd>
Reads n elements from stream fp into the array that p points to. 
sizelem is the number of bytes in each element.<p> 

If sizelem or n is zero, fread doesn't change doesn't change the 
contents of the array and returns zero.
</dd>

<dt><b>Return Value</b></dt> <dd>
fread returns the number of complete elements actually read. If an 
error or an end of file is encountered, it will return less than n.
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fwrite">fwrite</a><br>
<a href="#_read">_read</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for fread */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;
#define BUFSZ 256 

int main() 
{   
   char buf[BUFSZ], fname[_MAX_PATH]; 
   int sizelem, totalnum = BUFSZ, numread; 
   FILE *fd; 

   printf("Enter filename: "); 
   gets (fname); 
   if ((fd = <a href="#fopen">fopen</a> (fname, "r")) == NULL) 
   {   
      perror("Error opening file"); 
      exit (EXIT_FAILURE); 
   } 

   sizelem = sizeof (char); 
   numread = fread (buf, sizelem, totalnum, fd); 

   printf("Total read %d\n", numread); 
   printf("Data read\n %.256s", buf); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd>
<pre class="console">Enter filename: fread.c
Total read 256
Data read
/* 		Example for fread 	*/ 


#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;
#define BUFSZ 256 

int main() 
{   
   char buf[BUFSZ], fname[_MAX_PATH]; 
   int sizelem, totalnum = BUFSZ, numread; 
   FILE *fd; 

   printf("Enter filename: "); 
   gets (fname); 
   if (
(
fd 
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="freopen">freopen</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
FILE *freopen(const char *name, const char *mode, FILE *fp); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The freopen function closes the file indicated by fp. Errors while 
closing the file are ignored. The function then opens a new file and 
associates the stream fp with it. name and mode have the same 
meaning as in <a href="#fopen">fopen</a>. 
</dd>

<dt><b>Return Value</b></dt> <dd>
freopen returns fp if successful, otherwise a NULL. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fclose">fclose</a><br>
<a href="#fopen">fopen</a><br>
<a href="#_open">_open</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for freopen */ 
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;
#include &lt;stdio.h&gt;

int main() 
{   
   FILE *fp; 
   char fname1[_MAX_PATH], fname2[_MAX_PATH]; 

   printf("Enter the first filename: "); 
   gets (fname1); 

   printf("Enter the second filename: "); 
   gets (fname2); 

   if ((fp = <a href="#fopen">fopen</a> (fname1, "r")) == NULL) 
   {   
      perror("Could not open first file"); 
      exit (EXIT_FAILURE); 
   } 
   printf("File \"%s\" is now open\n", fname1); 

   if ((fp = freopen (fname2, "r", fp)) == NULL) 
   {   
      perror("Could not reopen to second file"); 
      exit (EXIT_FAILURE); 
   } 
   printf("File \"%s\" closed and \"%s\" is now 
	     open\n", fname1, fname2); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter the first filename: fread.c
Enter the second filename: freopen.c
File "fread.c" is now open
File "fread.c" closed and "freopen.c" is now open
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="fscanf">fscanf, scanf, sscanf</a></h2><dl>

<dt><b>Header</b></dt> <dd>stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int <b>fscanf</b>(FILE *<i>fp</i>, const char *<i>format</i>, ...);<br>
int <b>scanf</b>(char *<i>format</i>, ...);<br>
int <b>sscanf</b>(const char *<i>buffer</i>, const char *<i>format</i>, ...); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
<b>fscanf</b> reads characters from the input stream <i>fp</i>.<br>
<b>scanf</b> reads characters from the input stream <b>stdin</b>.<br>
<b>sscanf</b> reads characters from the string <i>buffer</i>.
<p>

Characters read are 
converted according to the <i>format</i> string and the values created are 
stored through the argument pointers. Note that the arguments are 
pointers to where values will be stored.<p>

The <i>format</i> string consists of:<p>

<ul>
<li> Spaces, tabs, and newlines that cause input to be 
skipped up to the next character, which is not 
whitespace.<br> 
<li> Other characters, except for %, that are matched against 
the input.<br> 
<li> Conversion specifications:
<pre class="bnf">%[*][<i>field_width</i>][<i>size</i>][<i>dist</i>]<i>conv_char</i> 
</pre>
</ul>


The conversion specification specifies how input characters are to be 
converted and assigned through the corresponding argument 
pointers. Conversion continues until a conflicting input character is 
encountered or the <i>field_width</i> is reached. * is an assignment 
suppression flag. It causes the conversion to be performed but the 
result is ignored. There is no corresponding argument pointer for 
this. If there are less argument pointers than conversion specification 
the results are unpredictable. If there are extra argument pointers the 
excess ones are ignored. 
<p>

<b>Field Width</b><p>

<i>field_width</i> is a sequence of decimal digits specifying the 
maximum number of characters in the field. 
<p>

<b>Size</b><p>

	<table border=1 cellpadding=4 cellspacing=0>

	<tr>
	<td>hh
	<td> The following b,d,i,o,u,x,X or n refers to an argument that
	is a pointer to a char.

	<tr>
	<td>h 
	<td>Argument is a pointer to a short. 

	<tr>
	<td> l
	<td> A following b,d,i,o,u,x,X or n refers to an argument that
	is a pointer to a long. A following a,A,e,E,f,F,g,G refers
	to an argument that is a pointer to a double. A following c, s
	or [ refers to an argument that is a pointer to a wchar_t.

	<tr>
	<td> ll
	<td> A following b,d,i,o,u,x,X or n refers to an argument that
	is a pointer to a long long.

	<tr>
	<td> j
	<td> A following b,d,i,o,u,x,X or n refers to an argument that
	is a pointer to a intmax_t.

	<tr>
	<td> z
	<td> A following b,d,i,o,u,x,X or n refers to an argument that
	is a pointer to a size_t.

	<tr>
	<td> t
	<td> A following b,d,i,o,u,x,X or n refers to an argument that
	is a pointer to a ptrdiff_t.

	<tr>
	<td>L 
	<td> A following a,A,e,E,f,F,g,G refers
	to an argument that is a pointer to a long double.

	</table>
	<p>

<b>Distance</b><p>

	The distance characters for the next argument are:<p>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<td>N 
	<td>Near pointer 
	<tr>
	<td>F 
	<td>Far pointer 
	</table>
	<p>

<b>Conversion Character</b><p>

	The conversion characters are:<p>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<td>b 
	<td>A binary number is expected, the argument pointer must 
	be a pointer to an int.<br>
	<tr>
	<td>d 
	<td>An integer is expected, the argument pointer must be a 
	pointer to an int. 
	<tr>
	<td>a, e, f, g
	<td>A floating-point number is expected. Argument pointer 
	must be a pointer to a float (double if l or L is used). 
	<tr>
	<td>i 
	<td>An integer is expected. If it starts with a 0, it is taken to be 
	octal. If it starts with 0x or 0X, it is hexadecimal. The 
	argument pointer must be a pointer to an int. 
	<tr>
	<td>o 
	<td>An octal number is expected. The argument pointer must 
	be a pointer to an int. 
	<tr>
	<td>p 
	<td>A hexadecimal integer is expected. The argument pointer 
	must be a pointer to a pointer. 
	<tr>
	<td>u 
	<td>An unsigned int is expected, the argument pointer 
	must be a pointer to an unsigned. 
	<tr>
	<td>n 
	<td>An int value is stored through the corresponding 
	argument pointer, specifying the number of characters 
	read up to this point by this call to <b>fscanf</b>. 
	<tr>
	<td>[
	<td>A string is expected. Between the [and a closing ] are 
	characters acceptable to the string. If the [is immediately 
	followed by a ^, acceptable characters for the string are all 
	those except the ones between the ^ and the ] . The 
	argument pointer must be a pointer to a character array. A 
	NULL character is appended to the string. 
	<tr>
	<td>s 
	<td>A string is expected. The argument pointer must be a 
	pointer to a string. The input field extends until a space or 
	newline is read, which is not part of the field. A NULL 
	character is appended to the string. 
	<tr>
	<td>c 
	<td>A character is expected. The argument pointer must be a 
	pointer to a character. If a <i>field_width</i> is specified, 
	then that many characters are read and the argument 
	pointer must point to a character array large enough to 
	hold the result. 
	<tr>
	<td>% 
	<td>Match the input with a %.
	</table><p>

The conversion characters a, e, f, g, and x may be uppercase, with no 
difference in meaning. Other conversion characters will cause 
unexpected results. Conflicting characters are left unread in the input 
stream. There is no direct way to determine if suppressed 
assignments or literal matches succeeded, unless %n is used. 
</dd>

<dt><b>Return Value</b></dt> <dd>
The number of assigned input items excluding any assignment 
suppressed conversions. If end of file is encountered before 
assignments are done or before conflicts occur, EOF is returned. 
<b>fscanf</b> returns when it reaches the end of the <i>format</i> string. 
</dd>
<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fprintf">fprintf</a><br>
</dd>
<dt><b>Example</b></dt> <dd>
<pre class="ccode">/* Example for <b>fscanf</b> */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   char first[16], last[16]; 
   int age; 
   int res; 

   printf("Enter your first and last name in 
	     the form \" first last\": "); 
   res = <b>fscanf</b>(stdin, "%s %s", first, last); 
   if (res != 2) 
   {   
      printf("Error reading name.\n"); 
      exit (EXIT_FAILURE); 
   } 

   printf("Your name is %s %s.\n", first, last); 
   printf("How old are you %s? ", first); 
   res = <b>fscanf</b>(stdin, "%d", &age); 

   if (res != 1) 
   {   
      printf("Error reading age.\n"); 
      exit(EXIT_FAILURE); 
   } 
   printf("Oh, %d.\n", age);

   return 0;
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter your first and last name in the form
"first last": John Doe
Your name is John Doe.
How old are you John? 32
Oh, 32.
</pre>
</dd>

<dt><b>Example 2</b><p><dd>

<pre class="ccode">/* Example of <b>sscanf</b> */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt; 

int main() 
{   
   char *buf = "1.24..."; 
   char str[8]; 
   float f; 
   int i; 

   <b>sscanf</b>(buf, "%s", str); 
   <b>sscanf</b>(buf, "%f", &f); 
   <b>sscanf</b>(buf, "%d", &i); 

   printf("Scanned \"%s\" for a string, float and integer\n", buf); 
   printf("String: \"%s\"\n", str); 
   printf("Float: %f\n", f); 
   printf("Integer: %d\n", i);

   return 0;
} 
</pre>
<p>

<dt><b>Output</b></dt> <dd><pre class="console">Scanned "1.24..." for a string, a float and an integer
String: "1.24..."
Float: 1.240000
Integer: 1
</pre>
</dd>


 </dl>

<!-- =========================================== -->

<hr> <h2><a name="fseek">fseek</a></h2><dl> 


<dt><b>Header</b></dt> <dd>
stdio.h

</dd>
<dt><b>Prototype</b></dt> <dd><tt>
int <b>fseek</b>(FILE *<i>fp</i>, long <i>offset</i>, int <i>origin</i>);

</tt></dd>

<dt><b>Description</b></dt> <dd>
Sets the file position associated with the stream <i>fp</i>.
<i>offset</i> is the 
signed offset in bytes relative to that specified by <i>origin</i>.
Values for 
<i>origin</i> are defined in io.h and stdio.h: 
<p>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<th><i>origin</i>
	<th>Description
	<tr>
	<td>SEEK_SET
	<td>Beginning of file 
	<tr>
	<td>SEEK_CUR
	<td>Current position 
	<tr>
	<td>SEEK_END 
	<td>End of file 
	</table>
	<p>

If the file is opened in text mode, <i>offset</i> can be only a value 
returned by ftell and <i>origin</i> can be only SEEK_SET, or <i>offset</i> 
must be 0. If an ungetc was called immediately before <b>fseek</b>, 
ungetc is undone. If the file was opened in read/write mode (see 
<a href="#fopen">fopen</a>) following <b>fseek</b>, reading or writing may be performed. 
</dd>

<dt><b>Return Value</b></dt> <dd>
<b>fseek</b> returns 0 if the pointer was successfully moved. <b>fseek</b> 
returns a non-zero value if an error occurs. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#ftell">ftell</a><br>
<a href="io.html#_lseek">_lseek</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* Example of <b>fseek</b> */ 
#include &lt;io.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   FILE *fp; 
   long offset, lpos; 
   char c; 

   fp = <a href="#fopen">fopen</a>("\\dm\\include\\io.h", "r"); 
   if (fp &lt; 0) 
      perror("Error opening file"); 
   else 
   {   
      offset = 35L; 
      if (<b>fseek</b> (fp, offset, SEEK_SET) != 0) 
      {   
	   perror("Error seeking"); 
	   exit (EXIT_FAILURE); 
      } 
      c = fgetc(fp); 
      printf("Character at position 35 is %d\n", c); 

      offset = 10L; 
      if (<b>fseek</b> (fp, offset, SEEK_CUR) != 0) 
      {   
	    perror("Error seeking"); 
	    exit (EXIT_FAILURE); 
      } 
      c = fgetc(fp); 
      printf("Character at prior position + 10 is %d\n", c); 

      offset = 0L; 
      if (<b>fseek</b> (fp, offset, SEEK_END) != 0) 
      {   
	    perror("Error seeking"); 
	    exit (EXIT_FAILURE); 
      } 
      c = fgetc(fp); 
      printf("Character at end of file is %d\n", c); 
      <a href="#fclose">fclose</a>(fp); 
   } 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Character at position 35 is 116
Character at prior position + 10 is 105
Character at end of file is -1
</pre>
</dd>

 </dl>



<!-- =========================================== -->

<hr> <h2><a name="fsetpos">fsetpos</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int fsetpos(FILE *fp, const fpos_t *pos);  
</tt></dd>

<dt><b>Description</b></dt> <dd>
The function fsetpos restores the position of the stream fp as 
previously saved in pos by a call to fgetpos. 
</dd>

<dt><b>Return Value</b></dt> <dd>
0 if successful, otherwise non-zero with errno set.
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fgetpos">fgetpos</a>
</dd>

<dt><b>Example</b></dt> <dd>
See fgetpos
</dd>

 </dl>



<!-- =========================================== -->

<hr> <h2><a name="ftell">ftell</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
long ftell(FILE *fp);  
</tt></dd>

<dt><b>Description</b></dt> <dd>
ftell returns the current position in the file associated with the 
stream fp. If the file is opened in text mode, the returned value may 
not accurately reflect the number of bytes actually read or written. 
</dd>

<dt><b>Return Value</b></dt> <dd>
ftell returns the current file position. If an error occurs -1 is 
returned and errno is set. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fseek">fseek</a><br>
<a href="#_isatty">_isatty</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for ftell */ 
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;
#include &lt;stdio.h&gt; 
#include &lt;io.h&gt;
#include &lt;<a href="string.html">string.h</a>&gt;

int main() 
{   
   char fname[_MAX_PATH]; 
   char line[128]; 
   FILE *fp; 
   long offset; 

   printf("Enter a filename: "); 
   gets (fname); 

   if ((fp = <a href="#fopen">fopen</a>(fname, "r")) == NULL) 
   {   
      perror("Unable to open input file"); 
      exit (EXIT_FAILURE); 
   } 

   setbuf(fp, NULL); 
   fgets(line, 128, fp); 

   if (line[strlen (line) -1] == '\n') 
      line[strlen (line) -1] = '\x00'; 

   offset = ftell(fp); 

   printf("After reading the first line in file 
	   \"%s\":\n \"%s\"\n", fname, line); 

   printf("The file pointer is at offset: 
	   %d\n", offset); 

   <a href="#fclose">fclose</a>(fp); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Enter a filename: ftell.c
After reading the first line in file "ftell.c":
  "/*"
The file pointer is at offset: 4
</pre>
</dd>

 </dl>



<!-- =========================================== -->

<hr> <h2><a name="fwrite">fwrite</a></h2><dl> 

<dt><b>Prototype</b></dt> <dd><tt>
size_t <b>fwrite</b>(const void *<i>buffer</i>, size_t <i>sizelem</i>,<br>
   &nbsp;size_t <i>n</i>, FILE *<i>fp</i>); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The function <b>fwrite</b> writes <i>n</i> elements of <i>sizelem</i> bytes from
<i>buffer</i> to the stream <i>fp</i>. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns the number of complete elements actually written, which 
may be less than <i>n</i> if an error occurred. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fread">fread</a>
</dd>

<dt><b>Example</b></dt> <dd>
<pre class="ccode">/* Example for fwrite */ 
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;
#include &lt;stdio.h&gt; 
#include &lt;<a href="string.html">string.h</a>&gt;

int main() 
{   
   FILE *fp; 
   char *str = "Write this data to file"; 
   char buffer[128]; 
   int count, nwritten, nread; 

   count = strlen (str) + 1; 

   fp = <a href="#fopen">fopen</a>("file.dat", "w+"); 

   if (fp == NULL) 
   {   
      perror("Unable to create file: file.dat"); 
      exit (EXIT_FAILURE); 
   } 

   printf("Writing string \"%s\" to file...\n", 
	     str); 
   nwritten = <b>fwrite</b>(str, sizeof(char), count, fp); 
   printf("%d bytes written\n", nwritten); 
   rewind(fp); 
   printf("Reading back from file...\n"); 
   nread = fread(buffer, sizeof(char), count, fp); 
   printf("%d bytes read from file\nString read 
	    is \"%s\"\n", nread, buffer); 
   <a href="#fclose">fclose</a>(fp); 
   return 0;
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Writing string "Write this data to file" to
file...
24 bytes written
Reading back from file...
24 bytes read from file
String read is "Write this data to file"
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="getc">getc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int getc(FILE *fp);  
</tt></dd>

<dt><b>Description</b></dt> <dd>
getc obtains one character from the stream fp. Input is line-buffered 
and therefore a carriage return is required before the 
character is returned. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns the next character of the line read. Otherwise, returns a 
value of EOF on error. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fgetc">fgetc</a><br>
<a href="#_getch">_getch</a><br>
<a href="#getchar">getchar</a><br>
<a href="#_getche">_getche</a><br>
<a href="#putc">putc</a><br>
<a href="#ungetc">ungetc</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for getc */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   int input; 

   printf("Input a character then hit return: "); 
   input = getc(stdin); 
   printf("'%c' was returned by getc()\n", input); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Input a character then hit return: g 'g' was returned by getc() 
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="getchar">getchar</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int getchar(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The getchar function gets a character from the stream stdin. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns the next character read. On error returns a value of EOF. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fgetc">fgetc</a><br>
<a href="#getc">getc</a><br>
<a href="#getchar">getchar</a><br>
<a href="#_getche">_getche</a><br>
<a href="#putchar">putchar</a><br>
<a href="#_getch">_getch</a><br>
<a href="#ungetc">ungetc</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for getchar */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt; 

int main() 
{   
   int input; 

   printf("Input a character then press 
	     return: "); 
   input = getchar(); 
   printf("'%c' was returned by getchar()\n", 
	  input); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Input a character then press return: g 'g' was returned by getchar() 
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="gets">gets</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
char *gets(char *str); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
Read characters from stdin into the string str until a newline is 
read or an end-of-file is encountered. Newlines are not written to the 
string. The string is terminated with a NULL character. str must be 
large enough to hold the resulting string. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns str if successful. A NULL is returned if an end-of-file is 
encountered and no characters have been written to str, or if a 
read error occurs. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fgets">fgets</a><br>
<a href="#puts">puts</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for gets
	Also demonstrates puts 
	gets.c 
*/ 

#include &lt;stdio.h&gt; 
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   char buffer[128]; 

   printf("Type something: "); 
   gets (buffer); 
   printf("You typed: "); 
   puts (buffer); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">c:\dm\examples&gt; gets 
Type something: Hello there 
You typed: Hello there 
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="putc">putc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int putc(int c, FILE *fp); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The putc function writes the character c to the stream fp.
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns the character just written. EOF is returned if an error occurs. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fputc">fputc</a><br>
<a href="#getc">getc</a><br>
<a href="#putchar">putchar</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for putc */ 
#include &lt;stdio.h&gt;
#include &amp;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   char *string = "This is an example of putc()";
   char *scan = string; 

   while (* scan)
   {   
      if (putc(* scan, stdout) == EOF)
	 exit(EXIT_FAILURE); 
      scan++;
   } 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">This is an example of putc() 
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="putchar">putchar</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int putchar(int c); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The putchar function writes the character c to the standard output 
stream, stdout (usually the screen). 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns the character just written. EOF is returned if an error occurs. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fputc">fputc</a><br>
<a href="#getchar">getchar</a><br>
<a href="#putc">putc</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for putchar */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   char *string = "This is an example of putchar()"; 
   char *scan = string; 

   while (* scan)
   {   
      if (putchar(* scan) == EOF)
      exit(EXIT_FAILURE); 
      scan++;
   } 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">This is an example of putchar() 
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="puts">puts</a></h2><dl> 


<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int puts(const char *s); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The puts function writes the string s to stdout (without the 
terminating 0), and then writes a newline to stdout. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns a positive value if successful, otherwise EOF. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fprintf">fprintf</a><br>
<a href="#fputs">fputs</a><br>
<a href="#gets">gets</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for puts */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   char *str1 = "Display this string using puts()."; 
   char *str2 = "Notice that puts() adds a
		 newline to the end."; 

   puts (str1);
   puts (str2); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Display this string using puts().
Notice that puts() adds a newline to the end. 
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="rewind">rewind</a></h2><dl> 


<dt><b>Prototype</b></dt> <dd><tt>
void <b>rewind</b>(FILE *<i>fp</i>); 
</tt></dd>

<dt><b>Description</b></dt> <dd>rewind repositions the file pointer associated with a stream to the 
beginning of the file. This is equivalent to using 
<a href="#fseek">fseek</a>(<i>fp</i>, 0L, SEEK_SET), with the error flag for <i>fp</i> being
cleared. 
</dd>

<dt><b>Return Value</b></dt> <dd>
None
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fseek">fseek</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* Example for rewind */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt; 

int main()
{   
   FILE *fp; 
   char *str1 = "String one, example string."; 
   char *str2 = "xxxxxxxxxxxxx";
   char buffer[80]; 

   fp = <a href="#fopen">fopen</a>("file.dat", "w+");
   fprintf(fp, "%s", str1); 
   <b>rewind</b>(fp);
   fprintf(fp, "%s", str2); 
   <b>rewind</b>(fp);
   <a href="#fgets">fgets</a>(buffer, 80, fp); 
   printf("The value read back is: \"%s\"\n", buffer); 
   return 0;
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">The value read back is: "xxxxxxxxxxxxxxample string." 
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="setbuf">setbuf</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
void setbuf(FILE *stream, char *buffer); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The setbuf function sets the buffering system for bytes read or 
written to a stream. If the buffer argument is NULL, the stream is 
unbuffered. If buffer is not NULL, it is taken to be a pointer to the 
buffer which is to be used for subsequent read and write calls. 
buffer must point to a character array of size BUFSIZ (defined in 
stdio.h). The user specified buffer is used then instead of the 
default system-allocated I/ O buffer. 
</dd>

<dt><b>Return Value</b></dt> <dd>
None
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#setvbuf">setvbuf</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for setbuf */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main()
{   
   FILE *fp;
   char buffer[BUFSIZ]; 

   fp = <a href="#fopen">fopen</a>("file.dat", "w+");
   setbuf (fp, buffer); 
   printf("Stream has been set to buffer at 
	     %Fp\n", buffer); 
   setbuf (fp, NULL);
   printf("Now stream buffering has been 
	     turned off\n");
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Stream has been set to buffer at 0334: 15F0
Now stream buffering has been turned off
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="setvbuf">setvbuf</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int setvbuf(FILE *fp, char *buf, int mode, size_t size);  
</tt></dd>

<dt><b>Description</b></dt> <dd>setvbuf specifies the type and size of a buffer used for a stream. In 
addition to the function parameters the following global variable 
affects the behaviour of this function: _okbigbuf, which is used 
only in the T, S, and M memory models under MS-DOS. _okbigbuf 
controls how buffers are allocated when buf is NULL. It is statically 
initialized to 0 or 1 by the programmer (the library sets it to 1 by 
default). If _okbigbuf is 1 and the memory model is T, S, or M: 
setvbuf tries to allocate a buffer outside of the data segment. If 
that fails, and size &lt;= BUFSIZ, then setvbuf tries to allocate a 
buffer within the data segment. A buffer that is outside the data 
segment is marked by setting _IOBIGBUF in fp-&gt;_flags. If 
_okbigbuf is 0 or the memory model is C or L: setvbuf tries to 
allocate a buffer within the data segment. A buffer allocated by 
setvbuf is flagged by _IOMYBUF being set in fp-&gt;_flags.<p>

The function parameters are: <p>
<dl>
<b>Argument/Description</b>
<dt>fp
<dd>Stream pointer that is already opened, but before any reads or writes have been done to the stream. 
<dt>buf
<dd>Pointer to buffer, or NULL. If NULL, then setvbuf uses malloc or faralloc to allocate a buffer of size bytes. If buf is not NULL, it points to a buffer that setvbuf causes to be associated with the stream fp. 
<dt>mode
<dd>Buffering mode. Use a value from the next table. 
<dt>size
<dd>If buf is NULL, size is the number of bytes to allocate for the buffer. If buf is not NULL, size must be the number of bytes in the buffer that buf points to. 
</dl>
<p>

mode can be one of these values: <p>
<dl>
<b>Constant/Description</b> 
<dt>_IONBF
<dd>No buffering. buf and size are ignored. Unbuffered I/ O means data written is immediately passed to DOS.  When data is read, exactly enough is read. 
<dt>_IOLBF
<dd>Do line buffering. The actual I/ O is performed when a newline is read or written. 
<dt>_IOFBF
<dd>Full buffering. Data are read a full buffer at a time and are written only when the buffer is full. 
</dl>
</dd>

<dt><b>Return Value</b></dt> <dd>
If the call succeeds, the various fields that fp points to are updated 
to show the buffer and 0 is returned. If memory is insufficient for the 
buffer or if the mode parameter is invalid, non-zero is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#setbuf">setbuf</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of setvbuf */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

#define OURBUFSIZE 1024 

int main() 
{   
   FILE *fp; 
   char buffer[OURBUFSIZE]; 

   fp = <a href="#fopen">fopen</a>("file.dat", "w+"); 
   setvbuf (fp, buffer, _IOFBF, OURBUFSIZE); 
   printf("Stream buffering has been set to 
	     %d bytes at %Fp\n", OURBUFSIZE, 
	buffer); 
   setvbuf (fp, NULL, _IONBF, 0); 
   printf("Now stream buffering has been 
	     turned off\n"); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Stream buffering has been set to 1024 bytes at
0340: 1400
Now stream buffering has been turned off
</pre>
</dd>
 </dl>




<!-- =========================================== -->

<hr> <h2><a name="stderr">stderr</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern FILE *stderr; 
</tt></dd>

<dt><b>Description</b></dt> <dd>stderr is a constant FILE pointer to the standard error stream,	which is usually the console display. To print error messages that users must see, stderr is preferred over stdout. Due to file redirection, errors printed to stdout can end up in files, whereas stderr cannot be redirected. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_stdaux">_stdaux</a><br>
<a href="#stdin">stdin</a><br>
<a href="#stdout">stdout</a><br>
<a href="#_stdprn">_stdprn</a>
</dd>

 </dl>




<!-- =========================================== -->

<hr> <h2><a name="stdin">stdin</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern FILE *stdin; 
</tt></dd>

<dt><b>Description</b></dt> <dd>stdin is a constant FILE pointer to the standard input stream, which is usually the keyboard or a redirected file. When the user redirects a file using the input redirection operator (&lt;) or the pipe operator(|),	the redirected data will arrive on the stdin stream. Filter programs,	such as the DOS programs MORE and SORT, use stdin.</dd>
Some functions use the stdin stream by default. Examples are getchar and scanf functions. getchar() is the same as getc(stdin), only shorter.
<p>


<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_stdaux">_stdaux</a><br>
<a href="#stderr">stderr</a><br>
<a href="#stdout">stdout</a><br>
<a href="#_stdprn">_stdprn</a>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="stdout">stdout</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern FILE *stdout;
</tt></dd>

<dt><b>Description</b></dt> <dd>stdout is a constant FILE pointer to the standard output stream, which is usually the console display or a redirected file. When a user redirects a file using the output redirection operator (&gt;) or the pipe	operator (|), the redirected data will go out to the stdout stream.  Filter programs, such as DOS programs MORE and SORT, use stdout.</dd> 
Some functions use the stdout stream by default. Examples are the putchar and printf. Function putchar('a') is the same as putc(stdout, 'a'), only shorter.<p>
stdout and the other standard streams do not need to be opened or closed. They are set to their standard devices or redirected to files by the operating system before a program begins. All files are closed when a program termines.
<p>


A program that spawns a child process can use freopen to set the standard file pointers for the child process. 
<p>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_stdaux">_stdaux</a><br>
<a href="#stderr">stderr</a><br>
<a href="#stdin">stdin</a><br>
<a href="#_stdprn">_stdprn</a>
</dd>

 </dl>




<!-- =========================================== -->

<hr> <h2><a name="tmpfile">tmpfile</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
FILE *tmpfile(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The tmpfile function creates a temporary file and returns a pointer 
to the stream associated with the file. The file is automatically 
deleted when it is closed or when the program terminates normally, 
as long as the current working directory does not change. The 
temporary file is opened in binary read/ write mode. 
</dd>

<dt><b>Return Value</b></dt> <dd>
Returns a stream pointer. If unsuccessful, a NULL pointer is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_rmtmp">_rmtmp</a><br>
<a href="#_tempnam">_tempnam</a><br>
<a href="#tmpnam">tmpnam</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for tmpfile */ 
#include &lt;stdio.h&gt; 
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   FILE *fp; char *str = "The quick brown dog jumped over 
			  the lazy cat"; 
   char buf[128]; 

   if ((fp = tmpfile ()) == NULL) 
   {   
      perror("Could not open temporary file"); 
      exit (EXIT_FAILURE); 
   } 

   printf("Created temporary file\n"); 
   printf("Writing to file: \"%s\"\n", str); 
   fputs (str, fp); 
   rewind(fp); 
   fgets (buf, 128, fp); 
   printf("Read from file: \"%s\"\n", buf); 
   <a href="#fclose">fclose</a>(fp); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Created temporary file
Writing to file: "The quick brown dog jumped
over the lazy cat"
Read from file: "The quick brown dog jumped over
the lazy cat"
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="tmpnam">tmpnam</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h 
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
char *tmpnam(const char *s); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
The tmpnam function generates a unique temporary filename that is 
valid, but not the same as, the name of any existing file. tmpnam 
generates a different string each time it is called, with a maximum 
defined by the macro TMP_MAX, found in stdio.h. The argument 
passed to tmpnam can be either a pointer to a buffer, which should 
be L_tmpnam characters, or a NULL pointer. The path of the file 
name will be P_tmpdir. 
</dd>

<dt><b>Return Value</b></dt> <dd>
If the argument passed to tmpnam is a pointer to a buffer, the 
temporary filename is placed in this buffer, and the return value is a 
pointer to this buffer. If the argument to tmpnam is a NULL pointer, 
the file name is placed in a static data area, overwritten at each call 
to tmpnam, and a pointer to this static data buffer is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#_tempnam">_tempnam</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for tmpnam */ 
#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;

int main() 
{   
   char *name; 

   if ((name = tmpnam (NULL)) == NULL) 
   {   
      perror("Unable to create temporary 
		filename"); 
      exit (EXIT_FAILURE); 
   } 

   printf("Temporary filename \"%s\" 
	     created.\n", name); 

   free (name); 
} 
</pre>
</dd>

 </dl>


<!-- =========================================== -->

<hr> <h2><a name="ungetc">ungetc</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int ungetc(int c, FILE *fp); 
</tt></dd>

<dt><b>Description</b></dt> <dd>
Puts character <i>c</i> back into the input stream <i>fp</i>, where it is read by 
the next input operation on the stream. If an <b>fseek</b>, <b>fsetpos</b>, or 
<b>rewind</b> is done between an <b>ungetc</b> and the next read, the 
character is lost. Only one character may be put back between reads. 
<b>EOF</b> cannot be placed back. If <b>ungetc</b> is called at the end of a file, 
<b>ungetc</b> clears the EOF indicator. 
</dd>

<dt><b>Return Value</b></dt> <dd>
<i>c</i> if successful; otherwise <b>EOF</b> if the character cannot be pushed 
back. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#getc">getc</a><br>
<a href="#_ungetch">_ungetch</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* Example for ungetc */ 

#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;
#include &lt;<a href="string.html">string.h</a>&gt;

#define delim "\n\r\t\v " 

int isdelim(int c) 
{   
   return (strchr(delim, c) != NULL); 
} 

char *gettoken(FILE *fp) 
{   
   static char tokbuf[128]; 
   int c; 
   int pos = 0; 

   c = fgetc(fp); 
   if (c == EOF) 
   {   
      if (!feof(fp)) 
	 perror("error reading from file"); 
      return NULL; 
   } 

   if (isdelim(c)) 
      do 
      {   
	 c = fgetc(fp); 
      } while ((isdelim (c)) &amp;&amp; (c != EOF)); 

   if (c != EOF) 
      do 
      {   
	 tokbuf[pos] = c; 
	 pos++; 
	 c = fgetc(fp); 
      } while ((!isdelim(c)) &amp;&amp; (c != EOF)); 

   <b>ungetc</b>(c, fp); 
   tokbuf[pos] = '\x00'; 
   return tokbuf; 
} 

int main() 
{   
   char fname[_MAX_PATH]; 
   char *token; 
   FILE *fp; 

   printf("Enter filename: "); 
   gets(fname); 

   if ((fp = <a href="#fopen">fopen</a>(fname, "r")) == NULL) 
   {   
      perror("Unable to open file"); 
      exit(EXIT_FAILURE); 
   } 
   do 
   {   
      token = gettoken(fp); 
      printf("%s\n", token); 
   } while (!feof(fp)); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console"> Enter filename: ungetc.c
 /* Example for 

 ungetc 
 */ 
 #include 
 &ltstdio.h&gt; 
 #include 
 &ltstdlib.h&gt;
 . 
 . 
 . 
 = 
 gettoken 
 (fp); 
 printf 
("%s\n", 
 token); 
 } 
 while (! feof(fp)); 
 } 
</pre>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="vprintf">vprintf</a></h2><dl> 

<dt><b>Header</b></dt> <dd>
stdio.h<br>
stdarg.h<br>
varargs.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>
int <b>vfprintf</b>(FILE *stream, const char *format, va_list arg_ptr);<br>
int <b>vprintf</b>(const char *format, va_list arg_ptr);<br>
int <b>_vsnprintf</b>(char *buffer, size_t count, const char *format, va_list arg_ptr);<br>
int <b>vsprintf</b>(char *buffer, const char *format, va_list arg_ptr);<br>
</tt></dd>

<dt><b>Description</b></dt> <dd>
These functions format and send data to the appropriate place. 
<b>vfprintf</b> sends data to the file specified by <i>stream</i>;
<b>vprintf</b> sends data to standard output;
<b>vsprintf</b> and <b>_vsnprintf</b> send 
data to the memory pointed to by <i>buffer</i>.
The <b>_vsnprintf</b> 
function differs from <b>vsprintf</b> in that it writes not more than 
<i>count</i> bytes to <i>buffer</i>.<p> 

These functions are similar to <b>printf</b>, <b>fprintf</b> and <b>sprintf</b> 
except the data are taken from the <i>arg_ptr</i>. 
</dd>

<dt><b>Return Value</b></dt> <dd>
The number of characters written, not counting the terminating null 
character. If an error occurs, a negative value is returned. For 
<b>_vsnprintf</b>, if the number of bytes to write exceeds <i>count</i>, then 
<i>count</i> bytes are written and -1 is returned. 
</dd>

<dt><b>Compatibility</b></dt> <dd>
DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd>
<a href="#fprintf">fprintf</a><br>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for vfprintf
	Also demonstrates vprintf, _vsnprintf, 
	vsprintf 
*/ 

#include &lt;stdio.h&gt;
#include &lt;<a href="stdlib.html">stdlib.h</a>&gt;
#include &lt;stdarg.h&gt;

void echo_err_printf(char *format, ...) 
{   
   va_list arg_ptr; 

   va_start(arg_ptr, format); 
   <b>vfprintf</b>(stderr, format, arg_ptr); 
   va_end(arg_ptr); 

   va_start(arg_ptr, format); 
   <b>vprintf</b>(format, arg_ptr); 
   va_end(arg_ptr); 
} 

int main() 
{   
   echo_err_printf("Error: %d\n", 12); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Error: 12
Error: 12
</pre> 
</dd>
 </dl>



<br><br><br><br>

</td></table>




<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

