
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - dos.h part 2
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:14 2006
</div>
</div>

<!-- Generated by Ddoc from dos2.d -->



$(RTL_S


<h1>dos.h part 2</h1>

<dl><dl>
	<dt><a href="#_bdos"><b>_bdos</b></a>
	<dt><a href="#_chain_intr"><b>_chain_intr</b></a>
	<dt><a href="#_disable"><b>_disable</b></a>
	<dt><a href="#_enable"><b>_enable</b></a>
	<dt><a href="#_FP"><b>_FP_OFF, _FP_SEG</b></a>
	<dt><a href="#_getdcwd"><b>_getdcwd</b></a>
	<dt><a href="#_hard"><b>_harderr, _hardresume, _hardretn</b></a>
	<dt><a href="#_inp"><b>_inp, _inpw, _inpl</b></a>
	<dt><a href="#_intdos"><b>_intdos</b></a>
	<dt><a href="#_intdosx"><b>_intdosx</b></a>
	<dt><a href="#_MK_FP"><b>_MK_FP</b></a>
	<dt><a href="#_osversion"><b>_osversion</b></a>
	<dt><a href="#_outp"><b>_outp, _outpw, _outpl</b></a>
	<dt><a href="#_segread"><b>_segread</b></a>
	<dt><a href="#allocmem"><b>allocmem</b></a>
	<dt><a href="#bdosptr"><b>bdosptr</b></a>
	<dt><a href="#bdosx"><b>bdosx</b></a>
	<dt><a href="#farcalloc"><b>farcalloc</b></a>
	<dt><a href="#farcoreleft"><b>farcoreleft</b></a>
	<dt><a href="#farfree"><b>farfree</b></a>
	<dt><a href="#farmalloc"><b>farmalloc</b></a>
	<dt><a href="#farrealloc"><b>farrealloc</b></a>
	<dt><a href="#findfirst"><b>findfirst</b></a>
	<dt><a href="#findnext"><b>findnext</b></a>
	<dt><a href="#freemem"><b>freemem</b></a>
	<dt><a href="#geninterrupt"><b>geninterrupt</b></a>
	<dt><a href="#getcbrk"><b>getcbrk</b></a>
	<dt><a href="#getcurdir"><b>getcurdir</b></a>
	<dt><a href="#getdate"><b>getdate</b></a>
	<dt><a href="#getdisk"><b>getdisk</b></a>
	<dt><a href="#getdta"><b>getdta</b></a>
	<dt><a href="#getfat"><b>getfat</b></a>
	<dt><a href="#getfatd"><b>getfatd</b></a>
	<dt><a href="#getpsp"><b>getpsp</b></a>
	<dt><a href="#gettime"><b>gettime</b></a>
	<dt><a href="#getverify"><b>getverify</b></a>
	<dt><a href="#parsfnm"><b>parsfnm</b></a>
	<dt><a href="#peek"><b>peek</b></a>
	<dt><a href="#peekb"><b>peekb</b></a>
	<dt><a href="#poke"><b>poke</b></a>
	<dt><a href="#pokeb"><b>pokeb</b></a>
	<dt><a href="#response_expand"><b>response_expand</b></a>
	<dt><a href="#setblock"><b>setblock</b></a>
	<dt><a href="#setcbrk"><b>setcbrk</b></a>
	<dt><a href="#setdisk"><b>setdisk</b></a>
	<dt><a href="#setdta"><b>setdta</b></a>
	<dt><a href="#setverify"><b>setverify</b></a>
</dl></dl>

<!-- =========================================== -->

<hr> <h2><a name="_bdos">_bdos</a></h2><dl> 

<dt><b>Header</b></dt> <dd>	dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>	int _bdos(int dosfunc, unsigned DX, unsigned AL); 
</tt></dd>


<dt><b>Description</b></dt> <dd>	_bdos invokes a DOS system call via interrupt 0x21,
	where <i>dosfunc</i> is the desired DOS system call.
	<i>DX</i> and <i>AL</i>
	are values to be loaded into the DX and AL registers prior to
	calling the specified DOS function.  For DOS 0x21 functions that require
	loading registers other than DX and AL prior to call, use either
	<a href="#_intdos">_intdos</a>
	or <a href="#_intdosx">_intdosx</a>.
	<p>

	Under the X and P memory models _bdos and bdosx carry out some filtering of
	parameters sent to the real mode interrupt. This enables MS-DOS functions
	running in real mode to access data stored in extended memory. Some DOS
	functions are partially or unsupported in the 32-bit memory models. See
	the <a href="bios.html#_int86">_int86</a> function.
	<p>

	Do not use _bdos() to invoke system calls that indicate errors
	by setting the carry flag.
	C programs do not have access to this flag and cannot
	determine whether the return value is an error code.
</dd>


<dt><b>Synonym</b></dt> <dd>	Function: bdos
</dd>


<dt><b>Return Value</b></dt> <dd>	The value in the AX register, as set by the system call.
</dd>


<dt><b>Compatibility</b></dt> <dd>	DOS, Windows 3.x, Phar Lap, DOSX 
</dd>

<dt><b>See Also</b></dt> <dd>	<a href="#bdosptr">bdosptr</a><br>
	<a href="#bdosx">bdosx</a><br>
	<a href="#_intdos">_intdos</a><br>
	<a href="#_intdosx">_intdosx</a><br>
	<a href="bios.html#_int86">_int86</a><br>
	<a href="bios.html#_int86x">_int86x</a><br>
	<a href="bios.html#_int86">int86_real</a><br>
	<a href="bios.html#_int86x">int86x_real</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _bdos 	*/

#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define I21HDISPCHAR   0x02 
#define I21HSETVERIFY  0x2e 
#define I21HGETDOSVERS 0x30

/* This Example assumes sizeof(int) == 2 */

int lowbytes(int tomask) 
{   
   return (tomask &amp; 0x00FF); 
}

int highbytes(int toshift) 
{
   return (toshift &gt;&gt; 8); 
}

void main() 
{
   int result;
   unsigned DX, AL;

   /* get DOS version number */ 

   result = <b>_bdos</b>(I21HGETDOSVERS, DX, AL);
   printf("Running DOS %d.%d\n", lowbytes(result), highbytes(result));

   /* Print a character on the screen */

   DX = 'Z';
   <b>_bdos</b>(I21HDISPCHAR, DX, AL);

   /* Turn DOS verify off */

   DX = 0x00; AL = 0x00; 
   <b>_bdos</b>(I21HSETVERIFY, DX, AL);
   printf("\nDOS Verify disabled\n"); 

}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Running DOS 6.20
Z
DOS Verify disabled
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_chain_intr">_chain_intr</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>


<dt><b>Prototype</b></dt> <dd><tt>void <b>_chain_intr</b>(void(__cdecl __interrupt __far *<i>target</i>)()); 
</tt></dd>


<dt><b>Description</b></dt> <dd><b>_chain_intr</b> transfers control from one interrupt handler to
another, specified by <i>target</i>, allowing the target handler to return as if
it were called directly.
<p>

Use <b>_chain_intr</b> only with functions that have been declared with
<b>__interrupt</b>, ensuring the procedure's entry and exit sequence is
appropriate for an interrupt handler.
</dd>

<dt><b>Return Value</b></dt> <dd>Does not return to the caller.
</dd>


<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX
</dd>


<dt><b>See Also</b></dt> <dd><a href="#_dos_getvect">_dos_getvect</a><br>
<a href="#_dos_setvect">_dos_setvect</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _chain_intr 
	Also demonstrates _dos_getvect, 
	_dos_setvect, _spawn 

      PROFILE. C

Shows how much time is being spent in each code 
segment running on the machine. Produces a more 
interesting result when not run in a Windows DOS 
box. 
*/ 

#include &lt;dos.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;process.h&gt; 
#include &lt;stdlib.h&gt; 

#define MAX_SEGS 128 

static struct seg_profile { 
   unsigned code_segment; 
   unsigned number_of_hits; 
} prof_table[MAX_SEGS]; 

static void (__interrupt __far *old_handler)(); 

static void __interrupt __far timer_handler (

   unsigned saved_es, unsigned saved_ds, 
   unsigned saved_di, unsigned saved_si, 
   unsigned saved_bp, unsigned saved_sp, 
   unsigned saved_bx, unsigned saved_dx, 
   unsigned saved_cx, unsigned saved_ax, 
   unsigned saved_ip, unsigned saved_cs, 
   unsigned saved_flags) 
{   
   struct seg_profile *p; 

   for (p = prof_table; p &lt; prof_table + 
	MAX_SEGS; p += 1) 

   {   
      if (p-&gt;code_segment == saved_cs) 
      {   
	p-&gt;number_of_hits += 1; 
	break; 
      } 
      if (p-&gt;code_segment == 0) 
      {   
	 p-&gt;code_segment = saved_cs; 
	 p-&gt;number_of_hits += 1; 
	 break; 
      } 
   } 
   _chain_intr (old_handler); 
} 
static void print_profile() 
{   
   struct seg_profile *p; 

   printf("Code Segment Number of hits\n"); 
   for (p = prof_table; p &lt; prof_table + 
       MAX_SEGS; p += 1) 
   {   
      if (p-&gt;code_segment == 0) 
	 break; 
      printf("%12x %14d\n", p-&gt;code_segment, 
	      p-&gt;number_of_hits); 
   } 
} 
void main (int argc, char const *const argv[]) 
{   
   if (argc &lt; 2) 
   {   
      fprintf(stderr, "Usage: PROFILE executable-file arguments...\n"); 
      exit (EXIT_FAILURE); 
   } 
   old_handler = _dos_getvect (0x8); 
   _dos_setvect (0x8, (void (__interrupt __far 
      *) (void)) timer_handler);
   _spawnvp (_P_WAIT, argv[1], argv + 1); 
   _dos_setvect (0x8, old_handler); 
   print_profile(); 
}
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">C:\SC\EXAMPLES&gt; profile edit profile.c
</pre>
<dl>
<dt>Code Segment 
<dd>Number of hits 
<dt>ff6d 
<dd>1 
<dt>6f6e 
<dd>1 
<dt>c000 
<dd>4 
<dt>d28f 
<dd>5 
<dt>638f 
<dd>721 
<dt>e003 
<dd>2
</dl>
</dd>
 </dl>


<!-- =========================================== -->

<hr> <h2><a name="_disable">_disable</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _disable(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>_disable disables interrupts by executing an 8086 CLI machine instruction. You should disable interrupts before modifying an interrupt vector.
</dd>

<dt><b>Synonym</b></dt> <dd>Function: disable
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_enable">_enable</a>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_enable">_enable</a></h2><dl> 


<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _enable(void); 
</tt></dd>

<dt><b>Description</b></dt> <dd>Enables hardware interrupts by executing an 8086 STI machine 
instruction. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: enable 
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_disable">_disable</a>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_FP">_FP</a></h2><dl> 


<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned _FP_OFF(void __far *fpointer);<br>
unsigned _FP_SEG(void __far *fpointer); 
</tt></dd>

<dt><b>Description</b></dt> <dd>_FP_OFF and _FP_SEG split far pointers into their offset and 
segment parts. These functions are implemented as macros. 
</dd>

<dt><b>Return Value</b></dt> <dd>_FP_SEG returns the 16-bit offset value of the far pointer. 
_FP_OFF returns the 16-bit segment value of the far pointer. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>Synonym</b></dt> <dd>Functions:  FP_OFF and FP_SEG
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_MK_FP">_MK_FP</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _FP_OFF 
	Also demonstrates _FP_SEG 
*/ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;dos.h&gt;

char __far * farstr = "This is a test."; 

void main() 
{   
   unsigned seg, off; 
   seg = _FP_SEG (farstr); 
   off = _FP_OFF (farstr); 

   printf("Far string at segment %04X, and 
	     offset %04X\n", seg, off); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Far string at segment 2305, and offset 0060 
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_getdcwd">_getdcwd</a></h2><dl> 

<dt><b>Header</b></dt> <dd>direct.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>char *_getdcwd(int drive, char *buffer, int length); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _getdcwd function gets the name of the current working 
directory on the specified drive and stores the drive and path name 
in buffer. Argument length is the maximum length of the path 
name (including the terminating null character.) If the current 
directory is the root, the returned string will end with a backslash. 
Otherwise, the string ends with the directory name, not a backslash.<p> 

To specify a drive, 0 indicates the default drive, 1 indicates drive A, 2 indicates drive B, and so on. If buffer is specified as NULL, 
_getdcwd will malloc enough bytes to hold the path (including 
the terminating 0). At least length bytes will be allocated. To 
deallocate the buffer, use the free function. 
</dd>

<dt><b>Return Value</b></dt> <dd>If successful, _getdcwd returns a pointer to buffer. A return value 
of NULL indicates an error and errno is set to ENOMEM (insufficient 
memory to allocate length bytes) or ERANGE (path name longer 
than length characters). 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_getcwd">_getcwd</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _getdcwd */ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;direct.h&gt;

void main() 
{   
   char path[_MAX_DIR]; 

   _getdcwd (3, path, _MAX_DIR); 
   printf("Current directory on drive C: is: %s", path); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Current directory on drive C: is: C:\SC\EXAMPLES 
</pre>
</dd>
 </dl>




<!-- =========================================== -->

<hr> <h2><a name="_hard">_hard</a></h2><dl> 


<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void _harderr(void(__far *handler)(unsigned, unsigned, unsigned));<br>
void _hardresume(int result);<br>
void _hardretn(int error); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _harderr, _hardresume, and _hardretn functions handle critical 
error conditions occuring from hardware devices that cause a DOS 
interrupt 0x24.<p>

The function specified as the handler in the _harderr call will be called when a
critical interrupt occurs. The function might call either of the following
functions:<p>

<ul><li>_hardresume, which returns to DOS with a result of abort, 
retry, ignore, or fail.</li>

<li>_hardretn, which skips DOS and returns directly to the 
routine that originally made the DOS call.</li>
</ul>

The _harderr function calls the user-defined routine, referenced by 
handler, using the following parameters:<p>

handler(unsigned deverror, unsigned errcode, unsigned __far *devhdr); <p>
Argument deverror, the device error code, contains the value of 
register variable AX that DOS passes to the interrupt 0x24 handler. If 
bit 15 is zero, indicating a disk device error, the bits have the 
following meaning:<p>
<dl>
<dt><b>Bits/Value = Meaning</b>
<dt>15 
<dd>0 = disk device error 
<dt>13 
<dd>0 = "ignore" response is not allowed 
<dt>12 
<dd>0 = "retry" iesponse is not allowed 
<dt>11 
<dd>0 = "fail" response is not allowed. "fail" will be changed 
to "abort" 
<dt>9 and 10 
<dd>00 = error occured in DOS 
<dd>01 = error occured in file allocation table 
<dd>10 = error occured in a directory 
<dd>11 = error occured in a data area 
<dt>8 
<dd>0 = read error 
<dd>1 = write error 
<dt>Low-order byte 
<dd>0 = drive A 
<dd>1 = drive B 
<dd>2 = drive C 
<dd>etc. 
</dl><p>
For errors on devices other than disk drives, bit 15 of the deverror 
argument is set to 1. The type of device that had the error is 
indicated by the attribute word, located at offset 4 in the device 
header block (which is pointed to by devhdr):<p>
<dl>
<dt><b>Bit in attribute word/Meaning</b>
<dt>15 
<dd>0 = error in memory image of file 
allocation table 
<dd>1 = error in character device. Bits 0 -3 
specify which device. 
<dt>3 
<dd>Current clock device 
<dt>2 
<dd>current null device 
<dt>1 
<dd>Current standard output 
<dt>0 
<dd>Current standard input 
</dl>

Argument errcode contains the value of register variable DI that 
DOS passes to the handler. The error code's low-order byte can be:<p>
<dl>
<dt><b>Code/Meaning</b>
<dt>0 
<dd>Attempt to write to write-protected disk 
<dt>1 
<dd>Unknown unit 
<dt>2 
<dd>Drive not ready 
<dt>3 
<dd>Unknown command 
<dt>4 
<dd>Cyclic-redundancy-check error in data 
<dt>5 
<dd>Bad drive-request structure length 
<dt>6 
<dd>Seek error 
<dt>7 
<dd>Unknown media type 
<dt>8 
<dd>Sector not found 
<dt>9 
<dd>Printer out of paper 
<dt>10
<dd>Write fault 
<dt>11 
<dd>Read fault 
<dt>12 
<dd>General failure 
</dl><br>
Argument devhdr is a far pointer to a device header. It describes 
the device that has the error. The user-defined handler must not 
change this information.<p>

Function _hardresume must be called with one of these results:<p>
<dl>
<dt><b>Constant/Action</b>
<dt>_HARDERR_ABORT 
<dd>Aborts the program 
<dt>_HARDERR_FAIL 
<dd>Fails the system call in progress 
<dt>_HARDERR_IGNORE 
<dd>Ignores the error 
<dt>_HARDERR_RETRY 
<dd>Retries the operation 
</dl><br>

The _hardretn function returns directly to the application program 
just after the failing I/ O function request according to these criteria:<p>
<dl>
<dt><b>If failing interrupt 0x21 is:/Then...</b> 
<dt>Greater than or equal to 0x38 
<dd>the _hardretn function returns 
to the application with the carry 
flag set and the AX register set to 
the error parameter.<p>

<dt>Less than 0x38 and the function 
can return an error 
<dd>the AL register is set to 0xFF on 
return to the application.<p>

<dt>Less than 0x38 but cannot return 
an error 
<dd>the error parameter is not used 
and no error code is returned to 
the application. 
</dl>
</dd>

<dt><b>Return Value</b></dt> <dd>None
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example for _harderr 
	Also demonstrates _dos_creat 
*/ 

#include &lt;dos.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;

static unsigned the_deverror, the_errcode, __far 
*the_devhdr; 

static void __far my_handler (unsigned deverror, 
			    unsigned errcode, 
			    unsigned  __far *devhdr) 
{   
   the_deverror = deverror; 
   the_errcode = errcode; 
   the_devhdr = devhdr; 
   _hardresume (_HARDERR_FAIL); 
} 

void main() 
{   

   int handle; 

   printf("Please be sure no disk is in 
	     the A drive.\n" 
	   "Press a key to continue: \n"); 
   getch(); 
   _harderr (my_handler); 
   the_deverror = -1; 
   the_errcode = -1; 
   the_devhdr = NULL; 
   if (_dos_creat (" a: anything", _A_NORMAL, 
	&handle) != 0) 
      printf("create failed, error code was 
		%d\n", the_errcode); 
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">Please be sure no disk is in the A drive.
Press a key to continue:
create failed, error code was 2
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_inp">_inp</a></h2><dl> 

<dt><b>Header</b></dt> <dd>	dos.h
</dd>


<dt><b>Prototype</b></dt> <dd><tt>	int _inp(unsigned port_address);<br>
	int _inpw(unsigned port_address);<br>
	int _inpl(unsigned port_address);
</tt></dd>


<dt><b>Description</b></dt> <dd>	This is a C interface to the hardware ports using the IN 80x86 I/O 
	instructions. <tt>_inp</tt> reads a byte from the specified port,
	and <tt>_inpw</tt> 
	reads a word from the specified port. The compiler generates inline 
	code for them. The real library functions can be called with #undef 
	inpw and #undef inp in the source file after including <dos.h>. 
</dd>


<dt><b>Synonym</b></dt> <dd>	Functions:  inp, inpw
</dd>


<dt><b>Return Value</b></dt> <dd>	The value read from the port is returned. 
</dd>


<dt><b>Compatibility</b></dt> <dd>	DOS, Windows 3.x, Phar Lap, DOSX, Win32 
</dd>


<dt><b>See Also</b></dt> <dd>	<a href="#_outp">_outp</a>
</dd>


<dt><b>Example</b></dt> <dd>The following two examples turn off and turn on the MDA cursor 

<pre class="ccode">/* 	Example for _inp 
	Turns off the MDA cursor. */ 

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &lt;stdlib.h&gt; 

void main() 
{   
   char result; 
   result = _inpw (0x3b4); 
   printf("The value from port 3B4h is %xh\n", 
	     result); 
   _outp (0x3b4, 10); 
   _outp (0x3b5, 32); 
} 

/* 	Turns on the MDA cursor 
*/ 
#include &lt;dos.h&gt; 
#include &lt;stdlib.h&gt;

void main() 
{   
   _outp (0x3b4, 10); 
   _outp (0x3b5, 11); 
} 
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_intdos">_intdos</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _intdos(union _REGS *regsin, union _REGS *regsout); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _intdos and intdos functions perform a MS-DOS system call 
(int 0x21). Consult an MS-DOS manual for specific function and 
calling conventions. regsin is a pointer to a structure containing 
the values of the registers AX, BX, CX, DX, SI and DI to be passed to 
the interrupt. regsout is a pointer to a structure into which the 
return values of the registers will be written. The state of the carry 
flag can be determined from x. cflag in regsout. The union 
_REGS is defined in dos.h.<p>

Under the 32-bit memory models intdos and indosx carry out 
some filtering of parameters sent to the real mode interrupt. This 
enables MS-DOS functions running in real mode to access data 
stored in extended memory. Some of the available DOS functions 
are not supported or only partially supported in the 32-bit memory 
models. Refer to the entry for int86 for more information. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  intdos
</dd>

<dt><b>Return Value</b></dt> <dd>The value that was in AX at the end of the interrupt. For _intdos, if 
an error occurs, the cflag field in regsout is non-zero and 
_doserrno is set to the corresponding error code. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_int86">_int86</a><br>
<a href="#int86_real">int86_real</a><br>
<a href="#_int86x">_int86x</a><br>
<a href="#int86x_real">int86x_real</a><br>
<a href="#_intdosx">_intdosx</a>
</dd>

<dt><b>Example</b></dt> <dd>See intdosx 
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_intdosx">_intdosx</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>int _intdosx(union _REGS *regsin, union _REGS *regsout, struct _SREGS *segregs); 
</tt></dd>

<dt><b>Description</b></dt> <dd>The _intdosx function performs an MS-DOS system call (int 0x21). 
Consult a DOS manual for specific function and calling conventions. 
regsin is a pointer to a structure containing values of the registers 
AX, BX, CX, DX, SI and DI to be passed to the interrupt. regsout is 
a pointer to a structure into which return values of the registers will 
be written. The state of the carry flag can be determined from 
x. cflag in regsout. The segregs structure contains segment 
register values passed to the interrupt for intdosx. It also returns their 
values after the interrupt is processed. Union _REGS and structure 
_SREGS are defined in dos.h. See int86 for an explanation of 
function filtering under the 32-bit memory models. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function:  intdosx
</dd>

<dt><b>Return Value</b></dt> <dd>The value that was in AX at the end of the interrupt. If an error 
occurs, the cflag field in regsout is non-zero and _doserrno is 
set to the corresponding error code. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_int86">_int86</a>
<a href="#int86_real">int86_real</a>
<a href="#_int86x">_int86x</a>
<a href="#int86x_real">int86_real</a>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_MK_FP">_MK_FP</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>void __far *_MK_FP(unsigned seg, unsigned off); 
</tt></dd>

<dt><b>Description</b></dt> <dd>Converts the unsigned segment and offset values to a far pointer. 
</dd>

<dt><b>Synonym</b></dt> <dd>Function: MK_FP 
</dd>

<dt><b>Return Value</b></dt> <dd>Returns a far pointer. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_FP Functions">_FP Functions</a>
</dd>

<dt><b>Example</b></dt> <dd><pre class="ccode">/* 	Example of _MK_FP */ 

#include &lt;dos.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main()
{   
   char far *p;
   unsigned int segment = 0xb800, offset = 0; 

   p = _MK_FP (segment, offset);
   printf("The CGA video buffer is at %lp\n", p);
} 
</pre>
</dd>

<dt><b>Output</b></dt> <dd><pre class="console">The CGA video buffer is at B800:0000 
</pre>
</dd>
 </dl>



<!-- =========================================== -->

<hr> <h2><a name="_osversion">_osversion</a></h2><dl> 


<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>extern unsigned int _osversion; 
</tt></dd>

<dt><b>Description</b></dt> <dd>This variable holds both the major and minor version numbers of 
the operating system. The low byte holds the major version number; 
the high byte holds the minor version number. This is the reverse of 
_osver. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS Windows 3.x Phar Lap DOSX Win32 
</dd>
 </dl>




<!-- =========================================== -->

<hr> <h2><a name="_outp">_outp</a></h2><dl> 

<dt><b>Header</b></dt> <dd>dos.h
</dd>

<dt><b>Prototype</b></dt> <dd><tt>unsigned char _outp(unsigned port_address, unsigned char value);<br>
unsigned short _outpw(unsigned port_address, unsigned short value);<br>
unsigned long _outpl(unsigned port_address, unsigned long value);
</tt></dd>

<dt><b>Description</b></dt> <dd>These functions write to the hardware 
I/O ports using the OUT 80x86 instruction.
</dd>

<dt><b>Synonym</b></dt> <dd>Functions: outp, outpw 
</dd>

<dt><b>Return Value</b></dt> <dd>The value that is sent to the I/O port. 
</dd>

<dt><b>Compatibility</b></dt> <dd>DOS, Windows 3.x, Phar Lap, DOSX 
</dd>

<dt><b>See Also</b></dt> <dd><a href="#_inp">_inp</a>
</dd>

<dt><b>Example</b></dt> <dd>See <a href="#_inp">_inp</a>.
</dd>
 </dl>



<!-- =========================================== -->

$(RTLENTRY1 _segread,

&lt;&lt;&gt;&gt;
$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void _segread(struct _SREGS *segregs); 
<p>

<b>
$(DESCRIPTION
</b><p>
The _segread function reads the contents of the segment register 
and puts them in _SREGS. In the 32-bit memory models, this 
function returns protected mode segment selectors, not real mode 
segment values. The elements in structure _SREGS are:<br>
<dl>
<b>Element/Meaning</b>
<dt>unsigned short cs; 	
<dd>Code segment 
<dt>unsigned short ds; 	
<dd>Data segment 
<dt>unsigned short es; 	
<dd>Extra segment 
<dt>unsigned short ss; 	
<dd>Stack segment 
<dt>unsigned short fs; 	
<dd>32-bit platform only 
<dt>unsigned short gs; 	
<dd>32-bit platform only 
</dl>
<p>

<b>
$(SYNONYM
</b><p>
Function:  segread<br>
Structure: SREGS 
<p>

<b>
$(RETURNS
</b><p>
None
<p>
<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#_intdosx">_intdosx</a><br>
<a href="#_int86x">_int86x</a><br>
<a href="#int86x_real">int86x_real</a><br>
<a href="#getDS">getDS</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example of _segread */ 

#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{   
   struct _SREGS sregs;
   unsigned cs, ss, ds, es; 

   _segread (&amp; sregs);
   cs = sregs.cs; 
   ss = sregs.ss;
   ds = sregs.ds; 
   es = sregs.es;
   printf("Segment registers currently 
	     contain:\n");
   printf("CS: %04x\nSS: %04x\nDS: %04x\nES: 
	     %04x\n", cs, ss, ds, es); } 
</pre>

<b>
$(OUTPUT
</b><p>
Segment registers currently contain:<br>
CS: 1f04<br>
SS: 2055<br>
DS: 2055<br> 
ES: 1eda 




<!-- =========================================== -->

$(RTLENTRY1 allocmem,


$(HEADER
</b><p>
dos.h 
<p>

<b>
$(PROTOTYPE
</b><p>
int allocmem(unsigned size, unsigned *segp); 
<p>

<b>
$(DESCRIPTION
</b><p>
Allocates a DOS memory segment, using the DOS system call 0x48. 
The allocated memory block has the number of paragraphs specified 
in the size argument. (There are 16 bytes in a paragraph.) The 
segp argument points to the word that contains the segment 
address of the allocated memory block.<p>

Do not use allocmem and malloc functions in the same program. 
<p>

<b>
$(RETURNS
</b><p>
Returns -1 if the memory is successfully allocated. If unsuccessful, 
the number of paragraphs available in the largest memory block is 
returned. In addition, the global variable _doserrno is set and the 
global variable errno is set to ENOMEM, for not enough memory. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#_dos_allocmem">_dos_allocmem</a><br>
<a href="#freemem">freemem</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for allocmem Also demonstrates _MK_FP 
*/ 
#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() 
{   
   int largest; 
   unsigned segment, size; 
   char __far *pointer;

   size = 0xffff; 
   largest = allocmem (size, &segment); 
   if (largest != -1) 
   {   
      printf("The largest available block is %u 
		bytes\n", largest); 
      size = largest / 2; 
      largest = allocmem (size, &segment); 
      if (largest != -1) 
      {   
	 fprintf(stderr, "Error allocating %u 
		  bytes\n", size); 
	 exit (EXIT_FAILURE); 
      } 
   } 
   pointer = _MK_FP (segment, 0); 
   printf("The beginning of the %u bytes is at 
	   %Fp\n", size, pointer); 
} 
</pre>

<b>
$(OUTPUT
</b><p>
The largest available block is 28675 bytes 
The beginning of the 14337 bytes is at 34FD: 0000 



<!-- =========================================== -->

$(RTLENTRY1 bdosptr,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int bdosptr(int dosfun, void *argument, unsigned dosal); 
<p>

<b>
$(DESCRIPTION
</b><p>
The bdosptr function invokes the DOS system call specified in the dosfun argument. In small data models, argument specifies the DX register; in large data models, argument specifies the DS: DX values to be used by the system call. The dosal argument specifies the value of the AL register.<p>

For system calls that require a pointer argument, use the bdosptr function. Otherwise, use bdos.
<p>

<b>
$(RETURNS
</b><p>
The value of the AX register, as set by the system call. If unsuccessful, -1 is returned and the global variables errno and _doserrno are set appropriately.
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#_bdos">_bdos</a><br>
<a href="#bdosx">bdosx</a><br>
<a href="#_intdos">_intdos</a><br>
<a href="#_intdosx">_intdosx</a><br>
<a href="#_int86">_int86</a><br>
<a href="#int86_real">int86_real</a>
<p>

<b>
$(EXAMPLE
</b><p>
See _bdos

<!-- =========================================== -->

$(RTLENTRY1 bdosx,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int bdosx(char int21func, void* DS_DX, char AL); 
<p>

<b>
$(DESCRIPTION
</b><p>
bdosx is used to invoke DOS system calls that require a pointer argument. The bdosx function calls the specified DOS function int21func, placing the pointer argument DS_DX in the DS: DX register pair, and the argument AL in register AL. The DS_DX argument is a standard near or far pointer, depending on memory model, and must match the default pointer type for that model. For system calls that require only an integer value in DX, use the function bdos.<p> 

Under the 32-bit memory models bdos and bdosx carry out some filtering of parameters sent to the real mode interrupt. This filtering allows data stored in extended memory to be passed to the DOS function so that, for instance, much larger buffers than normal can be used with the DOS disk functions. Where pointers are passed to bdosx, they are assumed to contain protected mode addresses. The filtering routine used for these functions assumes that all far pointers passed in registers to DOS have a segment address of DGROUP. If you use bdosx and specify a selector other that DGROUP the results will be unpredictable.<p>

Some of the available DOS functions are not supported or only partially supported in the 32-bit memory models. Refer to the entry for int86 for more information.
<p>

<b>
$(RETURNS
</b><p>
The value in AX after the system call.
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#_bdos">_bdos</a><br>
<a href="#bdosptr">bdosptr</a><br>
<a href="#_intdos">_intdos</a><br>
<a href="#_intdosx">_intdosx</a><br>
<a href="#_int86">_int86</a><br>
<a href="#int86_real">int86_real</a><br>
<a href="# _int86x"> _int86x</a><br>
<a href="#int86x_real">int86x_real</a><br>
<a href="#other dos_functions">other dos_functions</a>
<p>

<b>
$(EXAMPLE
</b><p>
See _bdos

<!-- =========================================== -->

$(RTLENTRY1 farcalloc,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void __far *farcalloc(unsigned long numelems, unsigned long size); 
<p>

<b>
$(DESCRIPTION
</b><p>
farcalloc allocates memory from the far heap for an array 
containing numelems elements, each size bytes long. This 
function is very similar to calloc because it initializes a new 
memory block to NULL. In the small and medium memory models, 
calloc allocates memory within the near heap whereas 
farcalloc allocates memory in the far heap. In the large memory 
model, both functions allocate memory from the far heap. This 
function is not implemented for the 32-bit memory models. 
<p>

<b>
$(RETURNS
</b><p>
farcalloc returns a far pointer to the allocated memory block, or 
NULL if not enough space exists. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#calloc Functions">calloc Functions</a><br>
<a href="#farcoreleft">farcoreleft</a><br>
<a href="#farfree">farfree</a><br>
<a href="#farmalloc">farmalloc</a><br>
<a href="#farcalloc">farcalloc</a><br>
<a href="#free Functions">free Functions</a><br>
<a href="#malloc Functions">malloc Functions</a><br>
<a href="#realloc Functions">realloc Functions</a><br>
<a href="#_FP Functions">_FP Functions</a><br>
<p>

<!-- =========================================== -->

$(RTLENTRY1 farcoreleft,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
unsigned long farcoreleft(void); 
<p>

<b>
$(DESCRIPTION
</b><p>
farcoreleft returns the size of largest contiguous block of 
unused memory in the operating system's heap. This function is not 
implemented for the 32-bit memory models. 
<p>

<b>
$(RETURNS
</b><p>
Returns the size of the largest contiguous block of memory in the far 
heap which has not been used, between the highest allocated block 
and the end of memory. This is the amount of memory still available 
for allocation by farmalloc or farcalloc. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#calloc Functions">calloc Functions</a><br>
<a href="#farfree">farfree</a><br>
<a href="#farmalloc">farmalloc</a><br>
<a href="#farcalloc">farcalloc</a><br>
<a href="#farrealloc">farrealloc</a><br>
<a href="#free Functions">free Functions</a><br>
<a href="#malloc Functions">malloc Functions</a><br>
<a href="#realloc Functions">realloc Functions</a><br>
<a href="#_FP Functions">_FP Functions</a>
<p>

<!-- =========================================== -->

$(RTLENTRY1 farfree,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int farfree(void __far *memblock); 
<p>

<b>
$(DESCRIPTION
</b><p>
farfree releases a block of previously allocated far memory 
pointed to by the far pointer memblock. The memblock argument 
must point to a memory block previously allocated by farcalloc, 
farmalloc, or farrealloc. This function is not implemented for 
the 32-bit memory models. 
<p>

<b>
$(RETURNS
</b><p>
An integer
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#calloc Functions">calloc Functions</a><br>
<a href="#farcoreleft">farcoreleft</a><br>
<a href="#farfree">farfree</a><br>
<a href="#farmalloc">farmalloc</a><br>
<a href="#farcalloc">farcalloc</a><br>
<a href="#farrealloc">farrealloc</a><br>
<a href="#free Functions">free Functions</a><br>
<a href="#malloc Functions">malloc Functions</a><br>
<a href="#realloc Functions">realloc Functions</a><br>
<a href="#_FP Functions">_FP Functions</a>
<p>

<!-- =========================================== -->

$(RTLENTRY1 farmalloc,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void __far *farmalloc(unsigned long sizebytes); 
<p>

<b>
$(DESCRIPTION
</b><p>
farmalloc allocates a memory block sizebytes long from the 
far heap. This function is not implemented for the 32-bit memory 
models. 
<p>

<b>
$(RETURNS
</b><p>
farmalloc returns a far pointer to the allocated memory block, or 
NULL if not enough space exists. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#calloc Functions">calloc Functions</a><br>
<a href="#farcoreleft">farcoreleft</a><br>
<a href="#farfree">farfree</a><br>
<a href="#farmalloc">farmalloc</a><br>
<a href="#farcalloc">farcalloc</a><br>
<a href="#farrealloc">farrealloc</a><br>
<a href="#free Functions">free Functions</a><br>
<a href="#malloc Functions">malloc Functions</a><br>
<a href="#realloc Functions">realloc Functions</a><br>
<a href="#_FP Functions">_FP Functions</a>
<p>


<!-- =========================================== -->

$(RTLENTRY1 farrealloc,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void __far *farrealloc(void __far *memblock, unsigned long newsize); 
<p>

<b>
$(DESCRIPTION
</b><p>
farrealloc adjusts the size of a previously allocated memblock 
to newsize. This function is not implemented for the 32-bit 
memory models. 
<p>

<b>
$(RETURNS
</b><p>
farrealloc returns the address of the reallocated memory block. 
This may be different from the original memory block. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#calloc Functions">calloc Functions</a><br>
<a href="#farcoreleft">farcoreleft</a><br>
<a href="#farfree">farfree</a><br>
<a href="#farmalloc">farmalloc</a><br>
<a href="#farcalloc">farcalloc</a><br>
<a href="#free Functions">free Functions</a><br>
<a href="#malloc Functions">malloc Functions</a><br>
<a href="#realloc Functions">realloc Functions</a><br>
<a href="#_FP Functions">_FP Functions</a>
<p>

<!-- =========================================== -->

$(RTLENTRY1 findfirst,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
struct FIND *findfirst(const char *pathname, int attribute); 
<p>

<b>
$(DESCRIPTION
</b><p>
The findfirst function finds the first file matching a file 
description possibly containing wild cards (i. e. '* ' or '? '). The wild 
cards can be in the file name or extension, but not the path. The 
attribute argument is the file attribute of the file to be found. 
More than one attribute bit can be passed in the findfirst call. 
The attribute values, defined in dos.h, are: <p>
<dl>
<dt>_A_RDONLY
<dd>Read only 
<dt>_A_HIDDEN
<dd>Hidden file 
<dt>_A_SYSTEM
<dd>System file 
<dt>_A_VOLID
<dd>Label 
<dt>_A_SUBDIR
<dd>Directory 
<dt>_A_ARCH
<dd>Archive 
</dl>
<p>
A value of 0 for the attribute finds all normal files. If a program 
specifies any combination of _A_HIDDEN, _A_SYSTEM, _A_SUBDIR, 
the function returns normal files in addition to the specified files. 
The program must examine the attribute to determine the type of file 
found. 

<p>

<b>
$(RETURNS
</b><p>
A pointer to a static structure FIND as defined in dos.h. A NULL 
pointer indicates the end of filename matches or an error (such as no 
matching files). The FIND structure has exactly the same fields as the 
find_t structure used by _dos_findfirst. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#findnext">findnext</a>
<p>


<!-- =========================================== -->

$(RTLENTRY1 findnext,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
struct FIND *findnext(void); 
<p>

<b>
$(DESCRIPTION
</b><p>
The findnext function is used to find the next match of the file 
specified in the preceding findfirst call. findnext can be 
called only after a findfirst call. 
<p>

<b>
$(RETURNS
</b><p>
A pointer to a static struct FIND as defined in dos.h is returned on 
success. Because this structure is static, you must copy the 
information to another buffer if you need the information after a call 
to findnext. A NULL pointer indicates the end of filename matches 
or an error. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#findfirst">findfirst</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for findnext
	Also demonstrates findfirst, printf 

	FILES. C
*/ 

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &lt;stdlib.h&gt;

void main (int argc, char *argv[])
{   
   struct FIND *entry;
   char *path; 
   struct time_format
   {   
	unsigned two_seconds: 5;
	unsigned minutes: 6; 
	unsigned hours: 5;
   } time; 
   struct date_format
   {   
	unsigned day: 5;
	unsigned month: 4; 
	unsigned year: 7;
   } date; 
   if (argc &lt; 2)
	path = "*.*"; 
   else
	path = argv[1]; 
   entry = findfirst (path,
	_A_RDONLY | _A_HIDDEN | _A_SYSTEM | 
	_A_VOLID | _A_SUBDIR | _A_ARCH);
   while (entry != NULL) 
   {
	time = *(struct time_format *)&amp; entry-&gt;time; 
	date = *(struct date_format *)&amp; entry-&gt;date;
	printf("%-13s %10lu %02d-%02d-%02d %02d: 
	   %02d.%02d %c%c%c%c%c%c\n",
	   entry-&gt;name, entry-&gt;size, 
	   date.month, date.day, date.year + 80,
	   time.hours, time.minutes, 
	   time.two_seconds &lt;&lt; 1, entry-&gt;attribute &amp; _A_RDONLY? 'r': ' ', 
	   entry-&gt;attribute &amp; _A_HIDDEN? 'h': ' ',
	   entry-&gt;attribute &amp; _A_SYSTEM? 's': ' ', 
	   entry-&gt;attribute &amp; _A_VOLID? 'v': ' ',
	   entry-&gt;attribute &amp; _A_SUBDIR? 'd': ' ', 
	   entry-&gt;attribute &amp; _A_ARCH? 'a': ' ');
	entry = findnext(); 
   }
} 
</pre>

<b>
$(OUTPUT
</b>
<pre class="console">C:\SC\EXAMPLES&gt;files \*.*
IO.SYS   	 40566 09-30-93 06:20.00 rhs 
MSDOS.SYS 	 38138 09-30-93 06:20.00 rhs
MS-DOS_6 	     0 03-03-94 11:54.14    v a 
DOS 		     0 03-03-94 11:54.14     d 
WINDOWS              0 03-03-94 12:05.32     d 
NET                  0 03-15-94 11:49.04     d
SC 		     0 06-21-94 10:07.34     d 
DIGIMARS             0 03-22-94 17:01.32     d
NDW                  0 03-22-94 17:14.18     d  
DOC                  0 04-04-94 10:49.00     d
COMMAND.COM	 54619 09-30-93 06:20.00 r 
DBLSPACE.BIN 	 64246 09-30-93 06:20.00 rhs
WINA20.386 	  9349 09-30-93 06:20.00      a 
AUTOEXEC.BAT       437 06-21-94 14:39.58      a 
386SPART.PAR  60809216 06-28-94 08:58.36  hs  a 
CONFIG.SYS         209 05-24-94 10:44.32      a 
</pre>


<!-- =========================================== -->

$(RTLENTRY1 freemem,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int freemem(unsigned segx);  
<p>

<b>
$(DESCRIPTION
</b><p>
The freemem function frees the DOS memory block associated with 
the segment address in the segx argument. This address was 
returned by a previous call to the allocmem function. 
<p>

<b>
$(RETURNS
</b><p>
If successful, a zero is returned. If unsuccessful, -1 is returned and 
errno is set to ENOMEM (insufficient memory). 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#allocmem">allocmem</a><br>
<a href="#free Functions">free Functions</a><br>
<a href="#_dos_allocmem">_dos_allocmem</a><br>
<a href="# _dos_freemem"> _dos_freemem</a>
<p>




<!-- =========================================== -->

$(RTLENTRY1 geninterrupt,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void geninterrupt(int intr_num); 
<p>

<b>
$(DESCRIPTION
</b><p>
The geninterrupt function generates the software interrupt 
specified in the intr_num argument. 
<p>

<b>
$(RETURNS
</b><p>
None
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#_disable">_disable</a><br>
<a href="#_enable">_enable</a>
<p>





<!-- =========================================== -->

$(RTLENTRY1 getcbrk,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int getcbrk(void); 
<p>

<b>
$(DESCRIPTION
</b><p>
The getcbrk function invokes the DOS system call 0x33, which 
gets the current setting for control-break checking. 
<p>

<b>
$(RETURNS
</b><p>
The value of the control-break setting (0 for off, 1 for on). 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#ctrlbrk">ctrlbrk</a><br>
<a href="#setcbrk">setcbrk</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for getcbrk */ 

#include &lt;stdio.h&gt; 
#include &lt;dos.h&gt;

void main() 
{   
   printf("Control-break is %s\n", getcbrk()? 
	     "on": "off"); 
} 
</pre>

<b>
$(OUTPUT
</b><p>
Control-break is on 



<!-- =========================================== -->

$(RTLENTRY1 getcurdir,


$(HEADER
</b><p>
direct.h
<p>

<b>
$(PROTOTYPE
</b><p>
int getcurdir(int drive, char *dir) 
<p>

<b>
$(DESCRIPTION
</b><p>
The getcurdir function gets the current working directory for the 
drive specified in the drive argument. To specify the drive 
argument, use an integer value, where 0 represents the current drive, 
1 represents drive A, 2 represents drive B, and so on. The dir 
argument points to a buffer where the name will be placed. The 
directory name is not stored with the drive specification and does 
not begin with a backslash. 
<p>

<b>
$(RETURNS
</b><p>
Returns 0 if successful, otherwise returns -1. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#_chdir">_chdir</a><br>
<a href="#_mkdir">_mkdir</a><br>
<a href="#_rmdir">_rmdir</a><br>
<a href="#_getcwd">_getcwd</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for getcurdir 

	CWD. C */ 

#include &lt;stdio.h&gt; 
#include &lt;direct.h&gt; 
#include &lt;stdlib.h&gt; 

void main (int argc, char *argv[]) 
{   

   char *path; 
   int drive; 

   if (argc &lt; 2) 
      drive = 0; 
   else 
   {   
      drive = toupper (* argv[1]) -'A' + 1; 
      if (drive &lt;= 0 || drive &gt; 26) 
      {   
	 fprintf(stderr," Usage: CWD [drive-
		  letter]\n"); 
	 exit (EXIT_FAILURE); 
      } 	
   } 
   if (getcurdir (drive, path) != 0) 
   {   
      fprintf(stderr, "Error accessing current 
	       directory\n"); 
      exit (EXIT_FAILURE); 
   } 
   printf("\\%s\n", path); 
} 
</pre>

<b>
$(OUTPUT
</b><p>
C:\SC\EXAMPLES&gt; cwd n<br>
\#\RELEASE\SRC 



<!-- =========================================== -->

$(RTLENTRY1 getdate,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void getdate(struct date *datep);  
<p>

<b>
$(DESCRIPTION
</b><p>
The getdate function obtains the current system date and places it 
in the structure pointed to by the datep argument. The date 
structure is:<br>

<pre class="ccode">struct date 
{   
int da_year; 	/* year */ 
char da_day; 	/* day of the month */ 
char da_mon; 	/* month, 1 for Jan */ 
}; 
</pre>
<p>

<b>
$(RETURNS
</b><p>
None
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#setdate">setdate</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for getdate */ 

#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;

void main() 
{   
   struct date the_date; 
   char *holiday; 

   getdate (&amp; the_date); 
   printf("The date is %d-%d-%d", 
	     the_date.da_mon, the_date.da_day, 
	     the_date.da_year); 
   holiday = NULL; 
   if (the_date.da_mon == 12 &amp;&amp; 
	     the_date.da_day == 25) 
      holiday = "Christmas day"; 
   else if (the_date.da_mon == 10 &amp;&amp; 
	    the_date.da_day == 31) 
      holiday = "Halloween"; 
   else if (the_date.da_mon == 7 &amp;&amp; 
	    the_date.da_day == 4) 
      holiday = "Independence Day"; 
   else if (the_date.da_mon == 6 &amp;&amp; 
	    the_date.da_day == 28) 
      holiday = "The anniversary of the writing 
		 of this program"; 
   if (holiday != NULL) 
      printf(": %s", holiday); 
   printf("\n"); 
} 
</pre>

<b>
$(OUTPUT
</b><p>
The date is 6-28-1994: The anniversary of the<br>
writing of this program 



<!-- =========================================== -->

$(RTLENTRY1 getdisk,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int getdisk(void); 
<p>

<b>
$(DESCRIPTION
</b><p>
The getdisk function calls DOS function 0x19 to return the current 
drive number. 0 represents drive A, 1 represents drive B, and so on. 
<p>

<b>
$(RETURNS
</b><p>
The current drive number. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#_getdrive">_getdrive</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for getdisk */ 

#include &lt;stdio.h&gt; 
#include &lt;dos.h&gt;

void main() 
{   
   printf("The current disk drive is %c\n", 
	     getdisk() + 'A'); 
} 
</pre>

<b>
$(OUTPUT
</b><p>
The current disk drive is C 



<!-- =========================================== -->

$(RTLENTRY1 getdta,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
char __far *getdta(void); 
<p>

<b>
$(DESCRIPTION
</b><p>
The getdta function returns the disk transfer address. 
<p>

<b>
$(RETURNS
</b><p>
A far pointer to the current disk transfer address. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#setdta">setdta</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for getdta */ 

#include &lt;stdio.h&gt; 
#include &lt;dos.h&gt;

void main() 
{   
   printf("The current disk transfer address is 
	   %Fp\n", getdta()); 
} 
</pre>

<b>
$(OUTPUT
</b><p>
The current disk transfer address is 1DD8: 0080 



<!-- =========================================== -->

$(RTLENTRY1 getfat,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void getfat(unsigned char drive, struct fatinfo *dtable); 
<p>

<b>
$(DESCRIPTION
</b><p>
The getfat function obtains the file allocation table information for 
the drive specified in the drive argument. 0 represents the default 
drive, 1 represents drive A, 2 represents drive B, and so on.<p>

The file allocation table information is placed in the structure 
pointed to by the dtable argument. This structure is of type 
fatinfo, which is defined as follows:<br>
<pre class="ccode">struct fatinfo 
{   
char fi_sclus; 	/* sectors per cluster */ 
char fi_fatid; 	/* the FAT id number */ 
unsigned fi_nclus; 	/* number of clusters */ 
int fi_bysec; 		/* bytes per sector */ 
}; 
</pre>
<p>

<b>
$(RETURNS
</b><p>
None
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#getfatd">getfatd</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for getfat 

	GETFAT. C 
*/ 
#include &lt;stdio.h&gt; 
#include &lt;dos.h&gt; 
#include &lt;stdlib.h&gt;

void main (int argc, char *argv[]) 
{   
   struct fatinfo fat; 
   int drive; 

   if (argc &lt; 2) 
      drive = 0; 
   else 
   {   
      drive = toupper (* argv[1]) -'A' + 1; 
      if (drive &lt;= 0 || drive &gt; 26) 
      {   
	 fprintf(stderr, "Usage: GETFAT [drive-
		  letter]\n"); exit (EXIT_FAILURE); 
      } 
   } 
   getfat (drive, &fat); 
   printf("number of clusters: %u\n", 
	     fat.fi_nclus); 
   printf("sectors per cluster: %d\n", 
	     fat. fi_sclus); 
   printf("bytes per sector: %d\n", 
	     fat.fi_bysec); 
   printf("FAT id number: %X\n", 
	     (unsigned char) fat.fi_fatid); 
} 
</pre>

<b>
$(OUTPUT
</b><br>
<pre class="console">C:\SC\EXAMPLES&gt; getfat a 
number of clusters: 2847 
sectors per cluster: 1 
bytes per sector: 512 
FAT id number: F0 

C:\SC\EXAMPLES&gt; getfat 
number of clusters: 65371 
sectors per cluster: 16 
bytes per sector: 512 
FAT id number: 74 
</pre>


<!-- =========================================== -->

$(RTLENTRY1 getfatd,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void getfatd(struct fatinfo *dtable); 
<p>

<b>
$(DESCRIPTION
</b><p>
The getfatd function obtains the file allocation table information 
for the default drive. This information is placed in the structure 
pointed to by the dtable argument.<p>

The dtable structure is of type fatinfo, which is defined as:<br>
<pre class="ccode">struct fatinfo 
{   
char fi_sclus;/* sectors per cluster */ 
char fi_fatid;/* the FAT id number */ 
unsigned fi_nclus;/* number of clusters */ 
int fi_bysec;/* bytes per sector */ 
}; 
</pre>
<p>

<b>
$(RETURNS
</b><p>
None
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#getfat">getfat</a>
<p>



<!-- =========================================== -->

$(RTLENTRY1 getpsp,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
unsigned getpsp(void); 
<p>

<b>
$(DESCRIPTION
</b><p>
The getpsp function uses DOS system call 0x62 to return the 
segment address of the program segment prefix. 
<p>

<b>
$(RETURNS
</b><p>
The program segment prefix. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#getenv">getenv</a><br>
<a href="#_getpid">_getpid</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for getpsp */ 

#include &lt;stdio.h&gt; 
#include &lt;dos.h&gt;

void main() 
{   
   printf("This program's psp is %X\n", 
	     getpsp()); 
} 
</pre>

<b>
$(OUTPUT
</b><br>
<pre class="console">C:\SC\EXAMPLES&gt; getpsp 
This program's psp is 1DD8 

C:\SC\EXAMPLES&gt; command /c getpsp 
This program's psp is 1EAC 
</pre>


<!-- =========================================== -->

$(RTLENTRY1 gettime,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void gettime(struct time *timep); 
<p>

<b>
$(DESCRIPTION
</b><p>
The gettime function copies the current system time into the 
structure pointed to by the timep argument. This structure is of type 
time, which has the following format:<br>
<pre class="ccode">struct time 
{   
unsigned char ti_min; 		/* minutes */ 
unsigned char ti_hour; 	/* hours */ 
unsigned char ti_hund; 	/* hundredths of a second */ 
unsigned char ti_sec; 		/* seconds */ 
}; 
</pre>
<p>

<b>
$(RETURNS
</b><p>
None
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

$(SEE_ALSO

<a href="io.html#getftime">getftime</a>
<p>

<b>
$(EXAMPLE
</b><p>
See settime


<!-- =========================================== -->

$(RTLENTRY1 getverify,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int getverify(void); 
<p>

<b>
$(DESCRIPTION
</b><p>
The getverify function returns the current status of the DOS 
verify flag. A verify flag of 0 means verification is off, writing is not verified. A verify flag of 1 means verification is on, writing is verified. 
<p>

<b>
$(RETURNS
</b><p>
The status of the verify flag (0 or 1). 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#setverify">setverify</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for getverify */ 

#include &lt;stdio.h&gt; 
#include &lt;dos.h&gt;

void main() 
{   
   printf("DOS verify is %s\n", getverify()? 
	     "on": "off"); 
} 
</pre>

<b>
$(OUTPUT
</b><p>
DOS verify is off 



<!-- =========================================== -->

$(RTLENTRY1 parsfnm,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
char *parsfnm(const char *cmdline, struct fcb *fcb, int opt); 
<p>

<b>
$(DESCRIPTION
</b><p>
The parsfnm function locates a filename by parsing argument 
cmdline. The file control block for the associated file is stored in 
the structure pointed to by argument fcb. Argument opt is the AL 
value for DOS parse system call 29h. The format of structure fcb is: <br>

<pre class="ccode">struct fcb
{   
char fcb_drive;/* 0= default, 1= A, etc */
char fcb_name[8];/* File name */ 
char fcb_ext[3];/* File extension */
short fcb_curblk;/* Current block number */ 
short fcb_filesize;/* File size in bytes */
short fcb_date;/* Date last written */ 
char fcb_resv[10];/* Reserved for DOS */
char fcb_crrec;/* Current record in block */ 
long fcb_random;/* Random record number */
}; 
</pre>
The pointer to the next byte of the command line, after the end of 
the filename. Null is returned when unsuccessful. 
<p>

<b>
$(RETURNS
</b><p>
The pointer to the next byte of the command line, after the end of 
the filename. Null is returned when unsuccessful. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#fnmerge">fnmerge</a><br>
<a href="#fnsplit">fnsplit</a><br>
<a href="#full_fullpathpath">full_fullpathpath</a><br>
<a href="#searchpath">searchpath</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for parsfnm */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;dos.h&gt;

void main()
{   
   char line[80];
   struct fcb block; 

   printf("Enter a filename: ");
   gets (line); 
   if (parsfnm (line, &block, 1) == NULL)
   {   
      perror (" parsfnm failed");
      exit (EXIT_FAILURE); 
   }
   else 
     printf("Drive: %d, name: \"%. 8s\",
	       extension \"%. 3s\"\n", 
	       block. fcb_drive,
	       block. fcb_name, block. fcb_ext); 
} 
</pre>

<b>
$(OUTPUT
</b><p>
Enter a filename: c: parsfnm. c<br>
Drive: 3, name: "PARSFNM ", extension "C " 



<!-- =========================================== -->

$(RTLENTRY1 peek,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int peek(unsigned seg, unsigned offset); 
<p>

<b>
$(DESCRIPTION
</b><p>
Returns the integer value located at the given seg: offset address. 
<p>

<b>
$(RETURNS
</b><p>
The value at the given seg: offset address. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#poke">poke</a><br>
<a href="#peekb">peekb</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for peek
	Also demonstrates peekb, poke, pokeb 
*/ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;dos.h&gt;

#define KBCTRLBYTEADDR 0x417
#define NUMLOCKBIT 0x20 

void syntax()
{   
   printf("Usage: NUMLOCK &lt;+|-&gt;\n");
   exit (EXIT_FAILURE); 
} 

void main (int argc, char *argv[])
{   
   char state; 

   if (argc &lt;&gt; 2)
      syntax(); 

   if (argv[1][0] == '+ ')
   {   
      state = peekb (0, KBCTRLBYTEADDR);
      state |= NUMLOCKBIT; 
      pokeb (0, KBCTRLBYTEADDR, state);
   } 
   else if (argv[1][0] == '-')
   {   
      state = peekb (0, KBCTRLBYTEADDR);
      state &amp;= ~NUMLOCKBIT; 
      pokeb (0, KBCTRLBYTEADDR, state);
   } 
   else 
      syntax(); 
} 
</pre>

<!-- =========================================== -->

$(RTLENTRY1 peekb,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
char peekb(unsigned segment, unsigned offset); 
<p>

<b>
$(DESCRIPTION
</b><p>
The peekb function returns the byte at the memory location 
specified by the segment and offset arguments. 
<p>

<b>
$(RETURNS
</b><p>
The specified byte. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#peek">peek</a><br>
<a href="#pokeb">pokeb</a>
<p>

<b>
$(EXAMPLE
</b><p>
See peek


<!-- =========================================== -->

$(RTLENTRY1 poke,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void poke(unsigned seg, unsigned offset);  
<p>

<b>
$(DESCRIPTION
</b><p>
Copies the int value to the given seg: offset address. 
<p>

<b>
$(RETURNS
</b><p>
None
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#peek">peek</a><br>
<a href="#pokeb">pokeb</a>
<p>

<b>
$(EXAMPLE
</b><p>
See peek


<!-- =========================================== -->

$(RTLENTRY1 pokeb,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void pokeb(unsigned segment, unsigned offset, char value); 
<p>

<b>
$(DESCRIPTION
</b><p>
The pokeb function copies the byte in the value argument to the 
location specified by the segment and offset arguments. 
<p>

<b>
$(RETURNS
</b><p>
None
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#peekb">peekb</a><br>
<a href="#poke">poke</a>
<p>

<b>
$(EXAMPLE
</b><p>
See peek

<!-- =========================================== -->

$(RTLENTRY1 response_expand,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int __pascal response_expand(int *argc, char *** argv); 
<p>

<b>
$(DESCRIPTION
</b><p>
The response_expand function expands an argument list read 
from a response file. The response file must be passed in the form 
@filename. Any existing command line arguments are preserved. 
Response files can be nested. response_expand will also expand 
command line arguments based on environment variables rather 
than response file names. 
<p>

<b>
$(RETURNS
</b><p>
0 if successful, otherwise non-zero, in which case argc and argv 
are unchanged. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for _response_expand */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;mem.h&gt;
#include &lt;dos.h&gt;

void main (int argc, char *argv[])
{   
   int i; 

   response_expand (&amp; argc, &argv);
   printf("There are %d command line 
	     parameters\n", argc -1); 

   for (i = 1; i &lt; argc; i++)
   {   
   puts (argv[i]);
   } 
} 
</pre>

<b>
$(OUTPUT
</b><p>
C:\SC\EXAMPLES&gt; redumpar 1 2 3 @in 4 5 6<br>
There are 12 command line parameters<br> 
1<br> 
2<br> 
3<br>
One<br> 
Two<br> 
Three<br> 
Four<br> 
Five<br> 
Six<br> 
4<br> 
5<br>
6<br> 


<!-- =========================================== -->

$(RTLENTRY1 setblock,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int setblock(unsigned segx, unsigned newsize); 
<p>

<b>
$(DESCRIPTION
</b><p>
The setblock function changes the size of the memory block 
specified in the segx argument to be the size, in paragraphs, 
specified in the newsize argument. The segx argument contains a 
value returned by a previous call to allocmem. 
<p>

<b>
$(RETURNS
</b><p>
If successful, -1 is returned. Otherwise, the size of the largest 
possible block, in paragraphs, is returned and errno and 
_doserrno are set. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#allocmem">allocmem</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for setblock */ 

#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main() 
{   
   unsigned int size, segp;
   int stat; 

   size = 1024; /* This is is paragraphs,
		   1024 * 16 = 16384 */ 
   stat = allocmem (size, &segp); 
   if (stat != -1)
   {   
      printf("Unable to allocate memory\n");
      exit (EXIT_FAILURE); 
   } 
   printf("Allocated 16384 bytes with allocmem 
	     () at segment %04X\n", segp); 

   stat = setblock (segp, size / 2);
   if (stat != -1) 
   {
      printf("Unable to reallocate memory, 
		maximum size is %d\n", stat);
      exit (EXIT_FAILURE); 
   } 
      printf("Shrunk the memory block at 
		segment %04X\n", segp); 

      freemem(segp);
} 
</pre>

<b>
$(OUTPUT
</b><p>
Allocated 16384 bytes with allocmem() at<br>
segment 33F2<br> 
Shrunk the memory block at segment 33F2<br>



<!-- =========================================== -->

$(RTLENTRY1 setcbrk,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
int setcbrk(int cbrkvalue); 
<p>

<b>
$(DESCRIPTION
</b><p>
The setcbrk function uses DOS system call 0x33 to set the control-break 
setting to the value specified in the cbrkvalue argument. A 
value of 0 limits checking to device communications such as console 
I/ O and printer I/ O. A value of 1 checks at every system call. 
<p>

<b>
$(RETURNS
</b><p>
The value of the cbrkvalue argument. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#getcbrk">getcbrk</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for setcbrk */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;dos.h&gt;

void syntax()
{   
   printf("Usage: setcbrk &lt;+|-&gt;\n");
   exit (EXIT_FAILURE); 
} 
void main (int argc, char *argv[]) 
{
   char state; 

   if (argc != 2) 
      syntax(); 

   if (argv[1][0] == '+ ')
   {   
      setcbrk(1);
   } 
   else if (argv[1][0] == '-')
   {   
      setcbrk(0); 
   } 
   else syntax(); 
} 
</pre>

<b>
$(OUTPUT
</b><p>
C:\SC\EXAMPLES&gt; setcbrk + <p>

C:\SC\EXAMPLES&gt; break<br>
BREAK is on<p> 

C:\SC\EXAMPLES&gt; setcbrk -C:\<p>

SC\EXAMPLES&gt; break<br>
BREAK is off 



<!-- =========================================== -->

$(RTLENTRY1 setdisk,


$(HEADER
</b><p>
direct.h
<p>

<b>
$(PROTOTYPE
</b><p>
int setdisk(int drive); 
<p>

<b>
$(DESCRIPTION
</b><p>
The setdisk function sets the current drive to the one specified in 
the drive argument. 0 indicates drive A, 1 indicates drive B, and so 
on. 
<p>

<b>
$(RETURNS
</b><p>
The number of drives available. 
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#getdisk">getdisk</a>
<p>

<b>
$(EXAMPLE
</b><p>
See getdisk

<!-- =========================================== -->

$(RTLENTRY1 setdta,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void setdta(char far *dta); 
<p>

<b>
$(DESCRIPTION
</b><p>
The setdta function sets the disk transfer address to the value 
specified in the dta argument. 
<p>

<b>
$(RETURNS
</b><p>
None
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#getdta">getdta</a>
<p>



<!-- =========================================== -->

$(RTLENTRY1 setverify,


$(HEADER
</b><p>
dos.h
<p>

<b>
$(PROTOTYPE
</b><p>
void setverify(int value); 
<p>

<b>
$(DESCRIPTION
</b><p>
The setverify function sets the verify flag to the value specified 
in the value argument. A value of 0 indicates that the verify flag is 
off and writes to disk are not verified. A value of 1 indicates that the verify flag is on and all writes to disk are verified. 
<p>

<b>
$(RETURNS
</b><p>
None
<p>

<b>
$(COMPATIBILITY
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
$(SEE_ALSO
</b><p>
<a href="#getverify">getverify</a>
<p>

<b>
$(EXAMPLE
</b><p>
<pre class="ccode">/* 	Example for setverify */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;dos.h&gt;

void syntax() 
{   
   printf("Usage: setver &lt;+|-&gt;\n"); 
   exit (EXIT_FAILURE); 
} 

void main (int argc, char *argv[]) 
{   
   char state; 

   if (argc &lt;&gt; 2) 
   syntax(); 

   if (argv[1][0] == '+ ') 
{   
   setverify(1); 

} 
else if (argv[1][0] == '-') 
{   
   setverify(0); 

} 
else 
   syntax(); 
} 
</pre>

<b>
<dt><b>Output</b></dt> <dd></b><p>
<pre class="console">C:\DM\EXAMPLES&gt; setver + 

C:\DM\EXAMPLES&gt; verify VERIFY is on 

C:\DM\EXAMPLES&gt; setver -

C:\DM\EXAMPLES&gt; verify VERIFY is off 
</pre>

</dd>




<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

