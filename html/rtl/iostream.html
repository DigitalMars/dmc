
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - IOstream
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:14 2006
</div>
</div>

<!-- Generated by Ddoc from iostream.d -->



<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>IOstream</h1>

This chapter consists of:

<ul>
	<li> An introduction to the iostream library
	<li> Terminology of Iostreams
	<li> Examples of how to use various aspects of the library
	<li> Sample program

	<li><a href="#filebuf"><b>Class filebuf</b></a>
	<li><a href="#Xstream"><b>Classes fstream, ifstream, and ofstream</b></a>
	<li><a href="#ifstream"><b>Class ifstream</b></a>
	<li><a href="#ios"><b>Class ios</b></a>
	<li><a href="#istream"><b>Class istream</b></a>
	<li><a href="#istream_withassign"><b>Class istream_withassign</b></a>
	<li><a href="#istrstream"><b>Class istrstream</b></a>
	<li><a href="#ofstream"><b>Class ofstream</b></a>
	<li><a href="#ostream"><b>Class ostream</b></a>
	<li><a href="#ostream_withassign"><b>Class ostream_withassign</b></a>
	<li><a href="#ostrstream"><b>Class ostrstream</b></a>
	<li><a href="#stdiobuf"><b>Class stdiobuf</b></a>
	<li><a href="#stdiostream"><b>Class stdiostream</b></a>
	<li><a href="#streambuf"><b>Class streambuf</b></a>
	<li><a href="#strstream"><b>Class strstream</b></a>
	<li><a href="#strstreambuf"><b>Class strstreambuf</b></a>
</ul>

This chapter does not have descriptions of the classes and functions. 
Chapter 27, "Iostream Library Class Descriptions," has descriptions 
of the classes and functions.<p>

C++, like C, has no built-in input or output statements. Instead, I/O 
facilities are provided by a library. The standard C++ I/O library is 
the iostream library.<p>

As with much of object oriented programming, iostreams can be 
difficult to understand without reading through the material more 
than once. A terminology section defines many of the basic terms.<p></font>

<font size=4><b>
Predefined Iostreams</font></b><p>

<font size=3>
The four predefined iostreams are:

<ul>
	<li> cin, connected to standard input.
	<li> cout, connected to standard output.
	<li> cerr, connected to standard error.
	<li> clog, connected to standard error.
</ul>

The predefined iostreams are fully buffered, except for cerr. See 
the "Output Using Iostreams" and "Input Using Iostreams" sections.<p></font>

<font size=4><b>
Basic Structure of Iostream Interaction</font></b><p>

The iostream library allows a program to use any number of input or 
output streams. Each stream has some source or sink, which might 
be one of the following:<p>

<ul>
	<li> Standard input
	<li> Standard output
	<li> A file
	<li> An array of characters
</ul>

A stream can be restricted to input or output, or a single stream can 
allow both input and output. The iostream library implements these 
streams using two processing layers.<p>

<ul>
	<li> The lower layer implements sequences, which are simply 
	streams of characters. These sequences are implemented 
	by the streambuf class, or by classes derived from it.<p>

	<li> The upper layer performs formatting operations on 
	sequences. These formatting operations are implemented 
	by the istream and ostream classes, which have as a 
	member a pointer to an object of a type derived from 
	class streambuf. An additional class, iostream, is for 
	performing input and output on streams.
</ul>

Standard input and output are handled by special class objects 
derived from class istream or ostream.<p>

The ifstream, ofstream, and fstream classes, which are 
derived from istream, ostream, and iostream respectively, 
handle input and output with files.<p>

The istrstream, ostrstream, and strstream classes, which 
are derived from istream, ostream, and iostream respectively, 
handle input and output to and from arrays of characters.<p>

When you want to open an input or output stream, you create an 
object of one of these types. You associate the streambuf 
member of the stream with a device or file. You generally do this 
association through the stream constructor, so you don't deal with 
the streambuf directly. The iostream library predefines stream 
objects for the standard input, standard output, and error output, so 
you don't have to create your own objects for those streams.<p>

You use operators or iostream member functions to insert data into a 
stream (output) or extract data from a stream (input), and to control 
the format of data that you insert or extract.<p>

To insert and extract a new data type (that is, one of your classes), 
you generally overload the insertion and extraction operators.<p>
</font>

<font size=4><b>
Iostream Terminology</font></b><p>

<font size=3>
The iostream libarary descriptions use the following terms, which are 
similar to terms from general programming but with specialized 
meanings.<p>
<dl><b>
Term/Definition</b><br>
<dt>buffer 
<dd>A word with two meanings, one specific to the iostream package and one more generally applied to input and output.<p> 

<dd>When referring specifically to the iostream library, a buffer is an object of the type defined by the class streambuf.<p>

<dd>A buffer, generally, is a block of memory used to make efficient transfer of characters for input or output. With buffered I/O, the actual transfer of characters is delayed until the buffer is full or forceably flushed.<p>

<dd>This confusion allows such odd phrases as "an unbuffered buffer", which refers to a streambuf where there is no buffer in the first sense defined above. Because of this confusion, this chapter avoids use of the term buffer to refer to streambufs. However, the next chapter and other C++ documents use the term buffer to mean streambufs.<p>

<dt>extraction<br>
<dd>The process of taking input from an iostream.<p>
			
<dt>fstream 		
<dd>An input or output stream for use with files.<p>

<dt>insertion
<dd>The process of sending output into an iostream. <p>

<dt>iostream
<dd>Generally, an input or output stream but can also refer to any of the 			classes in the iostream library.<p>

<dt>Iostream
library
<dd>The library implemented by header files iostream.h, fstream.h, 			strstream.h, iomanip.h, and stdiostream.h. Because iostream is an 				object-oriented library, you should extend it.	So, some of what you can 			do with the iostream library is not implemented.<p>

<dt>stream
<dd>An iostream, fstream, strstream, or user-defined stream.<p>

<dt>streambuf
<dd>A buffer that contains a sequence of characters with a put or get pointer, or both. It refers generally to any object of class streambuf or a class derived from streambuf. Any stream object contains an object, or a pointer to an object, of a type derived from streambuf.<p>

<dt>strstream
<dd>An iostream for use with character arrays.<p>

</font></dl>

<font size=4><b>
Using Iostreams</font></b><p>

<font size=3>
To use iostream routines, include the header files for the part of the 
library you need. The header files are:<p>
<dl><b>
Header File/Description</b> 
<dt>iostream.h
<dd>Declares basic features of iostream library. 
<dt>fstream.h
<dd>Declares iostreams and streambufs specialized to files. Includes iostream.h. 
<dt>strstream.h
<dd>Declares iostreams and streambufs specialized to character arrays. Includes iostream.h. 
<dt>iomanip.h 		
<dd>Declares manipulators (values you insert into or extract from iostreams to have different effects). 
<dt>fstream.h (obsolete)
<dd>Declares iostreams and streambufs specialized to use stdio FILEs. Includes iostream.h. 
stream.h (obsolete)  For compatibility with old-style streams from C++ version 1. 2. Includes iostream.h, fstream.h, iomanip.h, and stdiostream.h 
</dl></font><p>

<font size=4><b>
Output Using Iostreams</font></b><p>

<font size=3>
Output using iostreams usually relies on the overloaded left shift 
operator (&lt;&lt;) which, in the context of iostream, is called the 
insertion operator. To send a value to standard output, insert the 
value in the predefined output stream cout and use the insertion 
operator. For example:<p>

cout &lt;&lt; someValue;<p>

The insertion operator, overloaded for all built-in types, converts the 
value of someValue to its correct output representation. If, for 
example, someValue is a float value, the &lt;&lt; operator converts 
the value to the correct sequence of digits and includes a decimal 
point. Where it inserts float values on the output stream, &lt;&lt; is 
called the float inserter. In general, given a type X, &lt;&lt; is called the X inserter. The format of output and how to control it is discussed in 
the "Format Control" section.<p>

The iostream library does not know about user-defined types. If you 
define types for output, you must define an inserter (that is, overload 
the &lt;&lt; operator) to handle them correctly.<p>

The &lt;&lt; operator may be applied repetitively. To insert two values on 
cout, use the statement:<p>

cout &lt;&lt; someValue &lt;&lt; anotherValue;<p>

Output shows no space between the two values. To include spaces 
in the output use the statement:<p>

cout &lt;&lt; someValue &lt;&lt; " " &lt;&lt; anotherValue;<p>

The &lt;&lt; operator has the precedence of the left shift operator (its 
built-in meaning). As with other operators, you can always use 
parentheses to guarantee the order of action. It is often a good idea 
to use parentheses to avoid problems of precedence. Of the 
following four statements, the first two are equivalent, but the last 
two are not.<p>

cout &lt;&lt; a+ b; // + has higher precedence than &lt;&lt;<br>
cout &lt;&lt; (a+ b);<br>
cout &lt;&lt; (a&amp; y);// &lt;&lt; has precedence higher than &amp;<br>
cout &lt;&lt; a&amp; y;// probably an error: (cout &lt;&lt; a) &amp; y<p> 
 
<b>Defining Your Own Insertion Operator</b><br>
The string class defined in the "Sample Program" section has this 
definition:<p>
<pre>
class string {
private: 
   char* data;
   size_t size; 

public: 
   (functions not relevant here) 

friend ostream&amp; operator&lt;&lt;(ostream&amp;, 
       const string&amp;); 
friend istream&amp; operator&gt;&gt;(istream&amp;, string&amp;); 
}; 
</pre>

The insertion and extraction operators in this case must be defined 
as friends because the data part of the string class is private.  The definition of operator&lt;&lt; overloaded for use with strings is:<p>
<pre>
ostream&amp; operator&lt;&lt; (ostream&amp; ostr, 
         const string&amp; output) 
{ return ostr &lt;&lt; output. data;}
</pre> 
operator&lt;&lt; takes a reference to an ostream&amp; as its first 
argument and returns the same ostream, making it possible to 
combine insertions in one statement:<p>

cout &lt;&lt; string1 &lt;&lt; string2;<p>

<B>Handling Output Errors</b><br>
Checking for errors when overloading operator&lt;&lt; is not necessary 
because the iostream library can propagate errors.<p>

When an error occurs, the iostream where it occurred enters an error 
state. Bits in the iostream's state are set according to the general 
category of the error. The inserters defined in iostream ignore 
attempts to insert data into any stream that is in an error state, so 
such attempts do not change the iostream's state.<p>

In general, the recommended way to handle errors is to check the 
state of the output stream periodically in some central place. If an 
error exists, you should handle it in some way. This chapter assumes 
that you define a function error, which takes a string and aborts 
the program. error is not a predefined function. See "Handling 
Input Errors" for an example of an error function. Examine the 
state of an iostream with the operator !, which will return a nonzero 
value if the iostream is in an error state. For example:<p>
<pre>
	if (! cout) error("output error"); 
</pre>
Another way to test for errors exists. The ios class defines 
operator void *() so it returns a NULL pointer when an error 
occurs. This allows you to use a statement like this:<p> 
<pre>
if (cout &lt;&lt; x) return ; // return if successful 
</pre>
You can also use the function good, a member of ios:<p>
<pre>
if (cout. good() ) return; // return if successful 
</pre>
The error bits are declared the definition of class ios in the enum:<br> 
<pre>
enum io_state {goodbit= 0, eofbit= 1, failbit= 2, 
                badbit= 4, hardfail= 0x80} ; 
</pre>
<b>Flushing</b><br>
As with most I/O libraries, iostream often accumulates output and 
sends it on in larger and generally more efficient chunks. To flush 
the buffer, simply insert the special value flush. For example:<p>
<pre>
cout &lt;&lt; "Needs to get out immediately." &lt;&lt; flush; 
</pre>
flush is a kind of object known as a manipulator, which is a value 
that may be inserted into an iostream to have some effect other than 
causing output of its value. It is really a function that takes an 
ostream&amp; or istream&amp; argument and returns its argument after 
performing some actions on it (see "Manipulators").<p>

<b>Binary Output</b><br>
To obtain output in the raw binary form of a value, use the member 
function write as:<p> 
<pre>
cout. write((char*)&amp; x, sizeof(x)); 
</pre>

This, however, violates type discipline by converting &x to char*. 
Doing so is normally harmless, but if the type of x is a class with 
pointers, virtual member functions, or one that requires nontrivial 
constructor actions, the value written by the above example cannot 
be read back in properly.</font><p>

<font size=4>
<b>Input Using Iostreams</font></b><p>
<font size=3>
Input using iostream is similar to output. Use the extraction operator 
&gt;&gt; and string together extractions the way you can with insertions. 
For example to get two values from standard input:<p>
<pre>
cin &gt;&gt; a &gt;&gt; b ; 
</pre>
As with other overloaded operators, the extractors used depend on 
the types of a and b (and two different extractors are used if a and b 
have different types). The format of input and how you can control it 
is discussed in some detail in "Format Control". In general, though, 
leading whitespace characters (spaces, newlines, tabs, form-feeds, 
and so on) are ignored.</font><p>

<font size=4><b>
Defining Your Own Extraction Operators</font></b><p>

When you want input for a new type, you overload the extraction 
operator for it, just as you overload the insertion operator for output.<p>

Class string (shown in sections "Output Using Iostreams" and 
"Sample Program") defines its extraction operator like this:<p> 
<pre>
istream&amp; operator&gt;&gt; (istream&amp; istr, string&amp; input) 
{ 
   const int maxline = 256; 
   char holder[maxline]; 
   istr. get(holder, maxline, '\n'); 
   input = holder; 
   return istr; 
} 
</pre>
By convention, an extractor converts characters from its first 
argument (in this case, istream&amp; istr), stores them in its second 
argument (always a reference) and returns its first argument. The 
second argument must be a reference because an extractor is meant 
to store the input value in its second argument.</font><p>

<font size=4><b>
The char* Extractor</font></b><p>
<font size=3>
This predefined extractor is mentioned here because it can cause 
problems. You use it like this:<p>
<pre>
char x[50];
cin &gt;&gt; x; 
</pre>
The extractor skips leading whitespace and extracts characters and 
copies them to x until it reaches another whitespace character. It 
then completes the string with a terminating null (0) character. Be 
careful because input can overflow the given array.</font><p>

<font size=4><b>
Reading Any Single Character</font></b><p>
<font size=3>
The char extractor skips whitespace, which can be a problem if 
your program needs to read the next character whether or not it is 
whitespace. To do this with either form of function get member:<p>
<pre>
char c;
cin. get(c); // leaves c unchanged if input fails

int b;
b = cin. get(); // sets b to EOF if input fails
</pre>
To skip only blanks, stopping on a tab, newline, or any other 
character:<p>
<pre>
int a;
do { 
    a = cin. get(); 
while(a == ' ' ); 
</pre>
</font>
<font size=4><b>
Binary Input</font></b><p>
<font size=3>
To read binary values (such as those written with the member 
function write), use the read member function. To input the raw 
binary form of x using the read member function, do the following, 
which is the inverse of the earlier example that used write.<p>
<pre>
cin. read((char*)&amp; x, sizeof(x)); 
</pre>
</font>
<font size=4><b>
Peeking at Input</font></b><p>
<font size=3>
Use the peek member function to look at the next character in the stream without extracting it. For example:<p>
<pre>
if (cin. peek() != c) return 0; 
</pre>
</font>
<font size=4><b>
Extracting Whitespace</font></b><p>
<font size=3>
By default, iostream extractors skip leading whitespace. You can turn off the skip flag to prevent this from happening. The following code turns off whitespace skipping from cin, then turns it on again.<p>
<pre>
cin. unsetf(ios::skipws); // turn off . . . 

cin. setf(ios::skipws, ios::skipws); // turn on
</pre>
You can use the iostream manipulator ws to remove leading 
whitespace from the iostream, whether or not skipping is enabled. 
To remove the leading whitespace from iostream istr:<br>
<pre>
istr &gt;&gt; ws; 
</pre></font><br>
<font size=4><b>
Handling Input Errors</font></b><p>
<font size=3>
By convention, an extractor whose first argument has a nonzero error state should not extract anything from the input stream and should not clear any error bits. An extractor that fails should set at least one error bit.<p>

As with output errors, you should check the error state periodically 
and take some action (such as aborting) when you find a nonzero 
state. The ! operator returns the error state of an iostream. For 
example, the following code produces an input error if you type 
alphabetic characters for input:<p>
<pre>
#include &lt;stream.h&gt; 
#include &lt;stdlib.h&gt;
void error (const char* message) { 
   cout &lt;&lt; message &lt;&lt; "\n" ; 
   exit(1); 
} 
main() { 
   cout &lt;&lt; "Enter some characters: "; 
   int bad; 
   cin &gt;&gt; bad; 
   if (! cin) error(" aborted due to input error"); 
   cout &lt;&lt; "If you see this, not an error." &lt;&lt; 
"\n"; 
   return 0; 
} 
</pre>
Class ios has member functions that you can use for error handling. 
See the next chapter.</font><p>

<font size=4><b>
Using Iostreams with stdio</font></b><p>
<font size=3>
You can use stdio with C++ programs, but problems can occur 
when you mix iostreams and stdio in the same standard stream 
within a program. For example, if you write to both stdout and 
cout, independent buffering will occur; results might not be what 
you expect. The problem is worse if you input from both stdin and 
cin, since independent buffering can turn the input into trash.<p>

To eliminate this problem with standard input, standard output, and 
standard error, use the following instruction before performing any 
input or output. It connects all the predefined iostreams with the 
corresponding predefined stdio FILEs.<p>
<pre>
ios::sync_with_stdio(); 
</pre>

Such a connection is not the default because a significant 
performance penalty occurs when the predefined streams are made 
unbuffered as part of the connection. You can use both stdio and 
iostreams in the same program applied to different files with no 
difficulty. That is, you can write to stdout using stdio routines 
and write to other files attached to iostreams. You can open stdio 
FILEs for input and also read from cin so long as you do not also 
try to read from stdin.</font><p>

<font size=4><b>
Creating Iostreams</font></b><p>
<font size=3>
To read or write a stream other than the predefined iostreams, you 
must create your own iostream. In general that means creating 
objects of types defined in the iostream library. The following 
sections discuss the various types available.</font><p>

<font size=4><b>
Dealing with Files Using Class fstream</font></b><p>
<font size=3>
Dealing with files is similar to dealing with standard input and 
standard output; classes ifstream, ofstream, and fstream are 
derived from classes istream, ostream and iostream, 
respectively. As derived classes, they inherit the insertion and 
extraction operations (along with the other member functions) and 
also have members and constructors for use with files.<p>

You must include the file fstream.h to use any of the fstreams. 
Use an ifstream when you only want to perform input, an 
ofstream for output only, and an fstream for a stream on which 
you want to perform both input and output. Use the name of the file 
as the constructor argument.<p>

For example, to copy the file thisFile to the file thatFile:<p> 
<pre>
ifstream fromFile(" thisFile");
if (! fromFile) 
   error(" unable to open 'thisFile' for input"); 
ofstream toFile (" thatFile"); 
if (!toFile ) 
   error(" unable to open 'thatFile' for output"); 
char c ; 
while (toFile &amp;&amp; fromFile. get(c)) toFile. put(c); 
</pre>

This code:

<ul>
	<li> Creates an ifstream object called fromFile with a 
	default mode of ios: in and connects it to thisFile (it 
	opens thisFile).

	<li> Checks the error state of the new ifstream object and, 
	if it is not 0, calls the error function (which must be 
	defined elsewhere in the program).

	<li> Creates an ofstream object called toFile with a 
	default mode of ios::out and connects it to 
	thatFile.

	<li> Checks the error state of toFile.

	<li> Creates a char variable to hold the data while it is 
	passed.

	<li> Copies the contents of fromFile to toFile one 
	character at a time.
</ul>

Note<br>
You would not really copy a file this way, one 
character at a time. This code is provided only as an 
example of using fstreams. Instead, insert the 
streambuf associated with the input stream into 
the output stream.<p>

<b>Open Mode</b><br>
The mode is constructed by or-ing bits from the enumerated type 
open_mode, which is an public type of class ios and has the 
definition:<p>
<pre>
	enum open_mode {in= 1, out= 2, ate= 4, app= 8, 
		trunc= 0x10, nocreate= 0x20, noreplace= 0x40}; 
</pre>
You can open a file for both input and output. For example, the 
following code opens file someName for both input and output, 
attaching it to the fstream variable inoutFile.<p>
<pre>
fstream inoutFile("someName", ios::in | ios::out); 
</pre>
<b>Declaring an fstream Without Specifying a File</b><br>
You can declare an fstream without specifying a file and open the 
file later. For example, to create the ofstream toFile for writing.<br>
<pre>
ofstream toFile; 
toFile.open(argv[1], ios::out); 
</pre>

<b>Opening and Closing Files</b><br>
You can close the fstream and then open it with another file. For 
example, to process a list of files provided on the command line:<p>
<pre>
	ifstream infile; 
	for (char** f = &argv[1]; *f; ++f)
	{   
	   infile.open(*f, ios::in);
	   ...; 
	   infile.close();
	} 
</pre>
<b>Opening a File Using a File Descriptor</b><br>
If you know a file descriptor (such as the integer 1 for standard 
output), you can open it like this:<p>
<pre>
ofstream outfile; 
outfile. attach(1); 
</pre>
When you open a file by providing its name to one of the fstream 
constructors or by using the open function, the file automatically 
closes when the fstream is destroyed (by a delete or when it goes 
out of scope). When you attach a file to an fstream, it does not 
automatically close.<p>

<b>Repositioning Within a File</b><br>
Several tools can alter the reading and writing position in a file.

<ul>
	<li> streampos, a type that records a position in an 
	iostream.<p>

	<li> tellg (tellp), an istream (ostream) member 
	function that reports the file position. Since istream and 
	ostream are the parent classes of fstream, tellg and 
	tellp can also be invoked as a member function of the 
	fstream class.<p>

	<li> seekg (seekp), an istream (ostream) member 
	function that finds a given position.<p>

	<li> seek_dir, enum that specifies relative positions for use 
	with seek:<p>

	enum seek_dir {beg= 0, cur= 1, end= 2 }<p>
</ul>

For example, given an fstream aFile:<p> 
<pre>
	streampos original = aFile.tellp(); // save current position
	aFile.seekp(0, ios::end); 	    // reposition to end of file
	aFile &lt;&lt; x; 			    // write a value to file
	aFile.seekp(original); 		    // return to original position
</pre>

seekg (seekp) can take one or two parameters. When it has two 
parameters, the first is a position relative to the position indicated by 
the seek_dir value given as the second parameter. For example, to 
move 10 bytes from the end:<p>
<pre>
	aFile.seekp(-10, ios::end); 
</pre>

To move 10 bytes forward from the current position:<p> 
<pre>
	aFile.seekp(10, ios::cur); 
</pre>

Note<br>
Arbitrary seeking on text streams is not portable.</font><p>

<font size=4><b>
Assigning Iostreams</font></b><p>
<font size=3>
Earlier versions of C++ allowed assignment of one stream to another. 
This is no longer allowed.<p>

The problem with copying a stream object is that when two versions 
of the state information exist (such as a pointer to the current write 
point within an output file) each might be changed independently. 
This can cause problems. Copying stream objects is usually not 
necessary.</font><p>

<font size=4><b>
Format Control</font></b><p>
<font size=3>
Format control is described in the next chapter.</font><p>

<font size=4><b>
Manipulators</font></b><p>
<font size=3>
A manipulator is a value you can insert into or extract from iostreams 
to have special effects.<p>

Because manipulators are ordinary identifiers, and therefore use up 
possible names, iostream does not define them for every possible 
function. Manipulators are listed and described in the next chapter.<p> 

To use predefined manipulators, include header file iomanip.h in 
your program.<p> 

You can define your own manipulators. The two basic kinds of 
manipulators are:

<ul>
	<li> Plain manipulator
	<li> Parameterized manipulator.
</ul>

</font>
<font size=4><b>
Plain Manipulators</font></b><p>
<font size=3>
A plain manipulator is a function that<p>

<ol>
	<li> Takes a reference to a stream (takes an istream&amp;, 
	ostream&amp;, or ios&amp; argument).
	<li> Operates on it in some way.
	<li> Returns its argument.
</ol>

The shift operators taking (a pointer to) such a function are 
predefined for iostreams, so the function may be put in a sequence 
of input or output operators. The shift operator calls the function 
rather than trying to read or write a value.<p>

An example of a tab manipulator that inserts a tab in an ostream:<p>
<pre>
 ostream&amp; tab(ostream&amp; os) { 
         return os &lt;&lt; '\t' ; 
	 } 
 ... 
 cout &lt;&lt; x &lt;&lt; tab &lt;&lt; y ; 
</pre>

This is an elaborate way to achieve what could be done with:<p>
<pre>
 const char tab = '\t'; 
 ... 
 cout &lt;&lt; x &lt;&lt; tab &lt;&lt; y; 
</pre>
Here is another example, which cannot be accomplished with a 
simple constant. Suppose you want to turn whitespace skipping on 
and off for an input stream. You can use separate calls to 
ios::setf and ios::unsetf to turn the skipws flag on and off, 
or you could define two manipulators:<p>
<pre>
ostream&amp; skipon(istream &is) { 
       is. setf(ios::skipws, ios::skipws); 
       return is; 
} 

ostream&amp; skipoff(istream&amp; is) { 
       is. unsetf(ios::skipws); 
       return is; 
} 

 ... 
cin &gt;&gt; skipon &gt;&gt; x &gt;&gt; skipoff &gt;&gt; y; 
</pre>
</font>
<font size=4><b>
Parameterized Manipulators</font></b><p>
<font size=3>
A parameterized manipulator takes one or more parameters. It:<p> 

<ol>
	<li> Takes an istream&amp;, ostream&amp;, or ios&amp; argument, 
	one additional argument (the parameter).
	<li> Operates on the stream.
	<li> Returns its stream argument.
</ol>

One of the parameterized manipulators in iomanip.h is setfill. 
setfill sets the character that fills out field widths. It is 
implemented as:<p>
<pre>
	// file setfill.cpp 
	#include &lt;iostream.h&gt;
	#include &lt;iomanip.h&gt;

	// the private manipulator 
	static ios&amp; sfill(ios&amp; i, int f) { 
		 i.fill((char) f); 
		 return i; 
	} 

	// the public applicator 
	smanip_int setfill(int f) { 
		return smanip_int(sfill, f); 
	} 
</pre>

A parameterized manipulator is implemeted in two parts:<p>

<ul>
	<li> manipulator
	<li> applicator
</ul>

The manipulator looks like any other manipulator, except it takes an 
extra parameter. In the previous code example, it takes an extra int 
parameter. You cannot place this manipulator function in a sequence 
of input or output operations, since no shift operator is defined for it. 
Instead, you must use an auxiliary function- the applicator.<p> 

The applicator calls the manipulator. The applicator is a global 
function, and you make a prototype for it available in a header file. 
Usually the manipulator is a static function in the file containing the 
source code for the applicator. The manipulator is called only by the 
applicator. If you make it static, its name stays out of the global 
address space.<p>

Several classes are defined in the header file iomanip.h. Each class 
holds the address of a manipulator function and the value of one 
parameter. Chapter 27, "Iostream Library Class Descriptions," 
describes iomanip classes. The previous example uses the 
smanip_int class, which works with an ios. Because it works 
with an ios, it also works with an istream and an ostream. The 
previous example also uses a second parameter of type int.<p> 

The applicator creates and returns a class object. In the previous 
code example the class object is an smanip_int, and it contains 
the manipulator and the int argument to the applicator. The 
iomanip.h file defines the shift operators for this class. When the 
applicator function setfill appears in a sequence of input or 
output operations, the applicator function is called, and it returns a 
class. The shift operator acts on the class to call the manipulator 
function with its parameter value, which was stored in the class.<p> 

In the next code example, the manipulator print_hex does the 
following: <p>

1. Puts the output stream into the hex mode.<p>

2. Inserts a long value into the stream.<p>

3. Restores the conversion mode of the stream.<p>

The class omanip_long is used because this code example is for 
output only, and it operates on a long rather than an int.<p>
<pre>
	static ostream&amp; xfield(ostream&amp; os, long v)
	{ 
		long save = os. setf(ios::hex, ios::basefield); 
		os &lt;&lt; v; 
		is. setf(save, ios::basefield); 
		return s; 
	}
 
	omanip_long print_hex(long v)
	{ 
		return omanip_long(xfield, v); 
	} 
</pre></font><br>
<font size=4><b>
strstreams: Iostreams for Arrays</font></b><p>

<font size=3>See strstream in the next chapter.</font><p>

<font size=4><b> 
stdiobufs: Iostreams for stdio FILEs</font></b><p>

<font size=3>See stdiobuf in the next chapter.</font><p>

<font size=4><b>  
Streambufs</font></b><p>
<font size=3>
Iostreams are the formatting part of a two-part (input or output) 
system. The other part of the system is made up of streambufs, 
which deal in input or output of unformatted streams of characters.<p>

You usually use streambufs through iostreams, so you don't have to 
worry about the details of streambufs. You can use streambufs 
directly if you choose to, for example, if you need to improve 
efficiency or to get around the error handling or formatting built in to 
iostreams.</font><p>

<font size=4><b>
How Streambufs Work</font></b><p>
<font size=3>
A streambuf consists of a stream or sequence of characters and one 
or two pointers into that sequence. Each pointer points between two 
characters. (Pointers cannot actually point between characters, but it 
is helpful to think of them that way.)<p>

° One is a put pointer, which points just before the position 
of the next character delivered.<p>

° The other is a get pointer, which points just before the 
next character that will be fetched.<p>

A streambuf can have one or both of these pointers.<p>

<b>Position of Pointers</b><br>
The positions of the pointers and the contents of the sequences can 
be manipulated in various ways. Whether or not both pointers move 
when manipulated depends on the kind of streambuf used. 
Generally, with queue-like streambufs, the get and put pointers 
move independently; with file-like streambufs the get and put 
pointers always move together. A strstream is an example of a 
queue-like stream; an fstream is an example of a file-like stream.</font><p>

<font size=4><b>
Using Streambufs</font></b><p>
<font size=3>
You never create an actual streambuf object, but only objects of 
classes derived from class streambuf. Examples are filebuf and 
strstreambuf, which are described in filebuf and ssbuf, in 
the next chapter. You can derive your own classes from 
streambuf, to provide an interface to a special device, or to 
provide other than basic buffering. sbuf. pub and sbuf. prot, in 
the next chapter, discuss how to do this.<p>

Apart from creating your own special kind of streambuf, you might 
want to access the streambuf associated with an iostream to get at 
the public member functions. In addition, each iostream has a 
defined inserter and extractor that take a streambuf pointer. When a 
streambuf is inserted or extracted, the entire stream is copied.<p>

Here is another way to copy a file, with the error checking omitted.<p>
<pre> 
ifstream fromFile("thisFile");
ofstream toFile ("thatFile"); 
toFile &lt;&lt; (streambuf*) fromFile. rdbuf(); 
</pre>

Open the input and output files as before. Every iostream class has a 
member function rdbuf which returns a pointer to the streambuf 
object associated with it. In the case of an fstream, the streambuf 
object is type filebuf. Cast the filebuf* to a streambuf* so 
the appropriate inserter is called, and the entire file associated with 
fromFile is copied (inserted into) the file associated with toFile. 
The last line can also be written like this:<p> 
<pre>
fromFile &gt;&gt; (streambuf*) toFile. rdbuf(); 
</pre>
In this case, the source file is extracted into the destination. The two 
methods are equivalent.</font><p>

<font size=4><b>
Sample Program</font></b><p>
<font size=3>
Here is a sample C++ program. It has a '' toy'' implementation of a 
string class, and a small program to test it. The class is a '' toy'' 
because it is not full-featured, yet it shows a number of features a 
real class must have.</font><p>

<font size=4><b>
Header file</font></b><p>

The header file str.h for the string class string is:<p>
<pre>
/****************** str.h **********************/ 
/* header file str.h for toy C++ strings package 
*/ 
#include &lt;string.h&gt; /* for C string functions */ 
class ostream; /* to declare output of strings 

class string { 
public: 
   string(); 
   string(char *); 
   void append(char *); 
   const char* str() const; 
   string operator+ (const string&amp;) const; 
   const string&amp; operator=(const string&amp;); 
   const string&amp; operator=(const char*); 

private: 
   char *data; 
   size_t size; 
}; 
inline string::string() {size = 0; data = NULL;} 
inline const char* string::str() const { 
   return data;} 
ostream&amp; operator&lt;&lt;(ostream&amp;, const string&amp;); 
istream&amp; operator&gt;&gt;(istream&amp;, string&amp;); 
</pre></font><p>

<font size=4><b>
Implementation file</b><p> 
<font size=3>
The implementation file str.cpp of the string class functions is:<p>
<pre>
/******************* str.cpp *********************/ 
/* implementation for toy C++ string package */ 

#include &lt;iostream.h&gt;
#include "str.h" 

string::string(char *aStr) 
{ 
   if (aStr == NULL) 
      size = 0; 
   else 
      size = strlen(aStr); 

   if (size == 0) 
      data = NULL; 
   else { 
      data = new char [size+ 1]; 
      strcpy(data, aStr); 
   } 
}
void string::append(char *app) 
{ 
   size_t appsize = app ? strlen(app) :0; 
   char *holder = new char [size + appsize + 1]; 

   if (size) 
      strcpy(holder, data); 
   else 
      holder[0] = 0; 

   if (app) { 
      strcpy(&amp; holder[size], app); 
      size += appsize; 
   } 
   delete [] data; 
   data = holder; 
} 
string string::operator+(
      const string&amp; second) const 
{ 
      string temp; 
      temp. data = new char[size + second. size + 1] 

      if (size) 
         strcpy(temp. data, data); 
      else 
         temp. data[0] = 0; 

      if (second. size) 
	strcpy(&amp; temp. data[size], second. data); 
	temp. size = size + second. size; 
	return temp; 
} 
const string&amp; string::operator=(
	const string&amp; second) 
{ 
   if (this == &second) 
      return *this; /* in case string = string */ 

   delete [] data; 
   if (second. size) { 
      data = new char[second. size+ 1]; 
      size = second. size; 
      strcpy(data, second. data); 
   } 
   else { 
      data = NULL; 
      size = 0; 
   } 
   return *this; 
} 
const string&amp; string::operator=(const char* str) 
{ 
   delete [] data; 

   if (str &amp;&amp; str[0]) { 
      size = strlen(str); 
      data = new char[size+ 1]; 
      strcpy(data, str); 
   } 
   else { 
      data = NULL; 
      size = 0; 
   } 
   return *this; 
} 
ostream&amp; operator&lt;&lt; (
      ostream&amp; ostr, const string&amp; output) 
{ 
   return ostr &lt;&lt; output. data; 
} 
istream&amp; operator&gt;&gt; (
      istream&amp; istr, string&amp; input) 
{ 
   const int maxline = 256; 
   char holder[maxline]; 
   istr. get(holder, maxline, '\n'); 
   input = holder; return istr; 
} 
</pre></font><br>
<b><font size=4>
Test file</font></b><p>
<font size=3>
The test file testr.cpp to test the string class is:<p>
<pre>
/******************* testr.cpp********************/ 
/* test code for toy C++ strings package */ 

#include &lt;iostream.h&gt; 
#include "str.h" 

main() 
{ 
   string first ("This is a string."); 
   cout &lt;&lt; "first: " &lt;&lt; first &lt;&lt;"\n"; 

   string sec; 
   sec = first; 
   cout &lt;&lt; "sec = first: " &lt;&lt; sec &lt;&lt; "\n"; 

   sec = "And this is another."; 
   cout &lt;&lt; "another sec: " &lt;&lt; sec &lt;&lt; "\n"; 

   cout &lt;&lt;" Type in a string ....."; 
   cin &gt;&gt; sec; 
   cout &lt;&lt; "sec: "&lt;&lt; sec &lt;&lt; "\n" 

   string third; 
   third = sec+ first; 
   cout &lt;&lt; "sec + first: " &lt;&lt; third &lt;&lt; "\n"; 

   third = sec+ sec; 
   cout &lt;&lt; "sec + sec: " &lt;&lt; third &lt;&lt; "\n"; 

   third. append("plus"); 
   cout &lt;&lt; "with append:" &lt;&lt; third &lt;&lt; "\n"; 

   third = third + sec; 
   cout &lt;&lt; "added to itself:" &lt;&lt; third &lt;&lt; "\n"; 

   return 0; 
} 
</pre></font><br>
<font size=4><b>
Compile and link the program</font></b><p>
<font size=3>
To compile and link the entire program use the command: 
<p>
<pre>
sc -cpp -o testr testr.cpp str.cpp 
</pre>

<p>




<HTML>
<HEAD>
	<TITLE>Runtime Library Reference</TITLE>
</HEAD>
<BODY>
<font size=7><b><i>
27 Iostream Library Class Descriptions
</font></b></i>
<hr>

<font size=4><b>
T
</font></b>
<font size=3>
his chapter contains descriptions for:<p>

° Iostream classes<p>

° Iostream functions<p>

For an overview of Iostreams, see Chapter 26.<p>

Note <br>
This version of Digital Mars C++ implements a 
different iostream class library than previous 
versions of Digital Mars C++ or Zortech C++. If your 
code uses iostream classes from previous releases, 
you must convert to the classes described here; the 
old classes are not supported.<p>
</font>
<font size=4><b>
Manipulators</font></b><p>
<font size=3>
A manipulator provides a convenient way to work with extractors and inserters. It embeds what is really a function call into a sequence of insertions or extractions. A manipulator appears to be an object inserted or extracted into a stream, but usually it only changes the state of the stream.<p>

For example, instead of writing:<p>
<dl>
<dt>cout. width(8); 
<dd>cout &lt;&lt; val1 &lt;&lt; " "; 
<dd>cout. width(4); 
<dd>cout &lt;&lt; val2 &lt;&lt; '\n'; 
<dd>cout. flush(); <p>
</dl>

you can write:<p>
<pre>
cout &lt;&lt; setw(8) &lt;&lt; val1 &lt;&lt; " " &lt;&lt; setw(4) \
   &lt;&lt; val2 &lt;&lt; endl; 
</pre>

Classes ios, istream, and ostream all implement predefined 
manipulators. These are simple, taking no arguments such as endl, 
above, does. A manipulator can also take arguments, such as setw 
does. Header file <iomanip.h> defines some of these manipulators 
and provides the definitions for creating your own manipulators.<p>

Manipulators are logically defined as templates but were introduced 
before templates were available in the C++ language. They are 
accordingly defined as macros simulating templates. The macro 
IOMANIPdeclare(typ) expands to a complete set of definitions 
for a manipulator taking one parameter of type typ. Due to the 
nature of the macros, the type parameter must be a simple type 
name (just an identifier). The header provides the expanded 
definitions for types int and long.</font><p>

<font size=4><b>
Simple Manipulators</font></b><p>
A manipulator without arguments is a function with one parameter of type reference to stream, and which returns the same type. The streams have predefined overloaded operators that take such a 
function as a parameter. The manipulator performs whatever operations are necessary on the stream argument, then returns the same stream. For example, this code implements a tab manipulator:<p>
<pre>
ostream&amp; tab(ostream&amp; s) 
{ 
   s &lt;&lt; '\t'; 
   return s; 
} 
</pre>
In the expression cout&lt;&lt; tab, the overloaded operator ostream&amp; operator&lt;&lt; (ostream&amp; (*)(ostream&amp;)) is selected; it calls the manipulator function. The resulting call inserts 
a tab character into the ostream.<p></font>

<font size=4>
<b>Parameterized Manipulators</b><br>
</font>

<font size=3>
A manipulator with a parameter has two parts:<p> 

°A manip part, a function taking a stream and a typ 
argument and returning the stream;<p>

°An apply part, the function invoked by the manip part, 
which applies state changes or other operations.<p>

For a given type typ, all arts are declared by the IOMANIPdeclare 
macro. These are described below.<p>

The following declarations are used in the discussion below:<p>

<b>Variable/Declaration</b><br><dl>
<dt>typ
<dd>Some type name 
<dt>n 
<dd>An int 
<dt>l 
<dd>A long 
<dt>s 
<dd>An ios 
<dt>i 
<dd>An istream 
<dt>o 
<dd>An ostream 
<dt>io 
<dd>An iostream 
<dt>f 
<dd>An ios&amp; (*) (ios&amp;) 
<dt>if 
<dd>An istream&amp; (*) (istream&amp;) 
<dt>of 
<dd>An ostream&amp; (*) (ostream&amp;) 
<dt>iof 
<dd>An iostream&amp; (*) (iostream&amp;) 
<dt>s &lt;&lt; SMANIP(typ)(f, t) 
<dt>s &lt;&lt; SAPP(typ)(f)(t) 
<dt>s &gt;&gt; SMANIP(typ)(f, t) 
<dt>s &gt;&gt; SAPP(typ)(f)(t) 
<dd>Returns f(s, t). The stream s can also be 
<dd>any of the other stream types i, o, or 
<dd>io. 
<dt>i &gt;&gt; IMANIP(typ)(if, t) 
<dt>i &gt;&gt; IAPP(typ)(if)(t) 
<dd>Returns if(i, t).
<dt>o &lt;&lt; OMANIP(typ)(of, t) 
<dt>o &lt;&lt; OAPP(typ)(of)(t) 
<dd>Returns of(o, t). 
<dt>io &lt;&lt; IOMANIP(typ)(iof, t) 
<dt>io &lt;&lt; IOAPP(typ)(iof)(t) 
<dt>io &gt;&gt; IOMANIP(typ)(iof, t) 
<dt>io &gt;&gt; IOAPP(typ)(iof)(t) 
<dd>Returns iof(io, t). 
<p>
</dl>

The <iomanip.h> header contains declarations for manipulators 
taking an int or a long argument (typ in the above presentation). 
Predefined manipulators are used for changing the state of a stream:<p>

<b>Manipulator/Description</b><br><dl>
<dt>o &lt;&lt; setw(n) 
<dt>i &gt;&gt; setw(n) 
<dd>Sets the field width of stream i or o to n. 
The next formatted insertion or extraction 
resets the width to 0. 
<dt>o &lt;&lt; setfill(n) 
<dt>i &gt;&gt; setfill(n) 
<dd>Sets the fill character of stream i or o to n. 
<dt>o &lt;&lt; setprecision(n) 
<dt>i &gt;&gt; setprecision(n) 
<dd>Sets the precision variable of stream i or o 
to n. o &lt;&lt; setiosflags(l) 
<dt>i &gt;&gt; setiosflags(l) 
<dd>Turns on the ios flags of stream i or o that 
are set in l. 
<dt>o &lt;&lt; resetiosflags(l) 
<dt>i &gt;&gt; resetiosflags(l) 
<dd>Turns off the ios flags of stream i or o that 
are set in l.
</dl><p>

To write a parameterized manipulator:<p>
1. Declare function manip, and then implement functions 
manip and apply.<br>
2. If the manipulator will take an argument of type typ, 
declare function manip to take one argument of that 
type, and to return an object of type Xmanip_typ.<br>
3. Replace X with either s, i, o, or io, if the intention is to 
manipulate objects of type ios, istream, ostream, 
or iostream, respectively.<br>
4. Replace typ with the actual type name. For types int 
and long, all declarations are in place. For other types, 
invoke the "template" IOMANIPdeclare(typ).<p>

Function apply is usually static, called by only the manip function. 
Define it to return a reference to the type of stream to be 
manipulated, to have a first parameter of that same type, and a 
second of type typ.<p>

For example, consider the setiosflags manipulator. The 
manipulator operates on an ios, and takes a long parameter, so it is 
declared to return type smanip_long. If it operated on an 
ostream and took an int parameter, it would be declared to 
return type omanip_int. The manipulator (the manip function) is 
therefore declared in the header like this:<p>
<pre>
	smanip_long setiosflags(long); 
</pre>
The apply function does not appear in the header; it is never called 
directly by user code. Code for both functions appears in the 
implementation module:<p>
<pre>
// set the flags bitvector according to the bits
// set in b static ios&amp; sios(ios&amp; i, long b) 
// private apply function 
{
   i. setf(b); 
   return i; 
} 
smanip_long setiosflags(long b) 
// public manip function { 
   return smanip_long(sios, b); 
} 
</pre>


<hr><!-- =========================================== -->

<a name="filebuf"><h2>Class filebuf</h2></a>

The filebuf class is a specialization of streambufs using a file 
as the source or destination of characters. Characters are fetched 
(input) from a file and consumed by (written to) a file.<p>

A filebuf object has a file attached to it. When filebuf is 
connected (attached) to an open file, filebuf is said to be open; 
otherwise it is closed. A file is opened by default with protection 
mode filebuf::openprot, which is 0644.<p>

If seek operations can be performed on the attached file, class 
filebuf supports seeks. For example, an ordinary disk file is 
seekable, the terminal is not. If the attached file allows reading and/ 
or writing, the filebuf allows fetching and/ or storing. For 
example, standard input allows only reading, standard output allows 
only writing. Unlike C stdio calls, no seek is required between 
gets and puts to the same filebuf. At least four characters of 
putback are initially allowed.<p>

Class streambuf provides basic streambuf operations. The reserve 
area is allocated automatically if one is not supplied to a constructor 
or with a call to filebuf::setbuf (calls to setbuf are usually 
honored). If the filebuf is unbuffered, each input and output 
character requires a system call. Pointers get and put act like a 
single pointer; conceptually, they are tied together.<p>

A filebuf operates on files by way of a Unix-style file descriptor, a 
small integer passed in system calls. C stdio calls are not used.<p>

Note<br> 
Supplied file descriptors are not checked for 
validity. The filebuf does not report seek failures.<p>
</font>
<font size=4><b>
Member Functions of filebuf</b></font><p>
<font size=3>
Class filebuf is derived from streambuf, so you can use all the 
streambuf member functions on objects of class filebuf.<p>

The following functions are members of class filebuf.<p>
</font>
<font size=4><b>
filebuf constructors 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
filebuf();<br>
filebuf(int f);<br>
filebuf(int f, char *ptr, int len); 
<p>

<b>
Description
</b><p>
The default constructor filebuf() creates a closed filebuf.<p>

filebuf(f) creates an open filebuf attached to file descriptor f, 
which is assumed to be open.<p>

filebuf (f, ptr, len) creates an open filebuf attached to file 
descriptor f, which is assumed to be open. This constructor uses the 
array of len chars beginning at ptr as the initial reserve area. If 
ptr is zero or len is not greater than zero, the filebuf is unbuffered. 
<p><br>

<font size=4><b>
filebuf::attach 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
filebuf * filebuf::attach(int f); 
<p>

<b>
Description
</b><p>
If filebuf is closed, this function connects it to file descriptor f, 
which is assumed to be open, and returns the address of filebuf. 
If filebuf is already open, it ignores f and returns zero. 
<p><br>

<font size=4><b>
filebuf::close 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
filebuf * filebuf::close(); 
<p>

<b>
Description
</b><p>
This function flushes any pending output, unconditionally closes the 
file descriptor, and closes filebuf. It returns the address of 
filebuf, or zero if an error occurs. 
<p><br>

<font size=4><b>
filebuf::fd 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
int filebuf::fd(); 
<p>

<b>
Description
</b><p>
This function returns the file descriptor attached to filebuf, or 
EOF if filebuf is not open. 
<p><br>

<font size=4><b>
filebuf::is_open 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
int filebuf::is_open(); 
<p>

<b>
Description
</b><p>
This function returns non-zero if filebuf is open (connected to a 
file descriptor), and zero otherwise. 
<p><br>

<font size=4><b>
filebuf::open 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
filebuf * filebuf::open(const char *name, int mode, int prot= filebuf::openprot); 
<p>

<b>
Description
</b><p>
If filebuf is not already open, this function opens file name and 
connects its file descriptor to filebuf; otherwise an error occurs. 
This function returns the address of filebuf on success, or zero on 
any failure.<p>

If the file does not exist, and ios::nocreate is not set in mode, 
open attempts to create the file with the protection bits specified in 
prot (with default value 0644). Parameter mode is a collection of 
bits from ios::open_mode, described in fstream::open, which 
can be or'd together. 
<p><br>

<font size=4><b>
filebuf::seekoff 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
streampos filebuf::seekoff(streamoff off, ios::seek_dir dir, int mode); 
<p>

<b>
Description
</b><p>
This function moves the combined get/ put pointer, described in 
"Class streambuf (Public Interface)", except parameter mode is 
ignored. It returns the new file position on success, or EOF if a 
failure occurs.<p>

If filebuf is not open, if the attached file does not support 
seeking, or if the seek cannot otherwise be performed (such as off 
either end of the file), the operation fails. The position of the file in the event of an error is undefined. 
<p><br>

<font size=4><b>
filebuf::seekpos 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
streampos filebuf::seekpos(streampos pos, int mode=(ios::in | ios::out)); 
<p>

<b>
Description
</b><p>
This function is equivalent to the call 
filebuf. seekoff((streamoff) pos, ios::beg, mode). 
The value of pos is obtained from a previous call to seekoff or 
seekpos, or the value zero representing the beginning of the file. It 
returns the new file position on success, or EOF if a failure occurs. 
<p><br>

<font size=4><b>
filebuf::setbuf 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
streambuf * filebuf::setbuf(char *ptr, int len); 
<p>

<b>
Description
</b><p>
If filebuf is open and a reserve area has been allocated, no 
change is made and setbuf returns zero. Otherwise, the new 
reserve area becomes the len chars beginning at the location 
pointed to by ptr, and the function returns the address of 
filebuf. The function returns the address of the filebuf object, or 
zero if filebuf is already open and has a reserve area allocated for it.<p>

If ptr is zero or len is not greater than zero, there will be no 
reserve area and filebuf is unbuffered.
<p><br>

<font size=4><b>
filebuf::sync 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
int filebuf::sync(); 
<p>

<b>
Description
</b><p>
This function attempts to synchronize the get/ put pointer with the 
actual position of the attached file. This might involve flushing 
unwritten characters or backing up the file over characters already 
input. It returns zero if successful, otherwise EOF.<p>

To ensure that a group of characters is written to a file at the same 
time, allocate a reserve area larger than the largest such group, call 
sync() just before storing the characters, and then call sync() 
again just after.
<p><br>


<hr><!-- =========================================== -->

<a name="Xstream"><h2>Classes fstream, ifstream, and ofstream</h2></a>

Classes fstream, ifstream, and ofstream do the following:<p>

<ul>
	<li> fstream implements input and output streams for files
 	<li> ifstream implements input streams for files
	<li> ofstream implements output streams for files
</ul>

Each class uses a filebuf object as a buffer to coordinate 
operations between the stream and the file.<p>

Auxiliary class fstreambase is an implementation detail, primarily 
providing a set of common functions. It is not documented.<p>
</font>
<font size=4><b>
Member Functions of fstream, ifstream ofstream</b></font><p>
<font size=3>
Class fstream is derived from iostream, which in turn is derived 
from ios. You can use ios and iostreams member functions on 
fstream objects.<p>

Class ifstream is derived from istream, which in turn is derived 
from ios. You can use ios and istreams member functions on 
ifstream objects.<br><br

Class ofstream is derived from ostream, which in turn is derived 
from ios. You can use ios and ostreams member functions on 
ofstream objects.<p>

The following functions are members of fstream, ifstream, and 
ofstream class. The notation <b>Xstream</b> is used to collectively 
describe the member functions.<p>

<font size=4><b>
Xstream constructors 
</font></b><p>

<font size=3><b>

Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p><pre>
Xstream(); 
Xstream(int f); 
Xstream(const char *name, int mode= ios::in, 
   int prot= filebuf::openprot); 
Xstream(int f, char *ptr, int len); 
</pre>

<b>
Description
</b><p>
The default constructor Xstream() constructs a closed xstream, not 
connected to any file.<p> 

Xstream(f) constructs an Xstream attached to file descriptor f, 
which must already be open; It does not test for this condition. The 
file will not be closed automatically when the stream is destroyed.<p>

Xstream(name, mode, prot) constructs an Xstream and opens 
file name using mode for the Xstream::open mode bits and prot 
for the file protection bits. The default open mode is input for an 
ifstream and output for an ofstream. The default protection is 
filebuf::openprot, which is 0644. Errors will be stored in the 
Xstream error state; see "Error States" in the description of class ios.  The file closes automatically when the stream is destroyed.<p>

Xstream(f, ptr, len) constructs an Xstream attached to file 
descriptor f, which must already be open; it does not test for this 
condition. The filebuf uses len chars beginning at the location 
pointed to by ptr as the buffer (reserve area). If ptr is zero or len 
is not greater than zero, there will be no reserve area and filebuf will be unbuffered. The file will not be closed automatically when the 
stream is destroyed.  
<p><br>

<font size=4><b>
Xstream::attach 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
Xstream::attach(int f); 
<p>

<b>
Description
</b><p>
This function connects Xstream to an open file descriptor f. If 
Xstream is already connected to a file, it ignores the request, and 
sets ios::failbit in the Xstream error state. The attached file 
will not be closed automatically when the stream is destroyed. 
<p><br>

<font size=4><b>
Xstream::close 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
Xstream::close(); 
<p>

<b>
Description
</b><p>
This function closes the associated filebuf and disconnects the file 
from Xstream. If the filebuf's close call succeeds, it clears the 
error state; otherwise it sets ios::failbit in the Xstream error 
state. 
<p><br>

<font size=4><b>
Xstream::open 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
Xstream::open(const car *name, int mode= ios::in, int prot= filebuf::openprot); 
<p>

<b>
Description
</b><p>
This function opens file name and connects its file descriptor to 
Xstream. If the file does not exist, and ios::nocreate is not set 
in mode, open attempts to create the file with the protection bits 
specified in prot (with default value 0644). Parameter mode is a 
collection of bits from ios::open_mode that can be or'd together. 
The opened file closes automatically when the stream is destroyed. 
The following creation modes are supported:<p>
<dl>
<b>Mode/Description</b><br>
<dt>ios::app 
<dd>Initially seeks to the end of the file. Any 
subsequent write operation always appends to 
the end of the file. This flag implies ios::out. 
<dt>ios::ate 
<dd>Initially seeks to the end of the file. This flag does 
not imply ios::out, but only begins operations at 
end of file. 
<dt>ios::in 
<dd>Opens the file for input. Construction or opening 
of an ifstream always implies this bit; the bit need 
not be set. When set for an fstream, it means that 
input is allowed if possible. When set for an 
ofstream, it means that the file is not truncated 
when it is opened. 
<dt>ios::nocreate 
<dd>If the file does not already exist, do not create it; 
open will fail in this case. This bit makes sense 
only when opening for output. 
<dt>ios::noreplace 
<dd>The file must not already exist; otherwise open 
fails. This bit makes sense only when opening for 
output. 
<dt>ios::out 
<dd>Open the file for output. Construction or opening 
of an ofstream always implies this bit, meaning 
the bit need not be set. When set for an fstream, 
it means that output is allowed if possible. This 
bit can be set for an ifstream, but output to the 
file is not permitted. 
<dt>ios::trunc 
<dd>If the file exists, truncate to zero length upon 
opening it. When ios::out is specified or implied 
and neither ios::ate nor ios::app is specified, this 
bit is implied. This bit makes sense only when 
opening for output. 
<p><br>
</dl>

<font size=4><b>
Xstream::rdbuf 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
filebuf * Xstream::rdbuf(); 
<p>

<b>
Description
</b><p>
This function returns a pointer to the filebuf associated with 
Xstream. It works like its counterparts in the base classes, except 
that its return type is specifically a filebuf. 
<p><br>

<font size=4><b>
Xstream::setbuf 
</font></b><p>

<font size=3><b>
Header
</b><p>
fstream.h
<p>

<b>
Prototype
</b><p>
Xstream::setbuf(char *ptr, int len); 
<p>

<b>
Description
</b><p>
This function sets up a buffer of len chars at ptr as the reserve 
area. It calls filebuf::setbuf, and uses its return value to adjust 
the error state of Xstream. That is, it clears the error state on 
success, and sets ios::failbit on error.</font>
<p><br>

<hr><!-- =========================================== -->

<a name="ifstream"><h2>Class ifstream</h2></a>

Class ifstream, a specialization of class istream, implements 
input streams for files. It uses a filebuf object as a buffer to 
coordinate operations between the stream and the file.<p>

The section "Classes fstream, ifstream, and ofstream" discusses 
fstream, ifstream, and ofstream together, using the notation<b>
Xstream</b></font>.<p> 


<hr><!-- =========================================== -->

<a name="ios"><h2>Class ios</h2></a>

Class ios is a virtual base class of all stream objects. It describes 
common aspects of input and output streams, such as tracking 
errors, controlling representation and interpretation of numbers, and 
monitoring buffers. ios also provides the basic state and formatting 
data for a stream.<p>

Class ios defines several enumerations and collection of functions. 
Although you never create an object of class ios, you can use many 
of its member functions to check the state of a stream and to control 
formatting.</font><p>
<font size=4><b>
Class ios Enumerations</b><p>
<font size=3>
Class ios defines the enumerations described below.<p> 

<b>io_state</b><p>
Member functions use these enumerations to keep track of the error 
state of the stream. See "Error States" for information on how to test 
these bits. io_state is really a collection of bits, as follows<p> 
<dl>
<dt>badbit 
<dd>This bit indicates that some operation on the associated 
streambuf has failed. Typically, further operations will 
not succeed, even after clearing the bit. Example 
situations would be an output error, or immediate end 
of file on an attempted input operation.

<dt>eofbit 
<dd>This bit is normally set when end of file has been 
reached during an extraction. It is not set as the result 
of a succesful extraction reaching end of file, but when 
end of file is reached while attempting further 
extractions. '' End of file'' in this sense is an abstraction 
as defined by the streambuf associated with the stream. 
Normally this bit is not set for output streams. 

<dt>failbit 
<dd>This bit is set when an attempted extraction or 
conversion has failed, usually due to unexpected 
characters. Further attempted extractions will fail until 
this bit is cleared, to prevent running on after improper 
input. Usually the stream is still usable, and extraction 
can be continued after clearing the bit and dealing with 
the unexpected input.

<dt>goodbit 
<dd>This '' bit'' is really the absence of any error bits, and 
indicates that the stream is in a good state. 

<dt>hardfail 
<dd>This bit is reserved by the implementation to indicate 
that the stream cannot be further used. Typically it 
represents a hardware failure of some kind. The bit 
cannot be cleared by any publicly accessible function. 
</dl><p>

<b>open_mode</b><br>
These enumerations are described with function fstream::open.<p>

<b>seek_dir</b><br>
These enumerations are described in the section "Class streambuf 
(Public Interface)", under the function streambuf::seekoff.<p>

<b>Formatting Flags</b><br>
Member functions use these enumerations of anonymous type to 
control input and output formatting. See "Format Control".</font><p>
<font size=4>
<b>Constructors and Assignment</b></font><p>
<font size=3>
Class ios defines the following constructors, which are described in 
the "Member Functions of ios" section.<p>
<pre>
ios(sbptr) 
ios() 		// protected 
init(sbptr) 	// protected 
ios(iosref) 	// private 
</pre>
<p>
<b>Error States</b><br>
Functions that enable testing and adjusting the error state bits, are:<p>

<b>Function/Description</b><br>
<dl>
<dt>bad() 
<dd>Checks whether the stream can be used. 
<dt>clear(flags) 
<dd>Clears the error state. 
<dt>eof() 
<dd>Checks whether the eofbit is set. 
<dt>fail() 
<dd>Checks whether the operation failed. 
<dt>good() 
<dd>Checks whether any error state bits are set. 
<dt>rdstate() 
<dd>Returns the error state bits of a stream. 
</dl></font><p>
<font size=4>
<b>Other Status Testing</b></font>
<font size=3>
It is often convenient to be able to test the state of a stream directly. Since typical insertion and extraction operators return a reference to the stream, you can test the return values of the operations. Two operators are defined to permit this testing: void* and !.<p> 

<b>The operator void* ()</b><br>
You can use an explict cast of a stream to void*, or use a stream in a 
boolean context to test its state. The result is 0 if any of failbit, 
badbit, or hardfail is set. The result is a non-zero pointer if the 
stream is in a good or eof state. For example:<p>
<pre>
if(cout ) ... // next output should succeed
if(cin &gt;&gt; x ) ... // input to x succeeded 
</pre>

<b>The operator ! ()</b><br>
This operator provides the inverse of the above testing. The result is 
non-zero if any of failbit, badbit, or hardfail is set, and zero 
otherwise. For example:<p> 
<pre>
if(! cout ) ... // output will not succeed
if(! (cin &gt;&gt; x) ) ... // input to x failed 
</pre></font>
<p>
<font size=4>
<b>Format Control</b><p>
</font>
<font size=3>
A ios object maintains a format state that is controlled by formatting flags, in combination with the three functions fill, width, and 
precision. The formatting flags are a collection of bits described 
below, declared as enumerations of an anonymous type. These format bits are kept in a long int and can be manipulated independently via two versions of the flags function.<p>

Formatting flags can be set and cleared independent of other 
operations. They change only by explicit programmer action.<p>

<b>Formatting Flags</b><br>
ios defines the following format flags:<p>

<b>Flag/Description</b><br>
<dl>
<dt>skipws
<dd>If this flag is set, formatted extractors will skip leading 
whitespace; otherwise, leading whitespace is not skipped. This flag is set by default, allowing free-format input text. Unformatted extractors do not examine this flag.
<dt>left 
<dt>right 
<dt>internal 
<dd>These flags control how padding is inserted during 
formatted operations. At most one of these three flags 
can be set at one time. The three flags can be 
addressed as a unit by the static member 
ios::adjustfield. If left is set, the value is left-adjusted in 
its field width, meaning that padding is added on the 
right. If right is set, the value is right-adjusted in its 
field width, meaning that padding is added on the left. 
If internal is set, padding is added after any leading 
base or sign field, and before the value. The default 
(none of the flags set) is right. The fill character used 
for padding defaults to the space character, and can be 
set with the fill function. The amount of padding is 
determined by the field width as set by the width 
function. See the section "Manipulators" for more 
information. 
<dt>dec 
<dt>oct 
<dt>hex 
<dd>These flags control the conversion base of integer 
data. At most one of these three flags can be set at one 
time. The three flags can be addressed as a unit by the 
static member ios::basefield. Conversions are done in 
decimal (base 10) if dec is set, in octal (base 8) if oct is 
set, or in hexadecimal (base 16) if hex is set. If no flag 
is set, insertions are done in decimal, and extractions 
are converted according to the C++ rules for 
representing integer constants. That is, a leading '' 0x'' 
or '' 0X'' results in hex conversion, a leading '0' results 
in octal conversion, and a leading '1' through '9' 
results in decimal conversion for extraction. The 
default is none of these bits set. Manipulators dec, oct, 
and hex can also be used to set the conversion base as 
described in the section "ios Predefined Manipulators". 
<dt>showbase 
<dd>If this flag is set, insertions of converted integral values 
will be in the form used for representing C++ integer 
constants. That is, octal values will begin with a 
leading '0', and hexadecimal values will begin with a 
leading '' 0x'' or '' 0X'' (see '' uppercase'' below). The 
default is unset. 
<dt>showpos
<dd>If this flag is set, a plus sign ('+ ') will be added to 
insertions of converted positive decimal values 
(including floating point numbers). The default is 
unset. 
<dt>uppercase 
<dd>If this flag is set, an uppercase 'X' will be used in 
insertions of converted hexadecimal values when 
showbase is set, and an uppercase 'E' will be used for 
floating point conversions. Otherwise, lowercase 'x' 
and 'e' will be used, respectively. The default is unset. 
<dt>fixed 
<dt>scientific
<dd>These flags control the type of conversion used when 
floating point values are converted for insertion. The 
two flags can be addressed as a unit by the static 
member ios::floatfield. The rules for conversion are 
generally the same as for the C stdio function printf. If 
scientific is set, 'e' format is used. If fixed is set, 'f' 
format is used. If neither is set, 'g' format is used (see 
also uppercase above). The value set by width, if any, 
is used as the printf field width specification. The 
value set by precision, if any, is used as the printf 
precision specification. 
<dt>showpoint 
<dd>If this flag is set, trailing zeros, or a trailing decimal 
point, will appear in the conversion of floating point 
values. The default is to truncate trailing zeros or a 
trailing decimal point. 
<dt>unitbuf 
<dd>If an output stream is buffered, the buffer is flushed 
when it fills, or when it is explicitly flushed. This can 
result in delayed output, or lost output if the program 
crashes. A stream can be unbuffered, eliminating 
delays and lost output, but at the cost of a system call 
per character output. If the unitbuf flag is set, the 
buffer will be flushed after each complete insertion. 
Unit buffering is thus a compromise, providing 
frequent output at lower cost than unbuffered output, 
and not requiring extra flush() calls in the program 
source. In particular, unit buffering can be turned on 
and off at selected places in the code without 
changing any other source code. By default, this flag is 
not set. 
<dt>stdio 
<dd>This flag causes the C stdio files stdout and stderr to 
be flushed after each insertion in the stream. This can 
be useful when C stdio operations on the standard 
files is mixed with iostreams on other files. By default, 
this flag is not set. 
</dl><p>

<b>Format Bit Masks</b><br>
ios predefinesdefines the following bit mask as type long with the 
following OR'd definitions. Use them to set and clear specific groups 
of bits, helping to avoid conflicting specifications:<p>
<dl>
<b>Bit mask/Definition</b> 
<dt>adjustfield 
<dd>left| right| internal 
<dt>basefield 
<dd>dec| oct| hex 
<dt>floatfield 
<dd>fixed| scientific 
</dl><p>

<b>Format Control Functions</b><br>
ios defines the following member functions for format control:<p>
<dl>
<b>Function/Description</b>
<dt>fill(char) 
<dd>Gets or sets the fill character 
<dt>flags(long) 
<dd>Gets formatting flags 
<dt>precision(int) 
<dd>Gets or sets the precision setting 
<dt>setf(long, long) 
<dd>Sets formatting flags 
<dt>unsetf(long) 
<dd>Clears any flag bits that are set 
<dt>width(int) 
<dd>Gets or sets the field width 
</dl>
</font><p>
<font size=4>
<b>User-defined Format Flags and Variables</b></font><p>
<font size=3>
User-defined format flags and variables are provided for derived 
classes that might need their own. Once allocated for a class, the 
flags and variables are reserved for the duration of the program; 
several independent classes can allocate their own flags and 
variables without conflict. The following functions return values you 
can use as flags:<p>
<dl>
<b>Function/Description</b><br>
<dt>bitalloc
<dd>Allocates a flag bit 
<dt>iword 
<dt>ipword 
<dd>Gets a reference to a user-defined status variable. 
<dt>xalloc 
<dd>Returns an index to be used with iword or ipword. 
</dl><p>
</font>
<font size=4>
<b>ios Predefined Manipulators</b></font><p>
<font size=3>
A manipulator can appear to be an inserted or extracted object, but 
really only changes the state of the stream. The following manipulators are predefined for use with streams. Additional manipulators are available when you include manip.h file. See the section "Manipulators" for more information.<p> 
<dl>
<b>Manipulator/Description</b><br>
<dt>s &gt;&gt; dec 
<dt>s &lt;&lt; dec 
<dd>Set the conversion base of stream s to 10.
<dt>s &gt;&gt; oct 
<dt>s &lt;&lt; oct 
<dd>Set the conversion base of stream s to 8.
<dt>s &gt;&gt; hex 
<dt>s &lt;&lt; hex 
<dd>Set the conversion base of stream s to 16.
<dt>s &gt;&gt; ws 
<dd>Extracts and discards whitespace from stream s. See 
the overloaded operator &gt;&gt; in class istream. 
<dt>s &lt;&lt; endl 
<dd>Inserts a newline into stream s and flushes the stream. See overloaded operator &lt;&lt; in class ostream. 
<dt>s &lt;&lt; ends 
<dd>Inserts a null character ('\0') into stream s to end the 
string. See class strstream. 
<dt>s &lt;&lt; flush 
<dd>Flushes the stream s. See class ostream. 
</dl></font>
<p>
<font size=4>
<b>Member Functions of ios</b></font><br>
<font size=3>
Class ios is a virtual base class for ostream, istream, and 
iostream, so you can use any ios member functions on objects of 
any of these types, and on types derived from them.<p>

The following functions are members of class ios.<p> 

<font size=4><b>
ios constructors 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p><pre>
ios(streambuf* sbptr);

ios(); 					// protected 
void init(streambuf* sbptr); 		// protected 

ios(iosref); 				// private 
void operator=(ios&amp;); 			// private; 
</pre>
<p>

<b>
Description
</b><p>
Historically, a virtual base class requires a default constructor (one 
with no arguments), because arguments could not be passed to a 
constructor for a virtual base class. Class ios therefore has a default 
constructor ios() and a separate intialization function 
init(sbptr) whose argument is a pointer to a streambuf.<p>

A derived class uses protected constructor ios() by default, and 
calls initialization function init(sbptr). The argument to 
init(sbptr) points to the streambuf to be associated with the ios 
object being constructed, and must not be null. For example:<p>
<pre>
class istream : virtual public ios { ... }; 
istream::istream(streambuf* s) 
{ 
   ios::init(s); 
   // ... 
} 
</pre>
For the constructor of the form ios(sbptr), the streambuf pointed 
to by sbptr becomes the streambuf associated with the ios being 
constructed. The pointer must not be null.<p>

The copy constructor ios(iosref) and assignment operator 
stream2= stream1 are private to prevent copying of ios objects, since 
the effect of such copying is not well defined. Usually, you want to 
copy a pointer to the object, or pass a reference to a function. 
<p><br>

<font size=4><b>
ios:bad
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int ios::bad(); 
<p>

<b>
Description
</b><p>
Checks if badbit or hardfail is set. Returns non-zero if either is set, 
otherwise returns zero. 
<p><br>
<font size=4><b>
ios:bitalloc
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
long ios::bitalloc(); 
<p>

<b>
Description
</b><p>
This static member function returns a long with one previously 
unallocated flag bit set. This value can then be used as a flag for 
class-specific purposes (in calls to setf, for example). At least 16 
bits are available for allocation. When no bits are available, this 
function returns zero. 
<p><br>

<font size=4><b>
ios:clear
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
ios::clear(int flags= 0); 
<p>

<b>
Description
</b><p>
This function stores its int parameter as the error state of the 
stream. The value of flags is derived only from the return of 
rdstate and/ or combinations of the io_state bits. To clear only 
one bit in the stream state, use something like:<p>

ios::clear(~ ios::failbit &amp; ios::rdstate()); 
<p><br>

<font size=4><b>
ios:eof
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int ios::eof(); 
<p>

<b>
Description
</b><p>
This function returns non-zero if the eofbit is set, and zero 
otherwise. 
<p><br>

<font size=4><b>
ios:fail
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int ios::fail(); 
<p>

<b>
Description
</b><p>
This function returns non-zero if any of failbit, badbit, or hardfail is set, and zero otherwise. 
<p><br>

<font size=4><b>
ios:fill
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
char ios::fill();<br>
char ios::fill(char newfill); 
<p>

<b>
Description
</b><p>
fill() returns the current fill character of the stream. The fill 
character pads an insertion to the designated field width. See the 
discussion of the flags left, right, and internal in "Format Control".<p>

fill(newfill) returns the old fill character. The default fill 
character is the space. See the description of the predefined 
manipulator setfill in the section "Manipulators".<p><br>

<font size=4><b>
ios:flags
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
long ios::flags();<br>
long ios::flags(long newflags); 
<p>

<b>
Description
</b><p>
flags() returns the current formatting flags of the stream in a long.<p>

flags(newflags) uses the long value of newflags to replace all 
the formatting flags in the stream. It returns the previous formatting 
flags in a long. 
<p><br>

<font size=4><b>
ios::good
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int ios::good(); 
<p>

<b>
Description
</b><p>
This function returns non-zero if the error state is good; that is, if no bits are set.  Otherwise, it returns zero.  In particular, it returns zero if eofbit is set.
<p><br>

<font size=4><b>
ios:iword, ios:pword
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
long ios::iword(int i);<br>
void * ios::pword(int i); 
<p>

<b>
Description
</b><p>
When i is an index value returned by a call to ios::xalloc, these 
functions return a reference to the ith user-defined status variable 
(word) for class ios. Function iword returns the reference typed as a 
long; function ipword returns the reference typed as a void*.<p>

Note <br>
Do not depend on the returned reference being 
stable for an indefinite period. In particular, any call 
to ios::xalloc() can invalidate a previous reference. 
<p><br>

<font size=4><b>
ios::precision 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int ios::precision();<br>
int ios::precision(int newprec); 
<p>

<b>
Description
</b><p>
precision() returns the current '' precision'' format state of stream 
ios. It controls the number of significant digits converted in floating 
point insertions. See the section "Format Control" .<p>

precision(newprec) sets the '' precision'' format state of stream s 
to newprec, and returns the old value. The default value is 6. See the 
description of the predefined manipulator setprecision in the 
section "Manipulators" for more information. 
<p><br>

<font size=4><b>
ios::rdbuf
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
streambuf *ios::rdbuf(); 
<p>

<b>
Description
</b><p>
This function returns a pointer to the streambuf associated with the 
stream. This is part of the construction of a stream, and the buffer 
class object is not normally changed. This function can be used to 
get at streambuf functions directly, given a stream object. 
<p><br>

<font size=4><b>
ios:rdstate
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int ios::rdstate(); 
<p>

<b>
Description
</b><p>
This function returns the error state bits of stream ios as an int. 
<p><br>

<font size=4><b>
ios:setf
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
long ios::setf(long newflags);<br>
long ios::setf(long newflags, long field); 
<p>

<b>
Description
</b><p>
For setf(newflags), each bit that is set in the long value newflags 
is set in the formatting flags of stream ios. The remaining formatting 
flags are unaffected. It returns the previous formatting flags in a long. Note that the ios::flags function replaces all the flag bits, while the ios::setf function sets just those bits that are specified.<p>

setf(newflags) is most useful for setting a flag that is not part of a 
group. setf(newflags, field) is useful for setting one of a 
group of flags.<p>

For setf(newflags, field), bits that are set in the long value 
field mark the formatting flags that are replaced by the 
corresponding bits in the long value newflags. It returns the previous 
value of the designated flags. Typically, the field value is one of the 
bit masks basefield, adjustfield, or floatfield (see "Format Bit Masks").<p>

<b>
Example
</b><p>
This example sets left-justification, outputs a value, and restores the 
previous justification: 
<pre>
	long oldadjust = cout. setf(ios::left, \
	   ios::adjustfield); 
	cout &lt;&lt; data; 
	cout. setf(oldadjust, ios::adjustfield); 
</pre>
This technique ensures that only one of the adjustfield bits is ever 
set, and allows convenient restoration of the previous status. Using 
zero for the new value of the field will clear just those flags.<p>

This code clears the integer conversion base to the default state: 
<pre>
	cout. setf(0, ios::basefield);
</pre>
<br>
See the descriptions of the predefined manipulators setiosflags 
and resetiosflags in the "Manipulators" section. 
<p><br>

<font size=4><b>
ios::sync_with_stdio 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
ios::sync_with_stdio(); 
<p>

<b>
Description
</b><p>
If C stdio and C++ stream operations are performed on the same 
standard file, synchronization problems will occur. Since each style 
of I/O has its own buffering, I/O will not occur in the order of 
program execution.<p>

To solve this synchronization problem, call this static function before 
doing I/O to standard streams cin, cout, cerr, or clog; the 
function resets the standard streams to use class stdiobuf. I/O via 
stdio and streams will then be synchronized. A substantial 
performance degradation occurs, however, compared to using 
buffered stream I/O or buffered stdio.<p>

Note<br> 
Call sync_with_stdio only when doing I/O to the 
same standard input, output, or error file. Using 
exclusively stdio input functions on stdin and 
exclusively stream output functions on cout does 
not cause problems. 
<p><br>

<font size=4><b>
ios::tie
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
ostream * ios::tie(ostream *osp); ostream * ios::tie(); 
<p>

<b>
Description
</b><p>
A stream can be '' tied'' to one ostream, kept track of by the tie 
stream variable. Whenever a stream needs to acquire more input or 
flush its output, the tied stream, if any, is flushed first. For example, cin is initially tied to cout, so that pending output, such as a prompt, will be flushed before new input is attempted.<p>

tie(osp) sets the tie variable of stream s to the ostream pointed to 
by input parameter osp, and returns the old value of the tie variable. 
This code unties a stream while some work is done, and then 
restores the previous tie:<p>

ostream* oldosp = s. tie(0);<br>
 ... do something ...<br> 
s. tie(oldosp);<p>

tie returns the current value of the tie variable. 
<p><br>


<font size=4><b>
ios:unsetf
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
long ios::unsetf(long newflags); 
<p>

<b>
Description
</b><p>
Each bit set in the long value newflags is unset in the formatting 
flags of stream ios. The remaining formatting flags are unaffected. 
The function returns a long containing the previous formatting flags.<p> 

Function setf sets corresponding flag bits, while function unsetf 
clears them. See the description of predefined manipulator 
resetiosflags in "Manipulators" for more information. 
<p><br>

<font size=4><b>
ios:width
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
long ios::width();<br>
long ios::width(int newwidth); 
<p>

<b>
Description
</b><p>
width() returns the current field width format state of stream ios. If 
the field width is zero, inserters will insert only the characters 
necessary to represent the value being inserted. If the field width is 
greater than the number of characters needed, the field will be 
padded with the fill character to the specified width. If the field 
width is less than the number of characters needed, the width will be 
extended. Field width represents the minimum field width; it cannot 
be used to provide truncation to a maximum field width.<p>

width(newwidth) sets the field width format state of stream s to 
newwidth, and returns the old value. The default value is 0. The field 
width is reset to zero automatically after every formatted insertion or 
extraction. It must therefore be reset for each operation requiring a 
field width. See the description of the predefined manipulator setw 
in "Manipulators" for more information. 
<p><br>

<font size=4><b>
ios::xalloc
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int ios::xalloc(); 
<p>

<b>
Description
</b><p>
This static member function returns a previously unused index into 
an array of words. A word is big enough to contain a long or a void*. 
This index can then be used with functions iword or ipword to get 
a reference to a reserved status variable. 
<p><br>

<hr><!-- =========================================== -->

<a name="istream"><h2>Class istream</h2></a>

Class istream defines the behavior of input streams. It supports 
formatted and unformatted extraction (input) of data from an 
associated streambuf. <p>

istream works in combination with class ostream, which defines 
the behavior of output streams.</font><p>

<font size=4><b>
Formatted Input (extraction) Functions</font></b><p>
<font size=3>
These functions work with formatted input. They call the setup 
function ipfx(0). If it returns zero, no further action takes place. 
Otherwise, leading whitespace is stripped if ios::skipws is set. If 
only whitespace remains in the istream, no characters will remain 
and the ios::failbit will be set. <p>

istream defines the following formatted input function. <p>

<b>istr &gt;&gt; sbufp</b><br>
This function extracts characters from istr and inserts them into the 
streambuf pointed to by sbufp. It always returns a reference to 
istream. You can use this function to copy a stream efficiently, 
but be sure neither stream is tied. For example: <p>
<pre>
	#include &lt;iostream.h&gt;
	main() 
	{ // copy cin to cout 
	  cin. tie(0); 
	  cout. tie(0); 
	cin &gt;&gt; cout. rdbuf(); // see ios for 
	                      // rdbuf return 0; 
	}
</pre> 
<b>istr &gt;&gt; x</b><br>
This function extracts characters from istream and converts them 
according to the type of x. If ipfx returns zero, no characters are 
extracted and x is unchanged. Errors encountered are recorded in 
the error state of istream. In general, ios::failbit means the 
next available characters were not suitable for the type; for example, 
leading letters for a numeric type, or leading whitespace for any 
type. Offending characters are not extracted. Generally, 
ios::badbit means no characters could be extracted, as in 
attempting to extract past the end of file. These functions always 
return a reference to istream. User-written functions must conform 
to these principles and be of the form:<p>

istream&amp; operator&gt;&gt; (istream&amp;, SomeType)<p>

The type of x and the format state of the istream (described in class 
ios) determine details of the extraction and conversion. These 
functions do not change the state of the istream, although the width 
variable is reset to zero after each formatted extraction. The 
predefined formatted extractors are:<p>
<dl>
<b>Extractor/Description</b> 
<dt>char&amp; 
<dt>unsigned char&amp; 
<dd>Extracts one character and stores it in x. <p>

<dt>short&amp; 
<dt>unsigned short&amp; 
<dt>int&amp; 
<dt>unsigned int&amp; 
<dt>long&amp; 
<dt>unsigned long&amp; 
<dd>Extracts characters and converts them to an 
integral value according to the conversion 
base in the istream's format flags, and stores 
the value in x. The first character can be a 
plus ('+ ') or minus ('-') sign. The characters 
are then treated as decimal, octal, or 
hexadecimal, if the ios::basfield flags are 
dec, oct, or hex, respectively. If none of 
these flags is set, the number is interpreted 
in the same way as integer constants in C++. 
That is, if the first two characters are "0x" or 
"0X" the base is hex; otherwise, if the first 
character is '0' the base is octal; otherwise 
the base is decimal. <p>

<dd>Extraction (and thus conversion) stops with 
the first non-digit, which is not extracted. 
Valid digits are '0'-' 7' for octal, '0'-' 9' for 
decimal, and '0'-' 9', 'a'-' f', 'A'-' F' for 
hexadecimal. Error flag ios::failbit is set if no 
valid digits are encountered. A "0x" 
followed by a non-digit is an error. In case 
of an error, the value of x is not changed.<p>

<dt>float&amp; 
<dt>double&amp; 
<dd>Extracts characters and converts them to a 
floating point value according to the C++ 
rules for floating point constants, and stores 
the value in x. The error flag ios::failbit is set 
if the characters extracted do not begin a 
well-formed floating point number; some 
characters can be extracted in this case, 
depending on at what point the error is 
detected. In the case of an error, the value 
of x is not changed.<p>

<dt>char* 
<dt>unsigned char* 
<dd>Extracts characters and stores them in the 
array pointed to by x until a whitespace 
character is encountered. The whitespace is 
not extracted (but ipfx might have discarded 
leading whitespace). If the width formatting 
variable (see the description of class ios) is 
non-zero, at most width-1 characters are 
extracted. A terminating null (0) is always 
stored in x, even when nothing is extracted. 
The error flag ios::failbit is set if no 
characters are available for extraction.</font><p>
</dl>

<font size=4><b>
Unformatted Input (extraction) Functions</b></font><p>
<font size=3>
These functions perform conversions on unformatted input. They 
call the setup function ipfx(1). If a function returns zero, no 
further action takes place. Leading whitespace is not skipped, and 
no conversions take place. See descriptions of the functions in 
"Member Functions of istreams". Unformatted input functions are: <p>
<dl><b>
Function/Description</b><br>
<dt>get
<dd>Gets the next character(s) from the stream. 
<dt>getline
<dd>Gets lines from the stream. 
<dt>ignore 
<dd>Gets characters and discards them. 
<dt>read
<dd>Gets characters until EOF is encountered. 
</dl>
</font><p>
<font size=4><b>
Positioning Functions</font></b><p> 
<font size=3>
These functions position the get pointer of the streambuf associated 
with an istream. See the section "Class streambuf (Public Interface)"<p> 
<b><dl>
Function/Description</b>
<dt>istream::seekg(pos) 
<dd>Sets the position of the get pointer; returns istream. 
<dt>istream::seekg(offset, dir) 
<dd>Sets the position of the get pointer; returns istream. 
<dt>streampos istream::tellg() 
<dd>Returns the current position of the get pointer. 
</dl>
<p>
</font>

<font size=4><b>
istream Predefined Manipulators</font></b><p>

A manipulator can look like an inserted or extracted object, but often 
only changes the state of the stream. See "Manipulators" and "ios 
Predefined Manipulators" for more information.<p>

These manipulators are predefined for use with istreams:<p>
<b><dl>
Manipulator/Description</b><br>
<dt>istr &gt;&gt; manip
<dd>Equivalent to the call manip(istr). 
<dt>istr &gt;&gt; dec 
<dd>Sets the conversion base of istr to 10. 
<dt>istr &gt;&gt; oct 
<dd>Sets the conversion base of istr to 8. 
<dt>istr &gt;&gt; hex 
<dd>Sets the conversion base of istr to 16. 
<dt>istr &gt;&gt; ws 
<dd>Extracts and discards consecutive whitespace characters from istr. 
</dl></font><p>

<font size=4><b>
Member Functions of istreams</font></b><p>
<font size=3>
Class istream is derived from class ios, so you can use all of the 
ios member functions on an istream object.<p>

The following functions are members of class istreams.<p>

<font size=4><b>
istream constructors 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
istream(streambuf *sbufp);
<p>

<b>
Description
</b><p>
istream(sbufp) associates the streambuf pointed to by sbufp 
with the stream and initializes the ios state. 
<p><br>

<font size=4><b>
istream::gcount 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
istream::gcount 
<p>

<b>
Description
</b><p>
This function returns the number of characters extracted from istr 
by the last unformatted input function.<p>

Note that formatted input functions might call unformatted input 
functions, thus changing the count. 
<p><br>

<font size=4><b>
istream::get
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int istream::get();<br>
istream::get(char&amp; c);<br> 
istream::get(char *ptr, int count, char delim= '\n');<br>
istream::get(streambuf &amp; sbuf, char delim= '\n');<br>
<p>

<b>
Description
</b><p>
get() extracts the next character from istream and returns it. It 
returns EOF if no more characters are available; however, it never 
sets ios::failbit.<p> 

get(c) extracts the next character from istr and stores it in c. It 
stores EOF if no more characters are available; it sets ios::failbit 
when attempting to extract beyond EOF. This function always 
returns a reference to istream.<p>

get(ptr, count, delim) extracts characters from istr and stores 
them in the char array beginning at ptr. Extraction stops after 
count-1 characters have been extracted or when a character 
matching delim is encountered, whichever happens first. If a 
delim character is encountered, it is not extracted or stored. This 
function always stores a terminating null (0) even if nothing is 
extracted. It sets ios::failbit only if EOF is encountered before 
any characters are stored. This function always returns a reference to 
istream.<p>

istream::get(sbuf, delim) extracts characters from istr and 
stores them in the streambuf sbuf. Extraction stops when a 
character matching delim (or EOF) is encountered, or when a store 
into sbuf fails, whichever happens first. If a delim character is 
encountered, it is not extracted or stored. If delim is EOF, 
extraction stops only when input is exhausted or when a store 
operation fails. This function sets ios::failbit only if a store into 
sbuf fails;. it always returns a reference to istream. 
<p><br>

<font size=4><b>
istream::getline 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
istream::getline(char *ptr, int count, char delim= '\n');
<p>

<b>
Description
</b><p>
This function is the same as istream::get(ptr, count, delim), 
except delim, if encountered, is extracted but not stored. Once 
count-1 characters have been extracted, the next character is left in 
istream, even if it is delim. This function always returns a 
reference to istream. 
<p><br>

<font size=4><b>
istream::ignore 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
istream::ignore(int count= 1, int delim= EOF);
<p>

<b>
Description
</b><p>
Extracts characters from istr and discards them. Extraction stops 
when a character matching delim is encountered, when count 
characters have been extracted, or when EOF is encountered, 
whichever happens first; the delim character is extracted. If delim 
is EOF, all input is discarded. This function always returns a 
reference to istream.
<p><br>

<font size=4><b>
istream::ipfx
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int istream::ipfx(int noform= 0); 
<p>

<b>
Description
</b><p>
This function performs setup procedures common to all extraction 
operations. Formatted extractors call ipfx(0); unformatted 
extractors call ipfx(1).<p>

If the error state of istream is non-zero, ipfx returns zero 
immediately. If a stream is tied to istream (see ios::tie) and 
noform is zero, the tied stream is flushed. If flag skipws is set for 
the stream and noform is zero, leading whitespace characters (defined by iswhite, see ctype(3V)), are skipped. This function 
returns zero if an error condition is encountered; non-zero 
otherwise. 
<p><br>

<font size=4><b>
istream::peek
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int istream::peek();
<p>

<b>
Description
</b><p>
This function first calls istream::ipfx(1). If ipfx returns zero or 
if istr is at EOF, it returns EOF. Otherwise, it returns the next 
character without extracting it. 
<p><br>

<font size=4><b>
istream::putback
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
istream::putback(char c); 
<p>

<b>
Description
</b><p>
If istream::fail() returns non-zero, this function returns without 
doing anything. Otherwise, it attempts to back up the streambuf 
associated with istr by pushing back character c.<p> 

Because it does not extract, putback does not call ipfx. It may 
fail, setting ios::failbit. In general, c must match the character 
ahead of the streambuf's get pointer (normally the last character 
extracted) -input might come from a read-only in-memory buffer.<p>
<p><br>

<font size=4><b>
istream::read
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
istream::read(char *ptr, int count);
<p>

<b>
Description
</b><p>
This function extracts characters from istr and stores them in the 
char array beginning at ptr. Extraction stops after count 
characters are extracted or when EOF is encountered, whichever 
happens first. This function always returns a reference to istream.<p>

read sets ios::failbit if EOF is encountered before count 
characters are extracted. The number of characters extracted can be 
found by calling istream::gcount(). 
<p><br>

<font size=4><b>
istream::sync 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int istream::sync();
<p>

<b>
Description
</b><p>
This function forces a correspondence between internal data 
structures and the external source of characters in an 
implementation-defined manner. It calls the virtual function 
istream::rdbuf()-&gt; sync(); the result depends on the actual 
type of the buffer class. This function returns EOF if an error occurs. 
</font><p><br>

<hr><!-- =========================================== -->

<a name="istream_withassign"><h2>Class istream_withassign</h2></a>

<font size=3>
Class istream_withassign implements the assignment operator for istream objects. 
Use it to redirect stream input to other streams.</font><p>

<font size=4><b>
Member Functions of istream_withassign</font></b><p>

<font size=3>
Class istream_withassign is derived from class istream. You 
can use all istream and ios member functions on 
istream_withassign objects. The following functions are 
members of class istream_withassign.<p>

<font size=4><b>
istream_withassign constructor
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
istream_withassign();
<p>

<b>
Description
</b><p>
istream_withassign() creates an istream_withassign 
object that can be assigned to, but performs no initialization. 
<p><br>

<font size=4><b>
istream_withassign::operator= 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
istream_withassign::operator= (streambuf * sbufp);<p>
istream_withassign::operator= (istream &amp; istr); 
<p>

<b>
Description
</b><p>
The first function associates the streambuf pointed to by sbufp with 
the istream_withassign object and completely initializes it. The 
second function associates the streambuf, associated with istr, 
with the istream_withassign object, which the constructor completely initializes. These functions return a reference to the 
object it was assigned to. </font>
<p><br>

<hr><!-- =========================================== -->

<a name="istrstream"><h2>Class istrstream</h2></a>

Class istrstream supports stream input using in-memory character arrays. 
An istrstream uses a strstreambuf as a buffer to hold 
characters in memory. istrstream performs stream input 
operations on strings or on text stored in memory.</font><p>

<font size=4><b>
Member Functions of istrstream</font></b><p>

Because class istrstream is derived from class istream, which 
is in turn derived from ios, you can use all of the member functions 
of ios and istream on an istrstream object. The following 
functions are members of class istrstream.<p>

<font size=4><b>
istrstream constructors 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
istrstream(char *ptr); istrstream(char *ptr, int len);
<p>

<b>
Description
</b><p>
istrstream(ptr) assumes ptr points to a null-terminated array of 
characters, which serves as the input source. Null is not part of the 
input. Seeks, using istream::seekg, are permitted within the range 
of the array. istrstream(ptr, len) assumes ptr points to an array 
of characters of length len, which will serve as the input source. 
Seeks, using seekg, are permitted within the range of the array.
<p><br>

<font size=4><b>
istrstream::rdbuf
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
strstreambuf * istrstream::rdbuf(); 
<p>

<b>
Description
</b><p>
This function returns a pointer to the strstreambuf associated with 
istrstream. It works like its counterparts in the base classes, 
except that its return type is specifically a strstreambuf*. 
<p><br>
</font>

<hr><!-- =========================================== -->

<a name="ofstream"><h2>Class ofstream</h2></a>

Class ofstream, a specialization of class ostream, implements 
output streams for files. It uses a filebuf object as a buffer to 
coordinate operations between the stream and the file.<p>

The section "Classes fstream, ifstream, and ofstream" discusses 
fstream, ifstream, and ofstream together, using the notation 
<b>Xstream.</font></b><p> 

<hr><!-- =========================================== -->

<a name="ostream"><h2>Class ostream</h2></a>

<font size=3>
Class ostream defines behavior for output streams. It supports 
formatted and unformatted insertion (output) of data to an 
associated streambuf. ostream works in combination with class 
istream, which defines the behavior of input streams.</font><p>

<font size=4><b>
Output Prefix and Suffix Functions</b></font><p>

<font size=3>
These functions perform setup and cleanup actions before and after 
insertion operations:<p>

<b>Function/Description</b>
<dl>
<dt>opfx 
<dd>Performs setup for insertion operations 
<dt>osfx 
<dd>Performs cleanup after insertion operations 
</dl><p>

<b>Formatted Output (insertion) Functions</b><p>

These functions work with formatted output.  They call setup function opfx(). If zero returns, no further action takes place. These 
functions also call osfx() before returning (if opfx succeeded). The 
following output functions are defined by ostream.<p>

<b>ostr &lt;&lt; sbufp</b>
If ostr. opfx() returns non-zero, this function inserts all the 
characters into ostr that can be extracted from the streambuf 
pointed to by sbufp. No padding is performed. It returns a 
reference to ostr.<p>

You can use this function to copy a stream efficiently, but be sure 
neither stream is tied. For example:<p>
<pre>
	#include &lt;iostream.h&gt; 
	main() 
	{ // copy cin to cout 
	  cin. tie(0); 
          cout. tie(0); 
	cout &lt;&lt; cin. rdbuf(); 
	  // see ios::rdbuf 0; 
	} 
</pre>
<br>
<b>istr &lt;&lt; x</b>
If ostr. opfx(0) returns non-zero, this function inserts characters 
representing x into ostr. If opfx returns zero, no action is taken. 
Errors encountered are recorded in the error state of istream. 
These functions always return a reference to ostr. User-written 
functions must conform to these principles and be of the form:<p>

ostreama<b>&amp;</b> operator&lt;&lt; (ostream<b>&amp;</b>, SomeType) <p>

The type of x and the format state of the ostream (see the section 
"Format Control" in the discussion of class ios) determine the 
details of the conversion and insertion. This kind of function does 
not change the state of the ostream, except that the width variable is 
reset to zero after each formatted insertion.<p>

Predefined formatted inserters and their conversion rules are:<p>

<b>Predefined inserters/Conversion rules</b><br>
<dl>
<dt>char 
<dt>unsigned char 
<dd>Inserts the character x into ostr without conversion. 
<dt>shor 
<dt>unsigned short
<dt>int 
<dt>unsigned int
<dt>long 
<dt>unsigned long
<dd>The representation consists of a sequence of 
"digits" with no leading zeros. The digits 
and coversion are octal if ios::oct is set, 
hexadecimal if ios::hex is set, decimal if 
ios::dec or none of these is set. For decimal 
conversion, if x is positive and ios::showpos 
is set, there is a leading plus sign ('+ '); if x is 
negative there is a leading minus sign ('-'). 
The octal and hexadecimal conversions are 
treated as unsigned; no sign is included. 
<dd>If ios::showbase is set, there is a leading '0' 
for octal conversion and a leading "0x" or 
"0X" ' for hexadecimal conversion, 
depending on whether ios::uppercase is set.
<dt>float 
double 
<dd>The value of x is converted according to the 
current values in ostr of precision, width, 
ios::scientific, ios::fixed, and ios::uppercase. 
<dt>char* 
<dd>The representation is the sequence of 
characters pointed to by x up to but not 
including the first null (0) character.<p>
<dt>void* 
<dd>The pointer is converted as if it were an int 
and ios::showbase and ios::hex were set. 
</dl>
</font><p>

<font size=4>
<b>Unformatted Output (insertion) Functions</font></b><p>

<font size=3>
These functions work with unformatted output. They do not call 
opfx() or osfx(). See "Member Functions of ostream".<p>

<b>Function/Description</b><br><dl>
<dt>put 
<dd>Inserts a character into the ostream. 
<dtwrite 
<dd>Inserts multiple characters into the ostream.
</dl>
</font><p>

Positioning Functions These functions position the put pointer of the streambuf associated 
with an ostream. See the "Class streambuf (Public Interface)" section.<p>
<b>Function/Description</b>
<dl>
<dt>ostr.seekp(pos) 
<dt>ostr.seekp(off, dir) 
<dd>Sets the position of the put pointer; returns 
<dd>a reference to ostr. 
<dt>streampos pos = 
<dt>ostr.tellp() 
<dd>Returns the current position of the put 
<dd>pointer. 
</dl>
<p>
</font>

<h3>ostream Predefined Manipulators</h3>

A manipulator can appear to be an inserted or extracted object, but it 
usually changes only the state of the stream. See the "Manipulators" 
and "ios Predefined Manipulators" sections. These manipulators are 
predefined for use with ostreams.</font><p>

<font size=4><b>
Manipulator/Description</b></font><p>
<dl>
<dt>ostr &lt;&lt; manip
<dd>Equivalent to the call manip(ostr). 
<dt>ostr &lt;&lt; dec
<dd>Sets the conversion base of ostr to 10. 
<dt>ostr &lt;&lt; oct 
<dd>Sets the conversion base of ostr to 8. 
<dt>ostr &lt;&lt; hex 
<dd>Sets the conversion base of ostr to 16. 
<dt>ostr &lt;&lt; endl 
<dd>Ends a line by inserting newline and flushing ostr. 
<dt>ostr &lt;&lt; ends 
<dd>Ends a string by inserting null (0) character into 
ostr. 
<dt>ostr &lt;&lt; flush 
<dd>Equivalent to calling ostr. flush(). 
</dl></font><p>

<font size=4><b>
Member Functions of ostream</font></b><p>
<font size=3>
Class ostream is derived from class ios; you can use all of the ios 
member functions on an ostream object. The following functions are 
members of class ostream.<p> 

<font size=4><b>
ostream constructor 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
ostream(streambuf *sbufp); 
<p>

<b>
Description
</b><p>
ostream(sbufp) associates the streambuf pointed to by sbufp 
with the stream and initializes the ios state. 
<p><br>

<font size=4><b>
ostream::flush
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
ostream::flush(); 
<p>

<b>
Description
</b><p>
This function causes characters stored in the associated streambuf to 
be flushed; for example, they are written to the output file. The 
function returns a reference to ostream. 
<p><br>

<font size=4><b>
ostream::opfx 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int ostream::opfx(); 
<p>

<b>
Description
</b><p>
This function performs setup procedures common to all insertion 
operations. If a stream is tied to ostr (see ios::tie), the tied 
stream is flushed. If the error state of ostream is non-zero, opfx 
returns zero immediately. User-defined inserter functions must start 
by calling opfx.<p> 

This function returns zero if an error condition is encountered, non-zero 
otherwise. 
<p><br>

<font size=4><b>
ostream::osfx
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
ostream::osfx();
<p>

<b>
Description
</b><p>
This function performs cleanup procedures at the conclusion of an 
insertion operation. If ios::unitbuf is set, flushes the stream. If 
ios::stdio is set, flushes stdout and stderr. Predefined 
inserters call osfx, but unformatted output functions do not.<p> 

User-defined inserters must call osfx before returning. 
<p><br>

<font size=4><b>
ostream::put
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
ostream::put(char c); 
<p>

<b>
Description
</b><p>
This function inserts the character c into ostr. Sets the error state if 
the operation fails. The function always returns a reference to ostr. 
<p><br>

<font size=4><b>
ostream::write 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
ostream::write 
<p>

<b>
Description
</b><p>
This function inserts exactly len characters starting at the beginning 
of the char array, pointed to by ptr, into ostream. It sets the 
error state if the operation fails. The function always returns a 
reference to ostream. 
</font><p><br>

<hr><!-- =========================================== -->

<a name="ostream_withassign"><h2>Class ostream_withassign</h2></a>

Class ostream_withassign implements the assignment operator for ostream objects. 
Use it to redirect stream output to other streams.</font><p>

<font size=4><b>
Member Functions of ostream_withassign</font></b><p>
<font size=3>
Because class ostream_withassign is derived from class 
ostream, you can use all ostream and ios member functions on 
ostream_withassign objects. The following functions are 
members of class ostream_withassign.<p>

<font size=4><b>
ostream_withassign constructor 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
ostream_withassign(); 
<p>

<b>
Description
</b><p>
ostream_withassign() creates an ostream_withassign 
object that can be assigned to. However, it performs no initialization.
<p><br>

<font size=4><b>
ostream_withassign::operator=
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
ostream_withassign::operator= (streambuf *sbufp); 
ostream_withassign::operator= (ostream &amp; ostr); 
<p>

<b>
Description
</b><p>
The first function associates the streambuf pointed to by sbufp with 
the ostream_withassign object, completely initializing the 
object. The second function associates the streambuf, associated with 
ostr, with the ostream_withassign object, which is 
completely initialized by the constructor. Each function returns a 
reference to the object it was assigned to. 
<p><br></font>


<hr><!-- =========================================== -->

<a name="ostrstream"><h2>Class ostrstream</h2></a>

Class ostrstream is a specialization of class ostream. It supports 
stream output using in-memory character arrays. An ostrstream uses 
a strstreambuf as a buffer to hold the characters in memory. Use 
ostrstream to perform stream output operations on strings or on 
text stored in memory.<p>

Related classes istrstream and strstream are specializations of 
classes istream and iostream, respectively.</font><p>

<font size=4><b>
Member Functions of ostrstream</font></b>

<font size=3>
Class ostrstream is derived from class ostream, which in turn is 
derived from ios. You can use all of the member functions of ios 
and ostream on an ostrstream object.<p>

The following functions are members of class ostrstream.<p>

<font size=4><b>
ostrstream constructors
</font></b><p>

<font size=3><b>
Header
</b><p>
strstream.h
<p>

<b>
Prototype
</b><p>
ostrstream();<br>
ostrstream(char *ptr, int len, int mode= ios::out);
<p>

<b>
Description
</b><p>
ostrstream() creates an empty output stream that uses a dynamic 
(expandable) array of characters (see class strstreambuf). Seeks are 
permitted within the current bounds of the array. Presumably this 
stream will be converted to a char* via str() (see below).<p>

ostrstream(ptr, len, mode) creates an output stream using the 
static (non-expandable) array of len characters starting at ptr. If 
the ios::ate or ios::app bits are set in mode, the array is assumed 
to contain a null-terminated string beginning at ptr. Characters are 
stored beginning at the null character, but never go beyond len 
characters. If those bits are not set in mode, the array is assumed to 
contain no data, and characters will be stored beginning at ptr. 
Seeks are permitted within the range of the array. 
<p><br>

<font size=4><b>
ostrstream::pcount 
</font></b><p>

<font size=3><b>
Header
</b><p>
strstream.h 
<p>

<b>
Prototype
</b><p>
int ostrstream::pcount(); 
<p>

<b>
Description
</b><p>
This function returns the number of characters stored in the array. It 
is useful when the array contains binary data or is not null-terminated. 
<p><br>

<font size=4><b>
ostrstream::rdbuf 
</font></b><p>

<font size=3><b>
Header
</b><p>
strstream.h 
<p>

<b>
Prototype
</b><p>
strstreambuf * ostrstream::rdbuf(); 
<p>

<b>
Description
</b><p>
This function returns a pointer to the strstreambuf associated with 
ostrstream. It works like its counterparts in the base classes, 
except that its return type is specifically a strstreambuf*. 
</font><p><br>

<hr><!-- =========================================== -->

<a name="stdiobuf"><h2>Class stdiobuf</h2></a>

The stdiobuf class is a specialization of streambufs using a C stdio FILE structure as an intermediary to the file that is the source 
or destination of characters. Input, output, and seek operations are 
reflected in changes to the associated FILE structure. For example, 
seek functions are implemented in terms of fseek().<p>

The stdiostream class provides a C++ interface to a C stdio FILE 
structure. Class streambuf implements basic streambuf operations.</font><p>

<font size=4><b>
Why Use stdiobuf?</font></b><p>

<font size=3>
The only reason to use stdiobuf is to integrate existing C stdio code 
and C++ iostream-like code. If possible, use filebuf for new code; 
filebuf operations are more efficient because they are buffered.</font><p>

<font size=4><b>
Member Functions of stdiobuf</font></b><p>

<font size=3>
Class stdiobuf is derived from streambuf, so you can use all of the 
streambuf member functions on objects of class stdiobuf.<p>

The following functions are members of class stdiobuf.<p>

<font size=4><b>
stdiobuf constructor 
</font></b><p>

<font size=3><b>
Header
</b><p>
stdiostream.h 
<p>

<b>
Prototype
</b><p>
stdiobuf(FILE *fp); 
<p>

<b>
Description
</b><p>
This function constructs a stdiobuf attached to the FILE structure 
pointed to by fp. 
<p><br>

<font size=4><b>
stdiobuf::stdiofile 
</font></b><p>

<font size=3><b>
Header
</b><p>
stdiostream.h 
<p>

<b>
Prototype
</b><p>
FILE * stdiobuf::stdiofile();
<p>

<b>
Description
</b><p>
This function returns a pointer to the FILE structure associated with 
stdioiobuf. The function returns a pointer to FILE structure. 
<p><br></font>


<hr><!-- =========================================== -->

<a name="stdiostream"><h2>Class stdiostream</h2></a>

The stdiostream class provides a C++ interface to a C stdio FILE 
structure. It has a stdiobuf as its buffer. It is not a full implementation 
of iostreams; it has only the buffer-class and ios-class functionality. 
C++ I/O is done via per-character calls to the C stdio functions 
getc and putc. Buffering does not occur; it would break 
synchronization of the C and C++ file accesses.<p>

The stdiobuf class provides a specialization of streambufs using a C 
stdio FILE structure as an intermediary to the actual file that is the 
source or destination of characters. Basic streambuf operations are 
implemented in class streambuf.</font><p>

<font size=4><b>
Why Use stdiostream?</font></b><p>

<font size=3>
The only reason to use stdiostream is to integrate existing C 
stdio code and C++ iostream-like code. If possible, use fstream 
for new code; fstream operations are more efficient because they 
are buffered.</font><p>

<font size=4><b>
Member Functions of stdiostream</font></b><p>

Class stdiostream is derived from ios so you can use all of the 
ios member functions on objects of class stdiostream. The 
following functions are members of class stdiostream.<p>

<font size=4><b>
stdiostream constructor
</font></b><p>

<font size=3><b>
Header
</b><p>
stdiostream.h 
<p>

<b>
Prototype
</b><p>
stdiobuf * stdiostream::rdbuf(); 
<p>

<b>
Description
</b><p>
Constructs a stdiostream attached to the FILE structure pointed to 
by fp. 
<p><br>


<font size=4><b>
stdiostream::rdbuf
</font></b><p>

<font size=3><b>
Header
</b><p>
stdiostream.h 
<p>

<b>
Prototype
</b><p>
stdiobuf * stdiostream::rdbuf(); 
<p>

<b>
Description
</b><p>
Returns a pointer to the stdiobuf associated with stdiostream. 
It works like ios::rdbuf() except the return type is a stdiobuf. 
<p><br></font>


<hr><!-- =========================================== -->

<a name="streambuf"><h2>Class streambuf (Protected Interface)</h2></a>

The streambuf class is an abstract class for implementing buffers 
associated with input and output streams. It defines the basics from 
which actual buffer classes are derived.<p>

The protected interface to streambuf provides functions required 
to derive a user-defined buffer class. You do not typically create 
objects of type streambuf; buffer objects are of a class type derived 
from streambuf. The iostream library provides three predefined 
derived buffer classes: filebuf, strstreambuf, and stdiobuf.<p>

The public interface to streambuf, described in the section "Class 
streambuf (Public Interface)", provides functions that any stream 
class can perform its buffer related operations.</font><p>

<font size=4><b>
Using the Protected Interface to streambuf</font></b><p>

<font size=3>
The non-virtual functions in this interface are not intended to be 
over-ridden; they provide low-level buffer management functions. It 
is the virtual functions that you will often to override.<p>

Where a virtual function's default behavior is suitable for a derived 
buffer class, you do not have to override it. For example, a buffer 
class that has no input source need not do anything on underflow 
except return EOF, the default behavior. Where the default behavior 
is not appropriate, you must provide a class-specific version of the 
function. For example, an input buffer connected to a file attempts to 
read more data on underflow.<p>

A replacement virtual function conforms to the specification of the 
streambuf version, to ensure other functions that depend on this 
behavior will continue to work.</font><p> 

<font size=4><b>
The get, put, and reserve Areas</font></b><p>

<font size=3>
The buffer of a streambuf has three parts: the get area, the put area, 
and the reserve area. The get area contains characters immediately 
available for input. The put area holds characters stored for output 
but not yet consumed by (flushed to) their ultimate destination. The 
get and put areas can be disjoint or can overlap. The reserve area is 
the entire buffer, overlapped by the get and put areas. The get and 
put areas can expand into the remainder of the reserve area. In the 
course of input and output operations, the sizes of the get and put 
areas expand and shrink, always bounded by the total buffer size.<p>

The buffer and its three areas are defined by private pointer variables 
that you read and set using protected member functions. Think of 
the following pointers as pointing between characters; that is, 
although a pointer points to a character, it is helpful to conceptualize 
it as pointing to just before the character.</font><p>

<font size=4><b>
Non-virtual Functions for Examining Pointers</font></b><p>

<font size=3>
The protected interface to class streambuf defines the following 
non-virtual member functions for examining pointers. Their 
descriptions are in "Member Functions of streambuf (Protected 
Interface)".<p>

<b>Function/Returns the following</b>
<dl>
<dt>base 
<dd>A pointer to the beginning of the reserve area. 
<dt>eback 
<dd>The lowest possible value for gptr(). 
<dt>ebuf 
<dd>A pointer just past the end of the reserve area. 
<dt>egptr 
<dd>The maximum value for gptr(). 
<dt>epptr 
<dd>The maximum possible value for pptr(). 
<dt>gptr 
<dd>A pointer to the next character to be fetched. 
<dt>pbase 
<dd>The lowest possible value for pptr(). 
<dt>pptr 
<dd>The location of the next character to be stored. 
</dl></font>
<br>

<font size=4><b>
Non-virtual Functions for Setting Pointers</font></b><p>

<font size=3>
These functions provide the only way to set the pointers. Direct 
access is disallowed to ensure consistency among the various 
pointers. Pointer arguments to a function must all be zero to indicate 
that there is no area (get, put, reserve). Using equal non-zero 
pointers might result in incorrect behavior.<p>

The protected interface to class streambuf defines the following 
non-virtual member functions for examining pointers. Their descriptions are in "Member Functions of streambuf (Protected 
Interface)".<p>

<b>Function/Sets up the following</b>
<dl>
<dt>setb 
<dd>The buffer. 
<dt>Setg 
<dd>The get area. 
<dt>setp 
<dd>The put area. 
</dl></font>
<p>

<font size=4><b>
Virtual Functions</font></b><p>

<font size=3>
The following virtual functions can be or should be redefined by 
specialized buffer classes. Replacement functions must meet the 
specifications listed here to ensure the correct operation of other 
functions that depend on their behavior. See "Member Functions of 
streambuf (Protected Interface)" for information on the default 
behavior of these functions.<p>

<b>Function/Description</b>
<dl>
<dt>doallocate 
<dd>Allocates a buffer using new(). 
<dt>overflow 
<dd>Flushes characters to stdout when the put area is full. 
<dt>pbackfail 
<dd>Handles instances where put operations fail. 
<dt>seekoff 
<dd>Repositions the get and/ or put pointer(s) by some offset. 
<dt>seekpos 
<dd>Repositions the get and/ or put pointer(s) to a specific position. 
<dt>setbuf 
<dd>Set up a buffer. 
<dt>sync 
<dd>Synchronizes the streambuf with itscharacter stream. 
<dt>underflow 
<dd>Gets characters for input when the get area is empty.
</dl>
</font>
<p>

<font size=4><b>
Member Functions of streambuf (Protected Interface)</b><p>

<font size=3>
Class streambuf is an abstract class, so use only its derived classes 
(filebuf, strstreambuf, and stdiobuf) or derive your own 
class from streambuf.<p>

The protected interface to streambufs defines the following member 
functions. <p>

<font size=4><b>
streambuf constructors 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
streambuf();
streambuf(char* ptr, int len); 
streambuf(streambuf&amp;);
operator=(streambuf&amp;); 
<p>

<b>
Description
</b><p>
As streambuf is intended to be a base class, no streambuf 
object is meant to be constructed.<p>

streambuf() creates an empty buffer for an empty input stream. 
streambuf(ptr, len) creates an empty buffer, and makes a 
reserve area (see below) using the len bytes beginning at the 
location pointed to by ptr.<p>

The copy constructor streambuf(streambuf&amp;) and assignment 
operator operator=(streambuf&amp;) are private and not 
implemented to ensure that a streambuf cannot be copied. Do not 
copy a streambuf; instead, pass around pointers to one. 
<p><br>

<font size=4><b>
streambuf::allocate
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h
<p>

<b>
Prototype
</b><p>
int streambuf::allocate();
<p>

<b>
Description
</b><p>
This function is not called by any non-virtual member of streambuf. 
It tries to set up a reserve area of an unspecified default size. It 
returns zero and does nothing if a reserve area already exists or if the 
streambuf is marked unbuffered by a call to 
streambuf::unbuffered(). Otherwise, it attempts allocation by 
calling virtual function streambuf::doallocate(). It returns 1 on 
success, EOF on failure. 
<p><br>

<font size=4><b>
streambuf::base 
</font></b><p>

<font size=3><b>
Header
</b><p>
streambuf::base  
<p>

<b>
Prototype
</b><p>
char * streambuf::base(); 
<p>

<b>
Description
</b><p>
This function returns a pointer to the beginning of the reserve area. 
<p><br>

<font size=4><b>
streambuf::blen
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::blen();
<p>

<b>
Description
</b><p>
This function returns the size in chars of the reserve area, ebuf() -base().
<p><br>

<font size=4><b>
streambuf::doallocate 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h  
<p>

<b>
Prototype
</b><p>
int streambuf::doallocate(); 
<p>

<b>
Description
</b><p>
This function is called by streambuf::allocate() when 
streambuf::unbuffered() is zero and streambuf::base() is 
zero. It attempts to make a buffer of suitable size available.<p>

On success it must call setb to establish the reserve area, and then 
return a value greater than zero. The default behavior is to allocate a 
buffer using new. If a failure occurs, the function returns EOF. 
<p><br>

<font size=4><b>
streambuf::dpb 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h  
<p>

<b>
Prototype
</b><p>
streambuf::void sbuf. dpb(); 
<p>

<b>
Description
</b><p>
This function writes all the state variables of the streambuf as text 
directly to file descriptor 1 (standard output). This information is 
useful for debugging an implementation.<p>

dpb is a public function that you can call from anywhere in your 
code for debugging purposes, although it is logically part of the 
protected interface.<p>
<p><br>

<font size=4><b>
streambuf::eback 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
char * streambuf::eback(); 
<p>

<b>
Description
</b><p>
This function returns the lowest possible value for gptr(). The 
space from eback() through gptr()-1 is available for putting 
characters back (backing up the get pointer). If 
eback()== gptr(), an attempted putback operation might fail. 
<p><br>

<font size=4><b>
streambuf::gbumps 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<font size=4><b>
streambuf::ebuf
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
char * streambuf::ebuf(); 
<p>

<b>
Description
</b><p>
This function returns a pointer just past the end of the reserve area. 
The space from base() through ebuf()-1 is the reserve area. If 
ebuf()== base(), the stream is unbuffered. 
<p><br>

<font size=4><b>
streambuf::egptr 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
char * streambuf::egptr(); 
<p>

<b>
Description
</b><p>
This function returns a pointer just past the end of the get area, 
which constitutes the maximum possible value for gptr(). 
<p><br>

<font size=4><b>
streambuf::epptr 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
char * streambuf::epptr(); 
<p>

<b>
Description
</b><p>
This function returns a pointer just past the end of the put area, 
which constitutes the maximum possible value for pptr(). The 
space from pptr() through epptr() is immediately available for 
storing characters without a flush operation.
<p><br>

<b>
Prototype
</b><p>
streambuf::gbump(int n); 
<p>

<b>
Description
</b><p>
This function adds n, a signed quantity, to the get pointer, without 
any validity checks. 
<p><br>

<font size=4><b>
streambuf::gptr 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
char * streambuf::gptr(); 
<p>

<b>
Description
</b><p>
This function returns a pointer to the beginning of the get area, and 
thus to the next character to be fetched (if one exists).<p> 

The characters immediately available are from gptr() through 
egptr()-1. If egptr()&lt;= gptr(), no characters are available.
<p><br>


<font size=4><b>
streambuf::overflow 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::overflow(int c= EOF); 
<p>

<b>
Description
</b><p>
This function is called to consume characters (flush them to output), 
typically when the put area is full and an attempt is made to store 
another character. If c is not EOF, overflow must either store or 
consume the character, following those already in the put area.<p> 

The default behavior of the base class version is undefined, so each 
derived class must define its own overflow. The normal action for a 
derived class version is to consume the characters in the put area 
(those between pbase() and pptr()), call setp() to set up a new 
put area, then store c (using sputc()) if it is not EOF.<p>

The function returns EOF on error, any other value on success. 
<p><br>


<font size=4><b>
streambuf::pbackfail
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::pbackfail(int c); 
<p>

<b>
Description
</b><p>
This function is called when an attempt is made to put back the 
character c and no space is available in the putback area; that is, 
eback()== gptr().<p>

If this situation can be handled, such as by repositioning an external 
device, a derived class version of pbackfail should do so and 
return c. If the character cannot be put back, it returns EOF. The 
default behavior of the base class version is to return EOF.<p>
<p><br>



<font size=4><b>
streambuf::pbase 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
char * streambuf::pbase();
<p>

<b>
Description
</b><p>
This function returns a pointer to the beginning of the space 
available for the put area, which constitutes the lowest possible 
value for pptr(). The area from pbase() through pptr()-1 
represents characters stored in the buffer but not yet consumed. 
<p><br>


<font size=4><b>
streambuf::pbump 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
streambuf::pbump(int n); 
<p>

<b>
Description
</b><p>
This function adds n, a signed quantity, to the put pointer, without 
any validity checks. 
<p><br>



<font size=4><b>
streambuf::pptr
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
char * streambuf::pptr(); 
<p>

<b>
Description
</b><p>
This function returns a pointer to the beginning of the put area, and 
thus to the location of the next character that is stored (if possible). 
<p><br>



<font size=4><b>
streambuf::seekoff 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
streampos streambuf::seekoff(streamoff off,<br>
ios::seek_dir dir,<br> 
int mode = (ios::in | ios::out)); 
<p>

<b>
Description
</b><p>
See streambuf::seekoff in "Class streambuf (Public Interface)" 
for a description of its parameters, return value, and use.<p>

This function modifies the abstract get and put pointers, as opposed 
to gptr() and pptr() specifically, if possible. A derived class 
version returns EOF if the stream does not support repositioning or if 
there is any error, and the new position otherwise. The default 
behavior of the base class version is to return EOF. 
<p><br>

<font size=4><b>
streambuf::seekpos 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
streampos streambuf::seekpos(streampos pos, int mode=(ios::in | ios::out)); 
<p>

<b>
Description
</b><p>
See streambuf::seekpos in "Class streambuf (Public Interface)" 
for a description of its parameters, return value, and use.<p> 

This function modifies the abstract get and put pointers, as 
opposed to gptr and pptr specifically, if possible. The default 
behavior of the base class version is to return the value of 
streambuf::seekoff((streamoff) pos, ios::beg, mode ). 
Thus it is usually only necessary to implement seekoff in a derived 
class, and inherit the base class seekpos. 
<p><br>

<font size=4><b>
streambuf::setbuf 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
streambuf * streambuf::setbuf(char *ptr, int len); 
<p>

<b>
Description
</b><p>
A call of this function is a request to use the array of len bytes 
starting at the location pointed to by ptr as the buffer area. Setting 
ptr to zero or len to less than or equal to zero requests an 
unbuffered state.<p>

A derived class version can choose to ignore the request. It returns 
the address of sbuf if it accepts the request, EOF otherwise. The 
default behavior of the base class version is to honor the request if 
there is no reserve area. 
<p><br>

<font size=4><b>
streambuf::sync
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::sync(); 
<p>

<b>
Description
</b><p>
This function synchronizes the streambuf with its actual stream of 
characters. A derived class version flushes any characters in the put 
area to their final destination, and if possible give back any character 
in the input buffer to its source.<p>

The default behavior of the base class version is to return zero if an 
input or output character is not penting (streambuf::in_avail() 
and streambuf::out_waiting() are both zero), and return EOF 
otherwise. 
<p><br>

<font size=4><b>
streambuf::unbuffered 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::unbuffered(); streambuf::unbuffered(int i) 
<p>

<b>
Description
</b><p>
A streambuf has a private variable that keeps track of whether the 
stream is buffered or unbuffered, independent of whether a reserve 
area has been assigned. This variable is used mainly to control 
whether allocate() will actually allocate a reserve area.<p>

unbuffered() returns nonzero if the variable is set; zero otherwise. 
unbuffered(i) sets the variable if i is nonzero; clears it otherwise. 
<p><br>

<font size=4><b>
streambuf::underflow 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int i = sbuf.underflow 
<p>

<b>
Description
</b><p>
This function supplies characters for input (from some source) when 
the get area is empty, although it can be called at other times.<p>

If the get area is not empty, the first character is returned, without 
advancing the get pointer. If the get area is empty the function 
establishes a new get area, acquires new input, and returns the first 
character, if one exists.<p>

If no input characters are available, it leaves an empty get area and 
returns EOF. The default behavior of the base class version is 
undefined; each derived class must define how to handle underflow. 
<p><br></font>

<font size=4><b>
Class streambuf (Public Interface)</font></b><p>

<font size=3>
The streambuf class is an abstract class for implementing buffers 
associated with input and output streams. It defines the basics from 
which actual buffer classes are derived.<p>

The public interface to streambuf provides functions that any 
stream class might need to perform its buffer related operations. You 
do not typically create objects of type streambuf; buffer objects 
would be of a class type derived from streambuf. The section "Class 
streambuf (Protected Interface)" describes the protected interface 
necessary to create such derived classes.<p>

An object of class streambuf consists of a sequence of characters 
and one or two pointers that define where in memory where the 
next character will be stored (the put area) and/ or fetched (the get 
area). A buffer class intended only for input (or output) will have 
only the get (or put) pointer. A buffer class intended for both input 
and output will have both pointers.<p>

The get and put pointers point between characters in the sequence. 
The next character to be fetched from an input buffer is the one just 
after the get pointer. The next character placed into an output stream 
will be stored just after the put pointer. When at the beginning of the 
sequence, a pointer points just before the first character; at the end 
of the sequence it points just after the last character.<p></font>

<font size=4><b>
Buffering Strategies</font></b><p>

<font size=3>
The iostream library supports several buffering strategies. Queue-like 
buffers, such as strstreambufs, have independent get and put 
pointers. A strstreambuf object is an in-memory array of characters, 
and supports stores and fetches at arbitrary locations. File-like 
buffers, such as filebuf objects, can permit both get and put 
operations, but effectively only one pointer exists; the next get or 
put will always be at the current location. (In practice two pointers 
can exist, but they always point to the same place.)<p>

The streambuf uses an array of characters as the buffer, and calls 
upon virtual functions to fill an empty input buffer or to flush a full 
output buffer. (See "Class streambuf (Protected Interface)" for 
details.) The storing, fetching, and pointer manipulation functions 
are generally inline for maximum efficiency.<p>

The public interface to streambufs defines the followingfunctions. 
Their descriptionsare in "Member Functions of streambuf (Public 
Interface)".<p>

<b>Functions/Description</b><br>
Input Functions<p>
<dl>
<dt>getc 
<dd>Gets the character after the get pointer. 
<dt>in_avail 
<dd>Counts the number of characters in the get area. 
<dt>sbumpc 
<dd>Moves the get pointer forward one position and 
<dd>gets the character it moved past. 
<dt>sgetn 
<dd>Gets a string of characters. 
<dt>snextc 
<dd>Moves the get pointer forward one position. 
<dt>sputbackc 
<dd>Puts a character before the current pointer location. 
<dt>stossc 
<dd>Moves past the next character without getting it. 
</dl><br>
<dl>
<dt><b>Output Functions</b>
<dt>out_waiting 
<dd>Repositions the get/ put pointer(s). 
<dt>sputc 
<dd>Puts a character after the pointer. 
<dt>sputn 
<dd>Puts a string after the pointer. 
</dl><br>
<dl>
<dt><b>Positioning 
<dt>Functions</b>
<dt>seekoff 
<dd>Repositions the get/ put pointer(s). 
<dt>seekpos 
<dd>Repositions the get/ put pointer(s). 
<dt>sync 
<dd>Synchronizes the streambuf with the 
<dd>corresponding stream.
</dl><br> 
<dt><b>Other Functions</b>
<dt>setbuf 
<dd>Sets up a buffer area. 
</dl></font>
<p>

<font size=4><b>
Member Functions of streambuf (Public Interface)</font></b><p>

<font size=3>
Class streambuf is an abstract class, so you must use only its derived 
classes (filebuf, strstreambuf, and stdiobuf) or derive a class from 
streambuf yourself. The public interface to streambufs defines the 
following member functions.<p>

<font size=4><b>
streambuf::in_avail 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::in_avail();
<p>

<b>
Description
</b><p>
This function returns the number of characters immediately available 
in the get area. It ensures that i characters can be fetched without 
error, and without accessing any external device. 
<p><br>

<font size=4><b>
streambuf::out_waiting 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::out_waiting(); 
<p>

<b>
Description
</b><p>
This function returns the number of characters in the put area; that 
is, the number of characters pending output to the ultimate 
destination. 
<p><br>

<font size=4><b>
streambuf::sbumpc 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::sbumpc(); 
<p>

<b>
Description
</b><p>
This function should probably have been called "sgetc". It moves the 
get pointer forward one position and returns the character it moved 
past. If the get pointer is currently at the end of the sequence, this 
function returns EOF. 
<p><br>

<font size=4><b>
streambuf::seekoff 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
streampos streambuf::seekoff(streamoff off, ios::seek_dir dir, 
int mode=(ios::in | ios::out));
<p>

<b>
Description
</b><p>
This function repositions the get and/ or the put pointers, depending 
on the bits set in mode. If mode is set to ios::in, the get pointer is 
moved; if mode is ios::out, the put pointer is moved. The distance 
to move is off, a signed quantity. Values for dir are: 

ios::beg Move off bytes from the beginning of the stream 
ios::cur Move off bytes from the current position 
ios::end Move off bytes from the end of the stream 


Note 
Not all streams support positioning. 


The function returns the new position, or EOF if the stream could 
not be positioned. The position returned (of type streampos) must 
not be the subject of an arithmetic operation; it must be treated as a 
"magic" value. 
<p><br>

<font size=4><b>
streambuf::seekpos
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
streampos streambuf::seekpos(streampos pos,<br> 
int mode=(ios::in | ios::out)); 
<p>

<b>
Description
</b><p>
This function repositions the get or put pointer, depending on the 
bits set in mode, to position pos. If mode is set to ios::in, the get 
pointer is moved; if mode is ios::out, the put pointer is moved. The 
value of pos must be one that was returned by a previous call of 
seekoff or seekpos. Special values are: 


(streampos) 0 The beginning of the stream 
(streampos) EOF Error indicator 
<p><br>

<font size=4><b>
streambuf::setbuf 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
streambuf * streambuf::setbuf(char *ptr, int len); 
<p>

<b>
Description
</b><p>
This function attempts to use array len bytes starting at the location 
pointed to by ptr as the buffer area. Setting ptr to zero or len to 
less than or equal to zero requests an unbuffered state. Depending 
on the implementation of the derived class, honoring the request 
might not be possible. The function returns a pointer to the 
streambuf on success, or zero if the request cannot be honored. 
This function logically belongs in the protected interface to 
streambuf, but is in the public interface for compatibility with the 
original stream package. 
<p><br>

<font size=4><b>
streambuf::sgetc 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::sgetc(); 
<p>

<b>
Description
</b><p>
This function returns the character after the get pointer, or EOF if the 
get pointer is at the end of the sequence. Despite its name, this 
function does not move the get pointer. 
<p><br>

<font size=4><b>
streambuf::sgetn 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::ssgetn(char *ptr, int len);
<p>

<b>
Description
</b><p>
This function gets the next len characters following the get pointer, 
copying them to the char array pointed to by ptr; it advances the 
get pointer past the last character fetched. If fewer than len 
characters remain, it gets as many as are available. 
<p><br>

<font size=4><b>
streambuf::snextc 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::snextc(); 
<p>

<b>
Description
</b><p>
This function moves the get pointer forward one position, and then 
returns the character after the get pointer's new position. If the get 
pointer is at the end of the sequence before or after the call to this 
function (meaning that no character is available), this function 
returns EOF. For example, if the input buffer looks like this:<p>

abc| def <p>

where '| ' marks the position of the get pointer, snextc advances 
the get pointer and returns 'e'. 
<p><br>

<font size=4><b>
streambuf::sputbackc 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::sputbackc(char c); 
<p>

<b>
Description
</b><p>
This function attempts to move the get pointer back one character 
and put c at the new location. Depending on the underlying buffer 
mechanism, moving the pointer back or storing c at that location 
might not be possible. Therefore, the function's effect is uncertain if 
c is not the same as the character just ahead of the get pointer.<p>

Depending on the underlying buffer mechanism, this function might 
require resynchronization with an external device.<p>

The function returns the character that was put back, or EOF if the 
operation fails. Failure depends on the implementation of the actual 
buffer class, but would probably include already being at the 
beginning of a device. 
<p><br>

<font size=4><b>
streambuf::sputc
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::sputc(int c); 
<p>

<b>
Description
</b><p>
This function stores c just after the put pointer, and advances the 
pointer one position, possibly extending the sequence.<p>

The function returns the character stored, or EOF on error. What 
constitutes an error depends on the implementation of the actual 
derived buffer class. 
<p><br>

<font size=4><b>
streambuf::sputn 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
int streambuf::sputn(const char *ptr, int len); 
<p>

<b>
Description
</b><p>
&gt;From the location pointed to by ptr, this function stores exactly 
len characters after the put pointer, advancing the put pointer just 
past the last character. The function returns the number of characters 
stored, which is len. Fewer than len characters stored indicates an 
error. 
<p><br>

<font size=4><b>
streambuf::stossc();
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
This function moves the get pointer forward one position. 
<p>

<b>
Description
</b><p>
Use stossc in combination with sgetc (which provides 
lookahead) to implement a scanner without putting back characters. 
<p><br>

<font size=4><b>
streambuf::sync 
</font></b><p>

<font size=3><b>
Header
</b><p>
iostream.h 
<p>

<b>
Prototype
</b><p>
streambuf::sync 
<p>

<b>
Description
</b><p>
This function synchronizes the streambuf with its actual stream of 
characters. How it operates depends on the particular derived buffer 
class. Generally, any character in the put area is flushed to its final 
destination, and any character in the input buffer is given back to its 
source, if possible. This generally means that in_avail() and 
out_waiting() each return zero after a call to sync().<p> 

The function returns zero if successful, or EOF if an error occurs. 
<p><br>
</font>


<hr><!-- =========================================== -->

<a name="strstream"><h2>Class strstream</h2></a>

<font size=3>
Class strstream provides functions for stream I/O using in-memory 
character arrays. A strstream uses a strstreambuf as a buffer to hold 
the characters in memory. Use strstream to do stream I/O on strings 
or on text stored in memory.<p>

Related classes istrstream and ostrstream are derived from classes 
istream and ostream, respectively; they also perform I/O using 
character arrays.<p>

Auxiliary class strstreambase is an implementation detail to 
provide a set of common functions. It is not documented.</font><p>

<font size=4><b>
Member Functions of strstream</b></font><p>

<font size=3>
Class strstream is derived from class iostream, which in turn is 
derived from class ios. You can use all of the member functions of 
ios and iostream on a strstream object. The following functions 
are members of class strstream.<p>

<font size=4><b>
strstream constructors 
</font></b><p>

<font size=3><b>
Header
</b><p>
strstream.h 
<p>

<b>
Prototype
</b><p>
strstream(); strstream(char *ptr, int len, int mode);
<p>

<b>
Description
</b><p>
strstream() creates an empty bidirectional stream, which uses a 
dynamic (expandable) array of characters (see class strstreambuf). 
Seeks are permitted within the current bounds of the array.<p>

strstream(ptr, len, mode) creates a bidirectional stream using 
the static (non-expandable) array of len characters starting at ptr. 
If mode is set to ios::ate or ios::app bits, the array is assumed to 
contain a null-terminated string beginning at ptr. Characters are 
stored beginning at the null character, but never go beyond len 
characters. If those bits are not set in mode, the array is assumed to 
contain no data, and characters are stored beginning at ptr. Seeks 
are permitted within the range of the array.
<p><br>

<font size=4><b>
strstream::rdbuf 
</font></b><p>

<font size=3><b>
Header
</b><p>
strstream.h
<p>

<b>
Prototype
</b><p>
strstreambuf * strstream::rdbuf();
<p>

<b>
Description
</b><p>
This function returns a pointer to the strstreambuf associated with 
strstream. It works like its counterparts in the base classes, 
except its return type is specifically a strstreambuf*. 
<p><br>

<font size=4><b>
strstream::str
</font></b><p>

<font size=3><b>
Header
</b><p>
strstream.h
<p>

<b>
Prototype
</b><p>
strstream::str
<p>

<b>
Description
</b><p>
This function returns a pointer to the start of the underlying array, 
and freezes (see class strstreambuf) the stream. If the array was 
dynamically allocated, it is not automatically deleted, and is no 
longer expandable (see strstreambuf::freeze).<p>

Until str() is called, a dynamically allocated array is automatically 
freed when the streambuf is destroyed. After a call to str(), the 
programmer is responsible for freeing the array. 
<p><br>
</font>


<hr><!-- =========================================== -->

<a name="strstreambuf"><h2>Class strstreambuf</h2></a>

The strstreambuf class is derived from streambuf, specialized for 
memory-based (string-based) streams. A strstreambuf object uses a 
char array (string) as the source or destination of characters. 
Characters are fetched (input) from the array and consumed by 
(written to) the array. Unlike filebufs, strstreambuf provides 
storage but does not coordinate activity between the stream and the 
ultimate source and destination.<p>

Class streambuf defines the basic streambuf operations that 
strstreambuf uses. Pointers get and put point to the attached 
array; moving these pointer corresponds to incrementing or 
decrementing a char*. <p>

Memory based stream classes strstream, istrstream, and 
ostrstream use strstreambuf for stream memory operations.

<h3>strstreambuf Modes</h3>

A strstreambuf can be in one of two modes: dynamic or static. In 
dynamic mode, the source/ destination array is automatically 
allocated and expanded as needed to accomodate strings of any 
length. When more space is needed, a new reserve area is allocated 
and data from the old array are copied to it; the old array is deleted.<p>

In static mode, an array of fixed size that is allocated by the 
programmer is used. This array cannot be moved or changed to a 
new buffer, and is not deleted automatically.<p>

A dynamic strstreambuf can be frozen (made non-expandable). A 
frozen or static strstreambuf can be converted to a char* for 
use in expressions that require C-style strings. A frozen dynamic 
strstreambuf can be unfrozen (made expandable again).<p>
</font>

<h3>Member Functions of strstreambuf</h3>

Class strstreambuf is derived from streambuf, so you can use 
all the streambuf member functions on strstreambuf objects. 
The following functions are members of class strstreambuf.

<h3>strstreambuf constructors</h3>

<h4>Header</h4>

strstream.h


<h4>Prototype</h4>

<pre>
	strstreambuf();
	strstreambuf(int n);
	strstreambuf(void* (*alloc)(long), void (*del) (void*)); 
	strstreambuf(char* ptr, int len, char* putp = 0); 
</pre>

<h4>Description</h4>

strstreambuf() constructs an empty, dynamic, unfrozen 
strstreambuf object. Space for the string is allocated automatically as 
needed. If you know that some minimum number of characters will 
be inserted, you can avoid repeated allocation and deallocation of 
small arrays by either creating the buffer with constructor 
strstream::strstream(int) or using strstream::setbuf().<p>

strstreambuf(n) constructs an empty, dynamic, unfrozen 
strstreambuf object, with an initial buffer size of at least n bytes.<p>

strstreambuf(alloc, del) constructs an empty, dynamic, 
unfrozen strstreambuf object. Space for the string will be allocated 
automatically as needed. Rather than using new and delete, the 
programmer supplied functions alloc and del will be called. 
Function alloc must take a long parameter, the number of bytes 
to allocate; it must return a pointer to the allocated space (of type 
void*), or zero on failure. If alloc is null, new will be used. 
Function del must take a parameter of type void*, which will be a 
pointer value acquired from alloc; its return type is void. If del is 
null, delete will be used. When using this constructor, make sure 
alloc and del are compatible.<p>

strstreambuf(ptr, len, putp) constructs a static strstreambuf 
using the buffer pointed to by ptr. If len is positive the buffer is 
assumed to be len bytes in size, and operations will remain in that 
buffer area. If len is zero, ptr is assumed to point to a null-terminated 
string, and the area up to but not including the null byte 
will be used for the buffer. If len is negative, the buffer is assumed 
to be of unlimited length (a potentially dangerous mode). The get 
pointer will be initially set to ptr. The put pointer will be initially set 
to putp. If putp is not null, the initial get area will run from ptr to 
putp. If putp is null, stores will be treated as errors, and the initial 
get area will be the entire buffer. 

<h4>Example</h4>

Creates a buffer consisting of the supplied text without overwriting 
or expanding the data: 

<pre>
	strstreambuf greeting("Hello, world!", 0, 0); 
</pre>

Creates a buffer consisting of the supplied text; the data can be over-written 
from 'w' through '! ', but not expanded: 


<pre>
	char *hi = "Hello, world!";
	strstreambuf greeting(hi, 0, hi + 7); 
</pre>


Creates a buffer consisting of the supplied text. The "Hello" portion 
of the data can be read or overwritten; the remainder of the buffer is 
inaccesable: 

<pre>
	char *hi = "Hello, world!";
	strstreambuf greeting(hi, 5, hi); 
</pre>

<h3>strstreambuf::freeze</h3>

<h4>Header</h4>

strstream.h

<h4>Prototype</h4>

strstreambuf::freeze(int i = 1); 

<h4>Description</h4>

If i is non-zero, this function freezes the dynamic buffer. If i is zero, 
it unfreezes the buffer. Freezing prevents automatic deletion of the 
buffer, even when the strstreambuf is destroyed. It also prevents 
expansion of the buffer beyond its current size.<p> 

Typically, you freeze a buffer to permit taking a pointer to it that 
remains reliable until the buffer is explicitly unfrozen. Once 
unfrozen, a dynamic buffer can be automatically expanded and 
deleted. Freezing is irrelevant for a static buffer, since it is never 
automatically expanded or deleted.

<h3>strstreambuf::setbuf</h3>

<h4>Header</h4>

strstream.h

<h4>Prototype</h4>

streambuf *strstreambuf::setbuf(char *ptr, int len);

<h4>Description</h4>

If ptr is null, the value of len is saved, and the next dynamic mode 
buffer allocation will be at least len bytes. (This applies only to the 
next allocation; the value of len is then discarded.) The function 
returns a pointer to a strstreambuf, or nothing if ptr is not null.<p>

If ptr is not null, the request is ignored; replacing the buffer of any 
static or dynamic strstreambuf is not possible.<p>

Typically, use this function to force a suitably large allocation when 
a buffer was going to be expanded, avoiding potentially many small 
allocation and deallocation sequences. 

<h3>strstreambuf::str</h3>

<h4>Header</h4>

strstream.h

<h4>Prototype</h4>

char *strstreambuf::str(); 


<h4>Description</h4>

This function freezes ssbuf and returns a pointer to the beginning 
of the buffer. If ssbuf is in dynamic mode but the buffer is empty, 
the returned pointer might be null. 



<br><br><br><br>

</td></table>




<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

