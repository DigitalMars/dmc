
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - process.h
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:15 2006
</div>
</div>

<!-- Generated by Ddoc from process.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>process.h</h1>

<ul>
	<li><a href="#_beginthread"><b>_beginthread</b></a>
	<li><a href="#_c_exit"><b>_c_exit, _cexit</b></a>
	<li><a href="#_exec"><b>_exec Functions</b></a>
	<li><a href="#_endthread"><b>_endthread</b></a>
	<li><a href="#_getpid"><b>_getpid</b></a>
	<li><a href="#_spawn"><b>_spawn Functions</b></a>
</ul>

<hr><!-- =========================================== -->

<a name="_beginthread"><h2>_beginthread</h2></a>

<font size=3><b>
Header
</b><p>
process.h
<p>

<b>
Prototype
</b><p>
unsigned long _beginthread(void(* func)(void*), unsigned stack_size, void *arg); 
<p>

<b>
Description
</b><p>
This function creates a new thread of execution within the current process. Thread execution starts at the beginning of func. To terminate the thread correctly, func must call _endthread, freeing memory allocated by the run time library to support the thread.<p>

The operating system allocates a stack for the thread containing the number of bytes specified by stack_size. If stack_size is zero, the operating system creates a stack the same size as that of the main thread.<p>

The operating system passes arg to func when execution begins.  arg can be any 32-bit value cast to void*.
<p>

<b>
Return Value
</b><p>
Returns the operating system handle of the newly created thread. If unsuccessful, the function returns -1 and sets errno.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_endthread">_endthread</a><br>
<a href="stddef.html#_threadid">_threadid</a>
<p>

<b>
Example
</b><p><pre>
	/* 	Example for _beginthread
		Also demonstrates _endthread 

	      DBLCOPY. C

	Copies a file using double-buffering. There are
	two threads. One reads from the file, the other 
	writes. Since there are two buffers, the read-
	thread can read ahead into the second buffer 
	while the write-thread is still writing from the
	first buffer. Each thread goes into a wait while 
	its I/ O completes, allowing the other thread to
	resume. Two semaphores coordinate access to the 
	buffers. The full semaphore is signalled when
	the read-thread has filled a buffer. This wakes 
	up the write-thread so that it can write. The
	empty semaphore is signalled when the write-
	thread has written a buffer. This wakes up the
	read-thread so it can read another buffer. 
	*/

	#include &lt;process.h&gt;
	#include &lt;stdio.h&gt; 
	#include &lt;io.h&gt;
	#include &lt;fcntl.h&gt; 
	#include &lt;stdlib.h&gt;
	#include &lt;windows.h&gt; 


	static void error(char *action) 
	{
	   fprintf(stderr, "Error %s: %d\n", action, GetLastError()); 
	   exit(EXIT_FAILURE); 
	}

	static void status (char *action, int buffer) 
	{
	   printf("%s buffer %d\n", action, buffer + 1); 
	}

	static HANDLE source, dest, full, empty;
	static char buffer[2][0xffff]; 
	static int size[2];

	static void read_file(void *unused) 
	{
	   int code, i;
	   OVERLAPPED overlap; 

	   overlap.Offset = 0;
	   overlap.OffsetHigh = 0; 
	   overlap.hEvent = CreateEvent(NULL, FALSE, FALSE, "_beginth_event1");
	   if (overlap.hEvent == NULL)
	      error("creating read event"); 
	   for (i = 0; ; i = (i + 1) % 2) 
	   { 
	      if (WaitForSingleObject(empty, INFINITE) == -1) 
	          error("waiting for empty buffer");
	      status("Reading", i); 
	      if (!ReadFile(source, buffer[i], sizeof buffer[i], size + i, &overlap))
	         switch (GetLastError ()) 
		 {   
	         case ERROR_IO_PENDING:
		    if (WaitForSingleObject(overlap.hEvent, INFINITE) == -1) 
		       error("waiting for overlapped read"); 
		    break; 
		 case ERROR_HANDLE_EOF: 
		    break;
		 default:
		    error (" reading"); 
		 }
	      status("Done reading", i); 
	      ReleaseSemaphore(full, 1, NULL);
	      if (size[i] == 0) 
	         break;
	      overlap.Offset += size[i]; 
	   } 
	   _endthread (); 
	}

	static void write_file (void *unused) 
	{ 
	   int code, i, written;
	   OVERLAPPED overlap; 

	   overlap. Offset = 0;
	   overlap. OffsetHigh = 0; 
	   overlap.hEvent = CreateEvent(NULL, FALSE, FALSE, "_beginth_event2"); 
	   for (i = 0; ; i = (i + 1) % 2) 
	   { 
	      if (WaitForSingleObject(full, INFINITE) == -1) 
		 error("waiting for full buffer");
	      if (size[i] == 0) 
		 break;
	      status("Writing", i); 
	      if (!WriteFile(dest, buffer[i], size[i], &written, &overlap)) 
		 if (GetLastError() == ERROR_IO_PENDING) 
		 {  if (WaitForSingleObject(overlap.hEvent, INFINITE) == -1) 
		       error("waiting for overlapped write");
		 }
		 else 
		    error("writing"); 
	      status("Done writing", i); 
	      overlap.Offset += written; 
	      ReleaseSemaphore(empty, 1, NULL); 
	   } 
	   _endthread(); 
	}

	void main(int argc, char const *const argv[]) 
	{ 
	   HANDLE thread[2]; 
	   int code; 

	   if (argc != 3) 
	   {
	      fprintf(stderr, "Usage: DBLCOPY source-file destination-file\n"); 
	      exit(EXIT_FAILURE); 
	   }
	   printf("Copying %s to %s\n", argv[1], argv[2]); 

	   source = CreateFile(argv[1], GENERIC_READ, 
		    FILE_SHARE_READ, NULL, 
		    OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 
		    NULL); 
	   if (source == INVALID_HANDLE_VALUE) 
	      error("opening source file"); 
	   dest = CreateFile(argv[2], GENERIC_WRITE, 
		 FILE_SHARE_READ, NULL, 
		 CREATE_NEW, FILE_FLAG_OVERLAPPED, NULL); 
	   if (dest == INVALID_HANDLE_VALUE) 
	      error("opening destination file"); 

	   full = CreateSemaphore(NULL, 0, 2, "_beginth_sema1"); 
	   if (full == NULL) 
	      error("creating full semaphore"); 
	   empty = CreateSemaphore(NULL, 2, 2, "_beginth_sema2"); 
	   if (empty == NULL) 
	      error("creating empty semaphore"); 

	   thread[0] = (HANDLE)_beginthread(read_file, 0, NULL); 
	   if (thread[0] == INVALID_HANDLE_VALUE) 
	      error("creating read thread"); 
	   thread[1] = (HANDLE)_beginthread(write_file, 0, NULL); 
	   if (thread[1] == INVALID_HANDLE_VALUE) 
	      error("creating write thread");

	   if (WaitForMultipleObjects(2, thread, TRUE, INFINITE) == -1) 
	      error("waiting for threads");
 
	   if (!CloseHandle(source)) 
	      error("closing source file"); 
	   if (!CloseHandle(dest)) 
	      error("closing destination file"); 

	   printf("Done\n"); 
	}
</pre>

<b>
Output
</b><pre><p>
	C:\SC\EXAMPLES&gt; dblcopy bigfile bigcopy 
	Copying bigfile to bigcopy 
	Reading buffer 1 
	Done reading buffer 1 
	Reading buffer 2 
	Done reading buffer 2 
	Writing buffer 1 
	Done writing buffer 1 
	Writing buffer 2 
	Reading buffer 1 
	Done writing buffer 2 
	Done reading buffer 1 
	Reading buffer 2 
	Writing buffer 1 
	Done reading buffer 2 
	Done writing buffer 1 
	Writing buffer 2 
	Done writing buffer 2 
	Reading buffer 1 
	Done reading buffer 1 
	Done
</pre>

<hr><!-- =========================================== -->

<a name="_c_exit"><h2>_c_exit, _cexit</h2></a>

<font size=3><b>
Header
</b><p>
process.h
<p>

<b>
Prototype
</b><p>
void _c_exit(void);<br>
void _cexit(void);
<p>

<b>
Description
</b><p>
The _c_exit and _cexit functions perform cleanup operations and return without terminating the calling process. The _c_exit function performs a quick C library termination procedure and returns to the caller without processing registered exit functions (atexit or _onexit) or flushing buffers.<p>

In contrast, the _cexit function performs a complete C library termination procedure by calling registered exit functions in LIFO order, flushing all I/ O buffers, and closing all open streams before returning to the caller.<p>

Both functions restore interrupt vectors altered by the startup code.
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#abort">abort</a><br>
<a href="#atexit">atexit</a><br>
<a href="#_fatexit">_fatexit</a><br>
<a href="#_exec">_exec Functions</a><br>
<a href="#exit">exit</a><br>
<a href="#_exit">_exit</a><br>
<a href="#_spawn">_spawn Functions</a>
<p>

<b>
Example
</b><p><pre>
	/* 	Example for _c_exit and _cexit 
		Also demonstrates atexit 
	*/ 
	#include &lt;process.h&gt; 
	#include &lt;stdio.h&gt; 
	#include &lt;stdlib.h&gt; 

	void __cdecl near_exit_function(void) 
	{ 
	   printf (" In the atexit function\n"); 
	} 

	void main() 
	{ 
	   atexit (near_exit_function);
 
	   _c_exit(); 
	   printf (" Shouldn't have called the atexit 
		     function yet.\n"); 
	   _cexit(); 
	   printf (" Should have called the atexit 
		     function now.\n"); 
	}
</pre>

<b>
Output
</b><p>
Shouldn't have called the atexit function yet.<br> 
In the atexit function<br>
Should have called the atexit function now.<br>
In the atexit function


<hr><!-- =========================================== -->

<a name="_exec"><h2>_exec Functions</h2></a>

<font size=3><b>
Header
</b><p>
process.h
<p>

<b>
Prototype
</b>
<pre>
int _execl(const char *path, const char *arg0,... const char *argn, NULL);
int _execle(const char *path, const char *arg0,... const char *argn, NULL, const char *const *envp);
int _execlp(const char *path, const char *arg0,... const char *argn, NULL);
int _execlpe(const char *path, const char *arg0,... const char *argn, NULL);
int _execv(const char *path, const char *const *argv);
int _execve(const char *path, const char *const *argv, const char *const *envp);
int _execvp(const char *path, const char *const *argv);
int _execvpe(const char *path, const char *const *argv, const char *const *envp);
</pre>

<b>
Description
</b><p>
These functions load and execute a new child process by placing it 
in memory previously occupied by the calling process. Sufficient 
memory must be available.<p>

Argument path specifies the path name of the file executed as a 
child process. arg0 through argn is a list of pointers to arguments 
to be passed to the child process. argv is an array of pointers to 
arguments. envp is an array of pointers to environment settings. <p>

The base of each function is _exec, followed by one or more 
letters.<br> 
<dl>
<b>Letter/Meaning</b><br>
<dt>e
<dd>An array of pointers to environment arguments is explicitly 
passed to the child process. 
<dt>l
<dd>Command line arguments are passed individually to the 
function. 
<dt>p
<dd>Uses the PATH argument variable to find the file to be 
executed. 
<dt>v
<dd>Command line arguments are passed to the function as an 
array of pointers. 
</dl>
Files open when an _exec call is made remain open in the new 
process. In the _execl, _execlp, _execv, and _execvp calls, 
the child process inherits the parent's environment. The _execle, 
_execlpe, _execve, and _execvpe calls alter the enviroment for 
the child process by passing a list of environment settings through 
the envp argument. This argument is an array of character pointers; 
each element (except for the final element) points to a null-terminated 
string defining an environment variable.<p>

Each null-terminated string has the form<p>

NAME= value<p>
 
NAME is the environment variable name; value is the string value 
to which that variable is set. (value is not enclosed in double 
quotation marks.) The final element of the envp array must be 
NULL. When envp itself is NULL, the child process inherits the 
environment setttings of the parent process.<p>

A program executed with one of the _exec functions is always 
loaded into memory as if the "maximum allocation" in the program's 
 .exe file header is set to default value 0xFFFFH. You can use the 
EXEHDR utility to change the maximum allocation field of a 
program. However, if you do this and then invoke the program with 
one of the _exec functions, the program might behave differently 
from a program invoked directly from the operating-system 
command line or with one of the _spawn functions.<p>

By checking the first two bytes of a file, command. com determines 
if the file is an .exe file or a .com file. The _exec functions can 
execute a file named by any extension, as long as its content is 
executable. You can also execute .bat files<p>

The _exec calls do not preserve the translation modes of open files. 
If the child process uses files inherited from the parent, use the 
_setmode function to set the translation mode to the desired mode. <p>

You must flush or close all open files before an _exec call. 
<p>

<b>
Synonym
</b><p>
Functions: execl, execle, execlp, execlpe, execv, execve, execvp, execvpe 
<p>

<b>
Return Value
</b><p>
The _exec functions do not normally return to the calling process. 
If an exec function returns, an error occurred, the return value is -1, 
and errno is set to one of the following values:<p>
<dl>
<b>Value/Description</b>
<dt>E2BIG
<dd>The argument list exceeds the system limit. 
<dt>EACCES
<dd>The specified file has a locking or sharing 
violation. 
<dt>ENOENT
<dd>The file or path name not found. 
<dt>ENOMEM
<dd>Not enough memory is available to execute 
the child process. 
</dl>
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#abort">abort</a><br>
<a href="#atexit">atexit</a><br>
<a href="#_fatexit">_fatexit</a><br>
<a href="#exit">exit</a><br>
<a href="#_exit">_exit</a><br>
<a href="#_onexit">_onexit</a><br>
<a href="#_fonexit">_fonexit</a><br>
<a href="#_spawn">_spawn Functions</a><br>
<a href="#system">system</a>
<p>

<b>
Example
</b><p><pre>
	/* 	Example of _exec 
		dumparg. exe (see the _spawn function) must
		also be compiled to use this example 
	*/ 
	#include &lt;stdio.h&gt;
	#include &lt;stdlib.h&gt;
	#include &lt;process.h&gt;

	void main ()
	{ 
	   char argstr[128]; 
	   printf (" Enter parameters: ");
	   gets(argstr); 

	   if (_execlp (" dumparg. exe", "dumparg. exe",
		argstr, NULL) == -1) 
	   { 
		perror (" Could not spawn process"); 
		exit (EXIT_FAILURE);
	   } 
	} 
</pre>
<p>

<b>
Output
</b><p>
Enter parameters: Cat  Dog  Mouse  Shirt  Tie  Tail<p>
Cat<br>
Dog<br>
Mouse<br>
Shirt<br>
Tie<br>
Tail<br>

<hr><!-- =========================================== -->

<a name="_endthread"><h2>_endthread</h2></a>

<font size=3><b>
Header
</b><p>
process.h
<p>

<b>
Prototype
</b><p>
void _endthread (void);
<p>

<b>
Description
</b><p>
The _endthread function terminates a thread created by 
_beginthread. Always call _endthread from within the thread 
function rather than just returning from the thread function; 
_enthread frees data structures created by _beginthread. 
<p>

<b>
Return Value
</b><p>
None
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_beginthread">_beginthread</a><br>
<a href="stddef.html#_threadid">_threadid</a>
<p>



<hr><!-- =========================================== -->

<a name="_getpid"><h2>_getpid</h2></a>

<font size=3><b>
Header
</b><p>
process.h
<p>

<b>
Prototype
</b><p>
int _getpid(void); 
<p>

<b>
Description
</b><p>
The _getpid function returns the process identification number 
(process ID) for the calling process. The ID uniquely identifies a 
process. 
<p>

<b>
Synonym
</b><p>
Function:  getpid
<p>

<b>
Return Value
</b><p>
Both functions return the process ID. There is no error return. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#getpsp">getpsp</a>
<p>

<b>
Example
</b><p><pre>
	/* 	Example for _getpid */ 

	#include &lt;stdio.h&gt; 
	#include &lt;process.h&gt;

	void main () 
	{ 
	   printf (" The process id of this program is 
		     %d\n", getpid ()); 
	} 
</pre>

<b>
Output
</b><p>
The process id of this program is 7640 



<hr><!-- =========================================== -->

<a name="_spawn"><h2>_spawn Functions</h2></a>

<font size=3><b>
Header
</b><p>
process.h (for spawn and _spawn functions)<br>
stdio.h (for _spawn functions only) 
<p>

<b>
Prototype
</b>
<pre>
int _spawnl(int mode, char *filename, char *arg0,..., char *argn, NULL);
int _spawnle(int mode, char *filename, char *arg0,.., char *argn, NULL, char ** envp);
int _spawnlp(int mode, char *filename, char *arg0,..., char *argn, NULL);
int _spawnlpe(int mode, char *filename, char *arg0,..., char *argn, NULL, char ** envp);
int _spawnv(int mode, char *filename, char ** argv);
int _spawnve(int mode, char *filename, char ** argv, char ** envp);
int _spawnvp(int mode, char *filename, char ** argv);
int _spawnvpe(int mode, char *filename, char ** argv, char ** envp);
</pre>

<b>
Description
</b><p>
The _spawn functions load and execute a new child process. The 
current process may or may not continue to execute asynchronously. 
Creating a new subprocess requires enough memory in which both 
the child process and the current program can execute. <p>

The mode argument determines whether the child process runs 
asynchronously. Values for mode are: <p>
<dl>
<b>Value/Description</b>
<dt>_P_OVERLAY
<dd>Overlays parent process with child, which destroys the parent. This has the same effect as the _exec and exec functions. 
<dt>_P_WAIT
<dd>Suspends parent process until the child process has finished executing. 
</dl>
<p>
The filename argument specifies the program to execute. For 
spawnlp and spawnvp only, if the filename does not have a 
path and is not in the current directory, the environment variable 
PATH determines which directories to search for the file. The string 
pointed to by argv[0] is the name of the program to run. <p>

The command line passed to the spawned program is made up of 
the character strings, arg0 through argn, in the spawn call. The 
combined length of these strings must not exceed 128 characters. 
The argv argument is an array of character pointers. The last 
pointer in argv must be NULL to indicate the end of the list. <p>

Files that are open when a spawn call is made remain open in the 
child process. In the _spawnl, _spawnlp, _spawnv, and 
_spawnvp calls, the child process inherits the environment of the 
parent. The _spawnle, _spawnlpe, _spawnve, and _spawnvpe 
calls allow the user to alter the child process's environment by 
passing a list of environment settings using the envp argument. This 
argument is an array of character pointers; each pointer (except for 
the last one) points to a null-terminated string defining an 
environment variable. An environment variable has the form <p>

varname = value <p>

where varname is the variable name and value is the string value 
(not enclosed in quotation marks.) The last pointer in the array is 
NULL. When the envp argument is null, the child inherits the 
parent's environment settings. <p>

The _spawn functions can be used under Microsoft Windows. They 
use LoadModule to run the spawned process. If this fails an attempt 
is made to spawn a normal MS-DOS process. If a Windows 
application is spawned, the instance handle can be obtained using 
exec_instancehandleget. <p>

It is possible to specify how the spawned programwill be shown 
using the functions _exec_showset, _exec_showget and 
_exec_showreset.
<p>

<b>
Synonym
</b><p>
Functions: spawnl, spawnle, spawnlp, spawnlpe, 
spawnv, spawnve, spawnvp, spawnvpe 
<p>

<b>
Return Value
</b><p>
The return value indicates the exit status of the spawned program. A 
value of 0 indicates that the spawned program executed successfully. 
A positive value indicates that the spawned program executed, but 
was aborted or ended in error, the value returned is the exit status of 
the child process. A negative value indicates that the spawned 
program did not execute, and errno is set. <p>

Under Microsoft Windows, spawn returns the negated error code 
returned from LoadModule for compatibility with the C run-time 
library. The following error codes may be encountered: <p>
<dl>
<b>Error code/Description</b>
<dt>-2 				
<dd>File not found 
<dt>-3 				
<dd>Path not found 
<dt>-11 				
<dd>Invalid .exe file (for Windows) 
<dt>-13 				
<dd>DOS 4. 0 application 
<dt>-14 				
<dd>Unknown .exe type (may be DOS extended)
</dl> 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_exec">_exec Functions</a>
<p>

<b>
Example
</b><p><pre>
	/* 	Example for _spawn 
		Compile program to file: dumparg. exe 
	*/ 

	#include &lt;stdio.h&gt;

	void main (int argc, char *argv[]) 
	{ 
	   int i; 
	   printf ("There are %d command line 
	parameters\n", argc -1); 

	   for (i = 1; i &lt; argc; i++) 
	   { 
	      puts (argv[i]); 
	   } 
	} 

	/* 	Example of _spawn 
	   dumparg.exe must also be compiled to use 
	   this example 
	*/ 

	#include &lt;stdio.h&gt;
	#include &lt;stdlib.h&gt; 
	#include &lt;process.h&gt;

	void main () 
	{ 
	   char argstr[128]; 

	   printf (" Enter some parameters: "); 
	   gets(argstr); 

	   if (_spawnlp (_P_WAIT, "dumparg.exe", 
	      "dumparg.exe", argstr, NULL) == -1) 
	{
	   perror (" Could not spawn process"); 
	   exit (EXIT_FAILURE); 
	} 
} 
</pre>

<b>
Output
</b><p>
Enter some parameters: Dog Cat Tree House Fence Car Boat <br>
There are 7 command line parameters<br>
Dog <br>
Cat<br>
Tree <br>
House <br>
Fence <br>
Car <br>
Boat <br>




<br><br><br><br>

</td></table>





<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

