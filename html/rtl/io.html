
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<title>Digital Mars - Runtime Library - io.h
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/" target="_top"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>
| <a href="http://www.digitalmars.com/download/freecompiler.html" title="download C & C++ compiler">C/C++ Compiler</a>
| <a href="http://www.digitalmars.com/d/" title="D Programming Language">D</a>

	<div id="lastupdate">Last update Fri Apr 28 16:28:14 2006
</div>
</div>

<!-- Generated by Ddoc from io.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc" nowrap>
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/rtl">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="rtl.html"><b>Runtime Library<br>Reference</b></a><br><br>
</center>

    &#183; <a href="constants.html">Constants</a><br>
    &#183; <a href="datatypes.html">Data types</a><br>

<hr><b>Standard C</b><br>

    &#183; <a href="assert.html">assert.h</a><br>
    &#183; <a href="complex.html">complex.h</a><br>
    &#183; <a href="ctype.html" title="character classification">ctype.h</a><br>
    &#183; <a href="fenv.html">fenv.h</a><br>
    &#183; <a href="float.html">float.h</a><br>
    &#183; <a href="locale.html">locale.h</a><br>
    &#183; <a href="math.html" title="math and trig">math.h</a><br>
    &#183; <a href="setjmp.html">setjmp.h</a><br>
    &#183; <a href="signal.html">signal.h</a><br>
    &#183; <a href="stdarg.html">stdarg.h</a><br>
    &#183; <a href="stddef.html">stddef.h</a><br>
    &#183; <a href="stdio.html">stdio.h</a><br>
    &#183; <a href="stdlib.html">stdlib.h</a><br>
    &#183; <a href="string.html">string.h</a><br>
    &#183; <a href="time.html">time.h</a><br>
    <br>

<hr><b>Standard C++</b><br>
    &#183; <a href="iostream.html">IOstream</a><br>
    &#183; <a href="new.html">new</a><br>
    <br>

<hr><b>Win32</b><br>
    &#183; <a href="gc.html" title="Hans Boehm garbage collector">gc.h</a><br>
    <br>

<hr><b>DOS, DOS32, Win16</b><br>
    &#183; <a href="bios.html" title="interface to BIOS API">bios.h</a><br>
    &#183; <a href="cerror.html" title="critical errors">cerror.h</a><br>
    &#183; <a href="disp.html" title="direct access to video display">disp.h</a><br>
    &#183; <a href="dos.html" title="interface to DOS API">dos.h</a><br>
    &#183; <a href="dos2.html">dos.h part 2</a><br>
    &#183; <a href="emm.html" title="expanded memory">emm.h</a><br>
    &#183; <a href="handle.html" title="handle pointers">handle.h</a><br>
    &#183; <a href="int.html" title="interrupt functions">int.h</a><br>
    &#183; <a href="msmouse.html" title="DOS mouse functions">msmouse.h</a><br>
    &#183; <a href="sound.html" title="interface to PC speaker">sound.h</a><br>
    &#183; <a href="swap.html">swap.h</a><br>
    &#183; <a href="tsr.html" title="Terminate Stay Resident functions">tsr.h</a><br>
    &#183; <a href="winio.html" title="Andrew Schulman's winio library">winio.h</a><br>
    <br>

<hr><b>Other C</b><br>
    &#183; <a href="bitops.html" title="access to CPU bit instructions">bitops.h</a><br>
    &#183; <a href="conio.html" title="console I/O">conio.h</a><br>
    &#183; <a href="controlc.html" title="control C">controlc.h</a><br>
    &#183; <a href="direct.html" title="directories">direct.h</a><br>
    &#183; <a href="fltpnt.html">fltpnt.h</a><br>
    &#183; <a href="io.html" title="low level file I/O">io.h</a><br>
    &#183; <a href="page.html" title="suballocate blocks of memory">page.h</a><br>
    &#183; <a href="process.html">process.h</a><br>
    &#183; <a href="search.html">search.h</a><br>
    &#183; <a href="sys-stat.html">sys\stat.h</a><br>
    &#183; <a href="tabsize.html">tabsize.h</a><br>
    &#183; <a href="../ctg/trace.html" title="Trace Dynamic Profiling">trace.h</a><br>
    &#183; <a href="time.html">utime.h</a><br>
    &#183; <a href="unmangle.html">unmangle.h</a><br>
    &#183; <a href="util.html">util.h</a><br>
    <br>

<hr><b>Other C++</b><br>
    &#183; <a href="regexp.html" title="regular expressions">regexp.h</a><br>
    &#183; <a href="oldcomplex.html">class complex</a><br>
    <br>

</small>

<hr>

</td>
<td valign="top">


<h1>io.h</h1>

<ul>
	<li><a href="#_access"><b>_access</b></a>
	<li><a href="#_chmod"><b>_chmod</b></a>
	<li><a href="#_chsize"><b>_chsize</b></a>
	<li><a href="#_close"><b>_close</b></a>
	<li><a href="#_commit"><b>_commit</b></a>
	<li><a href="#_creat"><b>_creat</b></a>
	<li><a href="#_dup"><b>_dup</b></a>
	<li><a href="#_dup2"><b>_dup2</b></a>
	<li><a href="#_eof"><b>_eof</b></a>
	<li><a href="#_filelength"><b>_filelength</b></a>
	<li><a href="#_isatty"><b>_isatty</b></a>
	<li><a href="#_locking"><b>_locking</b></a>
	<li><a href="#_lseek"><b>_lseek</b></a>
	<li><a href="#_mktemp"><b>_mktemp</b></a>
	<li><a href="#_open"><b>_open</b></a>
	<li><a href="#_read"><b>_read</b></a>
	<li><a href="#_setmode"><b>_setmode</b></a>
	<li><a href="#_sopen"><b>_sopen</b></a>
	<li><a href="#_tell"><b>_tell</b></a>
	<li><a href="#_write"><b>_write</b></a>
	<li><a href="#_umask"><b>_umask</b></a>
	<li><a href="#_unlink"><b>_unlink</b></a>
	<li><a href="#filesize"><b>filesize</b></a>
	<li><a href="#getDS"><b>getDS</b></a>
	<li><a href="#getftime"><b>getftime</b></a>
	<li><a href="#lock"><b>lock</b></a>
	<li><a href="#remove"><b>remove</b></a>
	<li><a href="#rename"><b>rename</b></a>
	<li><a href="#setftime"><b>setftime</b></a>
	<li><a href="#unlock"><b>unlock</b></a>
</ul>

<hr><!-- =========================================== -->

<a name="_access"><h2>_access</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br>
errno.h 
<p>

<b>
Prototype
</b><p>
int _access(char *path, int mode); 
<p>

<b>
Description
</b><p>
_access determines whether the file or directory specified by path 
exists and can be accessed in the file mode specified by mode. 
Values for mode can be one or more of the following OR'ed 
together:<p>
<dl>
<dt>F_OK or 0 
<dd>Check for existence 
<dt>X_OK or 1 
<dd>Check for execute permission 
<dt>W_OK or 2 
<dd>Check for write permission 
<dt>R_OK or 4 
<dd>Check for read permission 
</dl> <p>


With directories, _access determines only whether the specified 
directory exists; in DOS, all directories have read and write access. <p>

<b>
Synonym 
</b><p>
Function: access 
<p>

<b>
Return Value
</b><p>
Returns 0 if the file exists and can be accessed in mode. A return 
value of -1 means that the file does not exist or cannot be accessed 
in mode, and errno is set to one of the following: <p>
<dl>
<dt>EACCES 
<dd>Access denied 
<dt>ENOENT 
<dd>File or path name not found 
</dl>
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_chmod">_chmod</a><br>
<a href="sys-stat.html#_fstat">_fstat</a><br>
<a href="#_open">_open</a><br>
<a href="sys-stat.html#_stat">_stat</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/*	 Example for _access	 */ 

#include &lt;io.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

void main() 
{   
   char search[32]; 

   printf ("Enter a file name: "); 
   scanf ("%s", search); 

   /* Check for existence only */

   if ((_access (search, 0) ) == -1) 

      /* if access is unsuccessful, errno is set*/ 
      perror ("ERROR accessing file"); 

   else
      printf ("File '%s' found.\n", search); 
} 
</pre>

<b>
Output
</b><p>

If the file does not exist:

<pre class="console">Enter a file name: temp.dat
ERROR accessing file: No such file or directory
</pre>

If the file does exist:
 
<pre class="console">Enter a file name: temp.dat
File 'temp.dat' found.
</pre>


<hr><!-- =========================================== -->

<a name="_chmod"><h2>_chmod</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br>
errno.h<br>
sys\stat.h<br> 
sys\types
<p>

<b>
Prototype
</b><p>
int _chmod (const char *pathname, int pmode); 
<p>

<b>
Description
</b><p>
_chmod changes the permission on a file, specified by pathname, to the permissions specified by pmode. The user must have write permission for the file. The following values are valid for pmode:<br>
<dl>
<dt>_S_IREAD 
<dd>Read permission 
<dt>_S_IWRITE 
<dd>Write permission (implies file can be deleted)
</dl><p>
 
You can also logically OR the values indicate read and write access by specifying _S_IREAD | _S_IWRITE. However, because all files are always readable, the modes _S_IWRITE and _S_IREAD | _S_IWRITE are equivalent. 
<p>

<b>
Synonym
</b><p>
Function: chmod<br>
Modes: S_IREAD, S_IWRITE
<p>

<b>
Return Value
</b><p>
0 if successful. Otherwise -1, and errno is set to ENOENT, and _doserror is set to the OS error code.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for _chmod 	*/ 

#include &lt;fcntl.h&gt; 
#include &lt;io.h&gt; 
#include &lt;sys\stat.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 

char *pathname = "temp.dat"; 

void main() 
{   
   int result; 

   result = _chmod (pathname, S_IREAD| S_IWRITE); 

   if (result == 0) 
      printf ("Permission on file %s changed\n", 
		pathname); 
   else 
      perror("Can't change file"); 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Permission on file temp changed
</pre>

or
 
<pre class="console">Can't change file: No such file or directory 
</pre>

<hr><!-- =========================================== -->

<a name="_chsize"><h2>_chsize</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br> 
errno 
<p>

<b>
Prototype
</b><p>
int _chsize(int handle, long size); 
<p>

<b>
Description
</b><p>
The _chsize function truncates or extends an open file. The argument handle is the handle of the file to truncate or extend and size is the new length of the file, in bytes. If the specified size is shorter than the existing file, the file will be truncated. If the specified size is longer than the existing file, the file will be extended and null characters ('\0') are appended. 
<p>

<b>
Synonym
</b><p>
Function: chsize 
<p>

<b>
Return Value
</b><p>
0 if successful. A return value of -1 indicates an error and _chsize sets errno to one of the following values:<br>
<dl>
<dt>EACCESS 
<dd>Specified file is locked against access. 
<dt>EBADF 
<dd>Specified file is read-only or an invalid file handle. 
<dt>ENOSPC 
<dd>No space is left on device.
</dl>
<p>

<b>
See Also
</b><p>
<a href="#filesize">filesize</a><br>
<a href="#_filelength">_filelength</a>
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for _chsize 
	Also demonstrates _open, fopen 
*/ 
#include &lt;dos.h&gt; 
#include &lt;fcntl.h&gt; 
#include &lt;io.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 

void main() 
{   
   int fd; 
   FILE *fp; 
   char *fname[2] = {" file1"," file2"}; 
   long sizes[2] = {10000l, 20000l}; 

   fd = _open (fname[0], O_CREAT| O_WRONLY); 
   if (fd == -1) perror ("No fd"); 
   fp = fopen (fname[1]," wb");

   _chsize (fd, sizes[0]); 
   _chsize (fileno(fp), sizes[1]); 

}
</pre>

<b>
Output
</b><p>
This program creates two files of the given size in the directory from<br>
which it is run.


<hr><!-- =========================================== -->

<a name="_close"><h2>_close</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br>
errno.h
<p>

<b>
Prototype
</b><p>
int _close(int handle);
<p>

<b>
Description
</b><p>
The _close function closes the file associated with file descriptor handle handle, freeing the file descriptor for use by another file.  _close does not write a Ctrl-Z (EOF) character at the end of file.
<p>

<b>
Synonym
</b><p>
Function: close
<p>

<b>
Return Value
</b><p>
0 if successful. Otherwise, -1 and errno is set to EBADF, to indicate an invalid file-handle argument, and _doserrno is set to the OS error code.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_creat">_creat</a><br>
<a href="#_open">_open</a><br>
<a href="#_unlink">_unlink</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for _close and _open 	*/ 

#include &lt;dos.h&gt; 
#include &lt;fcntl.h&gt; 
#include &lt;io.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 

void main() 
{   
   int fd, result; 

   fd = _open ("temp.dat", O_CREAT); 
   if (fd &lt; 0) 
   {   
      perror("Can't create temp.dat"); 
   } 
   else 
   {   
      printf ("Created temp.dat\n"); 
      result = _close (fd); 
      printf ("Close() result code is %d\n", 
		result); 
   } 

}
</pre>

<b>
Output
</b><p>
<pre class="console">Created temp.dat
Close() result code is 0
</pre>


<hr><!-- =========================================== -->

<a name="_commit"><h2>_commit</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br>
errno.h
<p>

<b>
Prototype
</b><p>
int _commit(int handle); 
<p>

<b>
Description
</b><p>
The _commit function forces the operating system to write the file indicated by handle to disk. This function causes the file to be flushed immediately.
<p>

<b>
Return Value
</b><p>
Returns 0 if the file is successfully flushed to disk. Otherwise, returns -1, errno is set to EBADF, indicating an invalid handle argument, and _doserrno is set to the OS error code.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_creat">_creat</a><br>
<a href="#_open">_open</a><br>
<a href="#_read">_read</a><br>
<a href="#_write">_write</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for _commit 	*/ 

#include &lt;fcntl.h&gt; 
#include &lt;io.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 

void main() 
{   
    int fd, result; 
    char *buf = "Hello from Digital Mars"; 

    fd = open ("temp.dat", (O_CREAT| O_RDWR)); 
    write (fd, buf, 20); 

    result = _commit(fd); 

    if (result == 0) 
       printf ("Buffer successfully flushed to disk\n"); 
    else 
       perror("ERROR flushing buffer"); 
}
</pre>

<b>
Output
</b><p>
This program overwrites the contents of file temp.dat with the string:<p>

<pre>
"Hello from Digital Mars".
</pre>

<hr><!-- =========================================== -->

<a name="_creat"><h2>_creat</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br>
errno.h<br>
sys\stat.h<br> 
sys\types.h
<p>

<b>
Prototype
</b><p>
int _creat(const char *name, int pmode); 
<p>

<b>
Description
</b><p>
The _creat function can either create a new file or open and truncate an existing file. The permission setting, pmode, sets the new file's read, write, and execute permission after the file is closed for the first time. pmode values, defined in stat.h are:<br>
<dl>
<dt>_S_IREAD 
<dd>Read permission, owner 
<dt>_S_IWRITE 
<dd>Write permission, owner
</dl><p>

To specify both read and write, logically OR the values (_S_IREAD | _S_IWRITE). Note that _creat can open the file with read/ write permission regardless of the setting of pmode. The pmode takes effect only after the file has been closed for the first time. MS-DOS does not allow write-only permission. Therefore, modes _S_IWRITE and _S_IREAD | _S_IWRITE are equivalent.
<p>

<b>
Synonym
</b><p>
Function: creat<br>
Modes: S_IREAD, S_IWRITE<br>
<p>

<b>
Return Value
</b><p>
The file handle for the new file. If unsuccessful, returns -1 and sets errno, defined in errno.h, to one of the following:<br>
<dl>
<dt>EACCES 
<dd>Permission to access the file or a directory on the path has been denied. 
<dt>EAGAIN 
<dd>The specified file exists, and has a locking or sharing violation.
<dt>EMFILE 
<dd>Too many open files. 
<dt>ENOENT 
<dd>The file or path name can not be found.
</dl><p>

_doserrno is set to the OS error code.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#dos_creat">dos_creat</a><br>
<a href="#_close">_close</a><br>
<a href="#fopen">fopen</a><br>
<a href="#_open">_open</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for _creat 	*/ 

#include &lt;io.h&gt; 
#include &lt;sys\stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 

void main() 
{   
   int fp; 

   fp = _creat ("file.dat", S_IREAD| S_IWRITE);

   if (fp == -1) 
      printf ("Cannot create file.dat\n"); 
   else 
      printf ("File.dat successfully created\n"); 
}
</pre>

<b>
Output
</b><p>
<pre class="console">File.dat successfully created
</pre>

<hr><!-- =========================================== -->

<a name="_dup"><h2>_dup</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
int _dup(int fd); 
<p>

<b>
Description
</b><p>
The _dup function allows a second file handle to be associated with 
a currently open file. Once associated, any of the file handles can be 
used to carry out operations on the file. The access mode for the file 
is unchanged by the assignment of a new file handle. <p>

The function causes a new file handle to be returned and associated 
with the file connected to the handle in the fd argument. <p>

This function differs slightly from the _dup2 function. 
<p>

<b>
Synonym
</b><p>
Function: dup 
<p>

<b>
Return Value
</b><p>
Returns the new file handle. If unsuccessful returns -1 if and sets 
errno to EBADF (invalid file handle) or EMFILE (no more file 
handles available.) 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_close">_close</a><br>
<a href="#_creat">_creat</a><br>
<a href="#_dup2">_dup2</a><br>
<a href="#_open">_open</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/*	Example for _dup, _dup2 */ 

#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt; 
#include &lt;io.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{   
  int file1, file2, file3;
  int result; 

  _dos_open ("temp.dat", _O_CREAT|_O_RDWR,
		&file1); 

  _dos_write(file1, "This is an example. ", 21,
		&result); 

  file2 = _dup (file1);
  _dup2 (file1, file3); 

  _dos_write(file1, "This is example 2. ", 20,
		&result); 
  _dos_write(file1, "This is example 3. ", 20,
		&result); 
  _dos_close (file1); 
} 
</pre>

<b>
Output
</b><p>
This program produces no screen output. It writes the following 
string to the file temp.dat: <p>

<pre>
This is an example. This is example 2. This is example 3. 
</pre>


<hr><!-- =========================================== -->

<a name="_dup2"><h2>_dup2</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
int dup2 (int fdl, int fd2); 
<p>

<b>
Description
</b><p>
The _dup2 function is like the _dup function except that it causes 
the file handle in the fd2 argument to be associated with the file 
connected to the handle in the fd1 argument. 
<p>

<b>
Synonym
</b><p>
Function: dup2 
<p>

<b>
Return Value
</b><p>
Returns 0. If unsuccessful, returns -1 and sets errno to EBADF 
(invalid file handle) or EMFILE (no more file handles available.) 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_dup">_dup</a>
<p>


<hr><!-- =========================================== -->

<a name="_eof"><h2>_eof</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
int _eof(int handle); 
<p>

<b>
Description
</b><p>
The _eof function determines if the end of the file associated with 
the handle argument has been reached. 
<p>

<b>
Synonym
</b><p>
Function: eof
<p>

<b>
Return Value
</b><p>
Returns 1 if the current position is end-of-file; returns 0 if the current 
position is elsewhere. If an error occurs, -1 is returned and errno is 
set to EBADF (invalid file handle). 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#clearerr">clearerr</a><br>
<a href="#feof">feof</a><br>
<a href="#ferror">ferror</a><br>
<a href="#perror">perror</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for _eof
	Also demonstrates _dos_open, _dos_read 
*/ 
#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;io.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main()
{   
   int handle, count, total = 0;
   int result; 
   char buf[10]; 

   result = _dos_open ("temp.dat", _O_RDONLY,
			&handle); 
   if (result == 0)
   {   
	while (!(_eof(handle)))
	{   

	   count = read (handle, buf, 10);
	   if (count !=-1 ) 
		total += count;
	} 

	printf ("Number of bytes read = %d\n", total); 
	_dos_close (handle);
   } 
   else
        perror("Error opening file"); 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Number of bytes read = 61 
</pre>

<hr><!-- =========================================== -->

<a name="_filelength"><h2>_filelength</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
long _filelength(int fd); 
<p>

<b>
Description
</b><p>
The _filelength function returns the length in bytes of the file 
associated with the file descriptor fd. The fd argument must point 
to a file which is already open. The _filelength function differs 
from filesize in that it is used on a file that is already open. 
<p>

<b>
Synonym
</b><p>
Function: filelength 
<p>

<b>
Return Value
</b><p>
The length of the file in bytes as a long integer. The current read/ 
write position within the file is unaltered. In addition, if there is an 
error, these functions return a value of -1 and set errno to EBADF. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#filesize">filesize</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for _filelength() */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;io.h&gt;
#include &lt;fcntl.h&gt;

void main ()
{   
   int fh;
   char fname[_MAX_PATH]; 
   long len; 

   printf ("Enter filename: ");
   gets (fname); 

   if ((fh = _open (fname, _O_RDONLY)) &lt; 0)
   {   
	perror ("Error opening file");
	exit (EXIT_FAILURE); 
   } 

   len = _filelength(fh);
   printf ("The file length is %ld bytes\n", 
	     len);
   _close(fh); 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Enter filename: _filelen.c
The file length is 469 bytes 
</pre>

<hr><!-- =========================================== -->

<a name="_isatty"><h2>_isatty</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
int _isatty(int fd); 
<p>

<b>
Description
</b><p>
The _isatty function determines if the handle fd is associated 
with a character device such as a terminal, printer, or a serial port. 
<p>

<b>
Synonym
</b><p>
Function:  isatty
<p>

<b>
Return Value
</b><p>
Returns a non-zero value if the device is a character device or a zero 
if it is not. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="sys-stat.html#_fstat">_fstat</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for _isatty 

	_ISATTY.C 
*/ 

#include &lt;stdio.h&gt;
#include &lt;io.h&gt;

void main () 
{   
   if (_isatty (fileno (stdin))) 
      printf ("stdin is connected to the 
		keyboard\n"); 
   else 
      printf ("stdin is connected to a file\n"); 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">C:\SC\EXAMPLES&gt;_isatty
stdin is connected to the keyboard

C:\SC\EXAMPLES&gt;_isatty &lt;_isatty.c
stdin is connected to a file
</pre>


<hr><!-- =========================================== -->

<a name="_locking"><h2>_locking</h2></a>

<font size=3><b>
Header
</b><p>
sys\locking.h<br>
io.h
<p>

<b>
Prototype
</b><p>
int _locking(int fd, int mode, long size); 
<p>

<b>
Description
</b><p>
The _locking function locks or unlocks a section of the file 
associated with file handle fd. This operation locks records in files 
that are shared by multiple applications in a multi-tasking or network 
environment. Locking a section of the file prevents other 
applications from reading or writing that section while it is being 
updated. The section is then unlocked to allow other applications to 
read and write to it. The file is locked from the current position of 
the file pointer for the next size bytes. The mode argument 
specifies which locking functions to apply:<p>
<dl>
<b>Value/Description</b>
<dt>_LK_LOCK, 
_LK_RLCK 
<dd>Locks the specified number of bytes. If they cannot be locked it will retry after 1 second. This is repeated until 10 attempts have failed, at which point the function will return an error. 
<dt>_LK_NBLCK, 
_LK_NBRLCK 
<dd>Locks the specified number of bytes. If they cannot be locked, returns an error. 
<dt>_LK_UNLCK 
<dd>Unlocks the specified number of bytes. The file pointer and size must have exactly the same values as when the section was locked. 
</dl>
<p>
Multiple regions of a file can be locked, but no regions may overlap. 
A call to locking, unlocks no more than one region. To use locking, 
share. exe must be loaded. 
<p>

<b>
Synonym
</b><p>
Function: locking
<p>

<b>
Return Value
</b><p>
Returns 0 if successful. If an error occurs, returns -1 and errno is set to one of the following values:<p>
<dl>
<b>Value/Meaning</b>
<dt>EACCES 
<dd>Locking violation (file already locked or unlocked) 
<dt>EBADF 
<dd>Invalid file handle 
<dt>EDEADLOCK 
<dd>Locking violation. Returned when _LK_LOCK or 
_LK_RLCK is specified and file cannot be locked 
after 10 attempts 
<dt>EINVAL 
<dd>Invalid argument to function 
</dl>
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#lock">lock</a><br>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example of _locking /* 

#include &lt;dos.h&gt; 
#include &lt;io.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;
#include &lt;sys\locking.h&gt; 
#include &lt;sys\types.h&gt;
#include &lt;fcntl.h&gt;

void main () 
{   
   int fd; 

   if ((fd = _open("temp.fil",_O_RDONLY))== -1) 
   {   
      perror ("Error opening file"); 
      exit (EXIT_FAILURE); 
   } 
   _lseek (fd, 0L, SEEK_SET); 
   if ((_locking (fd,_LK_NBLCK, 20L)) == -1) 
   {   
      perror ("Locking operation failed"); 
      exit (EXIT_FAILURE); 
   } 
   else 
   {   
      printf ("Locking operation successful\n"); 
      _lseek (fd, 0L, SEEK_SET); 
      _locking (fd, _LK_UNLCK, 20L); 
   } 
   close(fd); 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Locking operation successful
</pre>


<hr><!-- =========================================== -->

<a name="_lseek"><h2>_lseek</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
long _lseek(int fd, long offset, int mode); 
<p>

<b>
Description
</b><p>
The _lseek function moves the read/ write pointer for a file given 
by file descriptor fd. The pointer is moved offset bytes from the 
position indicated by mode. Values for mode are: <br>
<dl>
<b>Macro/Description</b>
<dt>SEEK_SET 
<dd>Beginning of the file. 
<dt>SEEK_CUR 
<dd>Current location. 
<dt>SEEK_END 
<dd>End of the file. 
</dl>
<p>

<b>
Synonym
</b><p>
Function:  lseek
<p>

<b>
Return Value
</b><p>
Returns the offset in bytes of the new position from the beginning of 
the file. A -1L is returned on error, and errno is set to EBADF or 
EINVAL. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#fseek">fseek</a><br>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example of _lseek */ 

#include &lt;io.h&gt;
#include &lt;dos.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt; 

void main () 
{   
   int fp; 
   long offset, lpos; 

   fp = _open ("\\sc\\include\\io.h", _O_RDONLY); 
   if (fp &lt; 0) 
      perror ("Error opening file"); 
   else 
   {   
      offset = 35L; 
      lpos = _lseek (fp, offset, SEEK_SET); 
      printf ("Position of seek = %ld\n", lpos); 
      offset = 10L; lpos = _lseek (fp, offset, SEEK_CUR); 
      printf ("Position of seek = %ld\n", lpos); 
      offset = 0L; 
      lpos = _lseek (fp, offset, SEEK_END); 
      printf ("Position of seek = %ld\n", lpos); 
      close (fp); 
   } 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Position of seek = 35
Position of seek = 45
Position of seek = 2759
</pre>



<hr><!-- =========================================== -->

<a name="_mktemp"><h2>_mktemp</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
char *_mktemp(char *template);  
<p>

<b>
Description
</b><p>
The _mktemp function generates unique filenames from the 
template specified in the template argument. The argument has 
the following form:<p>

baseXXXXXX<p>
 
The base is the part of the filename that you supply; the X's are 
placeholders for the part that _mktemp generates. The generated 
filename contains an alphanumeric character, followed by a 5-digit 
value that identifies the calling process. The first time _mktemp is 
called with a given template, the function selects 0 as the first 
alphanumeric character. In subsequent calls, the function uses the 
lowercase letters 'a' through 'z'.<p>

The _mktemp does not create or open files.
<p>

<b>
Synonym
</b><p>
Function:  mktemp
<p>

<b>
Return Value
</b><p>
These functions return a pointer to the modified template.  The return value is NULL if the template is specified incorrectly or if no more unique names can be created from the given template.
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#fopen">fopen</a><br>
<a href="#_getpid">_getpid</a><br>
<a href="#_open">_open</a><br>
<a href="#_tempnam">_tempnam</a><br>
<a href="#tmpfile">tmpfile</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example of _mktemp */ 

#include &lt;io.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main ()
{   
   char template[] = "tzXXXXXX";
   char names[27][sizeof (template)]; 
   char *result;
   int i; 
   FILE *fp; 

   for (i = 0; i &lt; sizeof (names) / sizeof
	   (names[0]); i++) 
   {
      strcpy (names[i], template); 
      result = _mktemp (names[i]);
      printf ("mktemp [%2d] = \"%s\"\n", i, 
	   result); fp = fopen(result, "w"); 
      if (fp == NULL)
      {   
	   printf ("unable to create file 
		    \"%s\"\n", result); 
	   exit(EXIT_FAILURE);
      } 
      fclose(fp);
   } 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">mktemp [0] = "tz008437"
mktemp [1] = "tza08437" 
mktemp [2] = "tzb08437"
mktemp [3] = "tzc08437" 
mktemp [4] = "tzd08437"
mktemp [5] = "tze08437" 
mktemp [6] = "tzf08437"
mktemp [7] = "tzg08437" 
mktemp [8] = "tzh08437"
mktemp [9] = "tzi08437" 
mktemp [10] = "tzj08437"
mktemp [11] = "tzk08437" 
mktemp [12] = "tzl08437"
mktemp [13] = "tzm08437" 
mktemp [14] = "tzn08437"
mktemp [15] = "tzo08437" 
mktemp [16] = "tzp08437"
mktemp [17] = "tzq08437" 
mktemp [18] = "tzr08437"
mktemp [19] = "tzs08437" 
mktemp [20] = "tzt08437"
mktemp [21] = "tzu08437" 
mktemp [22] = "tzv08437"
mktemp [23] = "tzw08437" 
mktemp [24] = "tzx08437"
mktemp [25] = "tzy08437" 
mktemp [26] = "tzz08437" 
</pre>



<hr><!-- =========================================== -->

<a name="_open"><h2>_open</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br>
fcntl.h<br>
sys\stat.h (for creating a file) <br>
sys\types.h
<p>

<b>
Prototype
</b><p>
int _open(const char *file, int oflag[, int pmode]); 
<p>

<b>
Description
</b><p>
These functions open a file for reading, writing, or appending. The 
*file argument is the name of the file to open. <p>

Argument oflag specifies the operation allowed. It can be one or 
more of the following flags OR'ed together: <p>
<dl>
<b>Flag/Operation performed</b>
<dt>_O_APPEND 	
<dd>Position file pointer to end 
<dt>_O_BINARY 	
<dd>Open file in binary mode 
<dt>_O_CREAT 	
<dd>Create file if it does not exist 
<dt>_O_EXCL 	
<dd>Used with O_CREAT, returns an error if file exists 
<dt>_O_RDONLY 	
<dd>Open file for reading only 
<dt>_O_RDWR 	
<dd>Open file for reading and writing 
<dt>_O_TEXT 	
<dd>Open file in text mode 
<dt>_O_TRUNC 	
<dd>Truncates existing file 
<dt>_O_WRONLY 	
<dd>Opens file for writing only 
</dl>
<p>

The pmode argument, which signifies permission mode, is required 
only when you are creating a file by specifying the flag O_CREAT or 
_O_CREAT. If you do not indicate permission mode, the open 
function might pull random values from the stack. If the file specified 
in the file argument exists (you are not creating a new file), the 
pmode argument is ignored. The pmode argument can be one or 
more of the following flags OR'ed together: <p>
<dl>
<b>Flag/Permission</b>
<dt>_S_IWRITE 
<dd>Permit writing 
<dt>_S_IREAD 
<dd>Permit reading 
</dl><p>
The pmode flags are found in the sys\stat.h file. 
<p>

<b>
Synonym
</b><p>
Function:  open<br>
Flags: O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, 
O_TRUNC, O_WRONLY, S_IWRITE, S_IREAD 
<p>

<b>
Return Value
</b><p>
Both functions return a file handle for the opened file. If an error 
occurs, -1 is returned and variable errno is set to one of the 
following values: <p>
<dl>
<dt>EEXIST 
<dd>File already exists 
<dt>EINVAL 
<dd>Invalid oflag or pmode argument 
<dt>EMFILE 
<dd>No more file handles available 
<dt>ENOENT 
<dd>File or path name not found 
</dl>
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_close">_close</a><br>
<a href="#_sopen">_sopen</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example of _open */ 

#include &lt;dos.h&gt;
#include &lt;io.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;

void main ()
{   

   int fd; char fn[_MAX_PATH]; 
   printf ("Enter a filename: ");
   scanf ("%s", fn); 

   fd = _open(fn, _O_RDONLY);
   if (fd == -1) 
   {
      printf ("Cannot open file \"%s\"\n", fn); 
      exit (EXIT_FAILURE);
   } 
   printf ("File \"%s\" opened successfully", fn); 
   _close(fd);
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Enter a filename: _open.c
File "_open.c" opened successfully
</pre>


<hr><!-- =========================================== -->

<a name="_read"><h2>_read</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
int _read(int fd, void *buffer, unsigned int len); 
<p>

<b>
Description
</b><p>
The _read function gets the number of bytes specified in len from 
the file associated with file descriptor fd. The bytes are read into 
buffer. After the read operation, the pointer points to the next 
unread byte. 
<p>

<b>
Return Value
</b><p>
Returns the number of characters actually read, which may be less 
than len if EOF was encountered or if the file was opened in text 
mode. If an error occurs, -1 is returned and errno is set to EBADF 
(invalid file handle). Returns 0 if an attempted read occurs at EOF. <p>

If a file is opened in text mode, the return value might not 
correspond to the number of bytes actually read. In text mode, each 
carriage-return-line-feed pair is replaced with a single line-feed 
character. Only the single line-feed character is counted in the return 
value. Also, in text mode, a CTRL/ Z character is treated as an end-of-file 
indicator. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
Synonym
</b><p>
Function:  read
<p>

<b>
See Also
</b><p>
<a href="#_creat">_creat</a><br>
<a href="#_open">_open</a><br>
<a href="#_write">_write</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example of _read */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;dos.h&gt;
#include &lt;io.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;

#define BUFSIZE 255 

void main ()
{   
   char buffer[BUFSIZE + 1], fn[_MAX_PATH];
   int fd, numread; 

   printf ("Enter a filename: ");
   scanf ("%s", fn); 

   if ((fd = _open (fn, _O_RDONLY)) == -1)
   {   
      perror ("Open failed");
      exit (EXIT_FAILURE); 
   } 
   memset (buffer, 0, BUFSIZE + 1);
   numread = _read (fd, buffer, BUFSIZE); 
   printf ("Actual number of characters read
	     was %d\n", numread); 

   _close (fd);
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Enter a filename: _read.c
Actual number of characters read was 239
</pre>


<hr><!-- =========================================== -->

<a name="_setmode"><h2>_setmode</h2></a>

<font size=3><b>
Header
</b><p>
fcntl.h<br>
io.h
<p>

<b>
Prototype
</b><p>
int _setmode(int handle, int mode); 
<p>

<b>
Description
</b><p>
The _setmode function sets the mode for an open file.<p>

The mode argument can be one of the following: <p>
<dl>
<dt>_O_BINARY
<dd>Binary mode. No character translations. 
<dt>_O_TEXT
<dd>Text mode. Carriage-return/ line-feed combinations are translated into a single line-feed character on input. Line-feed characters are translated into carriage-return/ line-feed combinations on output. 
</dl><br>

<b>
Synonym
</b><p>
Function:  setmode
<p>

<b>
Return Value
</b><p>
If successful, returns the previous mode. If unsuccessful, returns -1 
and set errno to EBADF (invalid file handle) or EINVAL (invalid 
mode argument). 
<p>
<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#fopen">fopen</a><br>
<a href="#_open">_open</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example of _setmode */ 

#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;fcntl.h&gt;

void main () 
{   
   int result; 
   result = _setmode(_fileno(stdprn), _O_TEXT); 
   if (result == -1) 
      perror("Error setting mode"); 
   else 
      printf("Printer successfully set to text mode\n"); 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Printer successfully set to text mode
</pre>


<hr><!-- =========================================== -->

<a name="_sopen"><h2>_sopen</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br>
share.h<br>
fcntl.h<br>
sys\types.h<br>
sys\stat.h
<p>

<b>
Prototype
</b><p>
int _sopen(const char *file, int oflag, int shflag[, int pmode]); 
<p>

<b>
Description
</b><p>
The _sopen function is similar to the standard library _open 
function; each opens a file. However, _sopen also prepares the file 
for DOS sharing. The DOS utility SHARE must be installed if files will 
be opened in shared mode. Attempting to use sopen with DOS 2.x 
causes an error.<p>

Arguments for _sopen are:<p>
<dl>
<b>Argument/Description</b>
<dtchar *file 		
<dd>Name of file to open 
<dt>int oflag 		
<dd>Operations allowed 
<dt>int shflag 		
<dd>Type of sharing allowed 
<dt>int pmode 		
<dd>Optional permission mode 
</dl>
<p>
The oflag argument can be one or more of the following values, 
OR'ed together: <p>
<dl>
<b>Value/Description</b>
<dt>_O_APPEND 		
<dd>Position file pointer to end 
<dt>_O_BINARY 		
<dd>Open file in binary (untranslated) mode 
<dt>_O_CREAT 		
<dd>Create file if it does not exist 
<dt>_O_EXCL 		
<dd>Used with _O_CREAT to return an error if file already exists 
<dt>_O_RDONLY 		
<dd>Open file for reading only 
<dt>_O_RDWR 		
<dd>Open file for reading and writing 
<dt>_O_TEXT 		
<dd>Open file in text (translated) mode 
<dt>_O_TRUNC 		
<dd>Truncate an existing file 
<dt>_O_WRONLY 		
<dd>Open file for writing only 
</dl>
<p>
The shflag argument can be one of the following:<p>
<dl>
<b>Value/Description</b>
<dt>_SH_COMPAT 		
<dd>Set compatibility mode 
<dt>_SH_DENYRW 		
<dd>Deny read and write access 
<dt>_SH_DENYWR 		
<dd>Deny write access 
<dt>_SH_DENYRD 		
<dd>Deny read access 
<dt>_SH_DENYNO 		
<dd>Permit read and write access 
</dl><p>
The pmode argument is used with _O_CREAT and can be one or 
both of the following OR'ed together: <p>
<dl>
<b>Value/Description</b>
<dt>_S_IWRITE 		
<dd>Permit writing 
<dt>_S_IREAD 		
<dd>Permit reading 
</dl><p>

<b>
Synonym
</b><p>
Function: sopen 
Values: O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, 
O_TEXT, O_TRUC, O_WRONLY, SH_COMPAT, SH_DENYRW, 
SH_DENYWR, SH_DENYRD, SH_DENYNO, S_IWRITE, S_IREAD 
<p>

<b>
Return Value
</b><p>
Returns a file handle for the opened file. If an error occurs, -1 is 
returned and errno is set to one of the following values: <p>
<dl>
<dt>EACCES 		<dd>Access violation 
<dt>EEXIST 		<dd>File already exists 
<dt>EINVAL 		<dd>Invalid oflag or pmode argument 
<dt>EMFILE 		<dd>No more file handles available 
<dt>ENOENT 		<dd>File or path name not found 
</dl>
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example of _sopen */ 

#include &lt;dos.h&gt; 
#include &lt;io.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;share.h&gt;

void main () 
{   
   int fd; 
   char fn[_MAX_PATH]; 

   printf ("Enter a filename: "); 
   scanf ("%s", fn); 

   fd = _sopen(fn, _O_RDONLY | _SH_DENYNO, 0); 
   if (fd == -1) 
   {   
      perror ("Cannot open file"); 
      exit (EXIT_FAILURE); 
   } 
   printf ("File opened successfully"); 
   _close(fd); 
} 
</pre>


<b>
Output
</b><p>
<pre class="console">Enter a filename: _sopen. c
File opened successfully
</pre>


<hr><!-- =========================================== -->

<a name="_tell"><h2>_tell</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
long _tell(int handle); 
<p>

<b>
Description
</b><p>
The _tell function returns the current position of the file pointer 
associated with the handle argument. The position is specified as the 
number of bytes from the beginning of the file. 
<p>

<b>
Synonym
</b><p>
Function:  tell
<p>

<b>
Return Value
</b><p>
Returns the file pointer position if successful; otherwise returns -1L, 
and errno is set to EBADF, indicating an invalid file handle. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#ftell">ftell</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for _tell */ 

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;io.h&gt;
#include &lt;string.h&gt;

void main () 
{   
   char fname[_MAX_PATH]; 
   char line[128]; 
   FILE *fp; 
   long offset; 

   printf ("Enter a filename: "); 
   gets (fname); 

   if ((fp = fopen(fname, "r")) == NULL) 
   {   
      perror ("Unable to open input file"); 
      exit (EXIT_FAILURE); 
   } 

   setbuf(fp, NULL); 
   fgets(line, 128, fp); 

   if (line[strlen (line) -1] == '\n') 
       line[strlen (line) -1] = '\x00'; 

   offset = _tell (_fileno (fp)); 

   printf ("After reading the first line in file 
	     \"%s\":\n \"%s\"\n", fname, line); 
   printf ("The file pointer is at offset: 
	     %d\n", offset); 

   fclose (fp); 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Enter a filename: _tell.c
After reading the first line in file "_tell.c":
"/*"
The file pointer is at offset: 4
</pre>


<hr><!-- =========================================== -->

<a name="_write"><h2>_write</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
int _write(int fd, void *buffer, unsigned int length); 
<p>

<b>
Description
</b><p>
This function writes length bytes from buffer to the file specified by file descriptor fd. This binary-only operation is not buffered.<p>

Data is written, starting at the current position of the file pointer associated with the given file. If the file is open for appending, data is written at the end of the file. After the write operation, the file pointer is increased by the number of bytes written.
<p>

<b>
Synonym
</b><p>
Function: write
<p>

<b>
Return Value
</b><p>
Returns the number of bytes written. If an error occurs, -1 is returned and errno is set to EBADF (invalid file handle) or ENOSPC (no space left on device). 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_read">_read</a><br>
<a href="#_open ">_open </a>
<p>

<b>
Example
</b>
<pre class="ccode">/* 	Example for _write 	*/

#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt;
#include &lt;io.h&gt; 
#include &lt;dos.h&gt; 
#include &lt;fcntl.h&gt; 

void main () 
{   
   int fh; 
   char *str = "Write this data to file"; 
   char buffer[128]; 
   int count, nwritten, nread; 

   count = strlen (str) + 1;
 
   fh = _open ("file.dat", _O_RDWR | _O_CREAT);

   if (fh &lt; 0) 
   {   
      perror ("Unable to create file: file.dat"); 
      exit (EXIT_FAILURE); 
   } 

   printf ("Writing string \"%s\" to file...\n", 
	     str); 
   nwritten = _write (fh, str, count); 
   printf ("%d bytes written\n", nwritten); 
   _lseek (fh, 0, SEEK_SET); 
   printf ("Reading back from file...\n"); 
   nread = _read (fh, buffer, count); 
   printf ("%d bytes read from file\nString read 
      is \"%s\"\n", nread, buffer); 
   _close (fh);
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Writing string "Write this data to file" to
file...
24 bytes written
Reading back from file...
24 bytes read from file
String read is "Write this data to file"
</pre>

<hr><!-- =========================================== -->

<a name="_umask"><h2>_umask</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br>
sys\types.h<br>
sys\stat.h 
<p>

<b>
Prototype
</b><p>
unsigned _umask(int mode); 
<p>

<b>
Description
</b><p>
The _umask function sets the file-permission mask for the current 
process to the mode specified by the mode argument. The 
permission mask modifies the permission setting of new files created 
using functions _open, _creat, or _sopen. If a bit in the mask is 
set to 1, the corresponding bit in the file's requested permission is set to 0. If a bit in the mask is 0, the corresponding bit remains 
unchanged. For example, if the write bit is set, new files will be 
read-only.<p>

Values for the mode argument are:<br>

<pre>
S_IWRITE 		Write access 
S_IREAD 		Read access 
S_IREAD | S_IWRITE 	Read and write access 
</pre>

<b>
Synonym
</b><p>
Function: umask 
<p>

<b>
Return Value
</b><p>
Returns the previous value of the file permission mask. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_chmod">_chmod</a><br>
<a href="#_creat">_creat</a><br>
<a href="#_open">_open</a><br>
<a href="#_sopen">_sopen</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for _umask */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;io.h&gt;
#include &lt;sys\types.h&gt; 
#include &lt;sys\stat.h&gt;

void main () 
{   
   FILE *fp; 
   struct _stat statbuf; 

   _umask (_S_IWRITE); 

   if ((fp = fopen ("new.dat", "w")) == NULL) 
   {   
      perror ("Error creating file"); 
      exit (EXIT_FAILURE); 
   } 
   fclose (fp); 

   if (_stat("new.dat", &statbuf) != 0) 
   {   
      perror ("Error calling _stat"); 
      exit (EXIT_FAILURE); 
   } 

   if (statbuf. st_mode &amp; _S_IWRITE) 
      printf ("_umask did not work\n"); 
   else 
      printf ("_umask worked\n"); 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">_umask worked
</pre>



<hr><!-- =========================================== -->

<a name="_unlink"><h2>_unlink</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br>
stdio.h
<p>

<b>
Prototype
</b><p>
int _unlink(const char *filename);  
<p>

<b>
Description
</b><p>
The _unlink function deletes the file specified by the string 
filename. 
<p>

<b>
Return Value
</b><p>
Returns 0 if the file was successfully deleted. Otherwise, returns -1 
and sets errno to EACCES (the file is read-only) or ENOENT (file or 
path not found, or name is a directory). 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_close">_close</a><br>
<a href="#remove">remove</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for remove */ 

#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;stdlib.h&gt;

void main () 
{   
   int value; 
   char buffer[13]; 
   char *result; 

   printf ("Enter file to remove: "); 
   result = gets (buffer); 
   value = _unlink (result); 
   if (value == 0) 
      printf ("Erased \"%s\" from disk\n", 
		result); 
   else 
   {   
      perror("Unable to erase file"); 
      exit (EXIT_FAILURE); 
   } 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Enter file to remove: delete.me
Erased "delete.me" from disk
</pre>


<hr><!-- =========================================== -->

<a name="filesize"><h2>filesize</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
long filesize(const char *filename); 
<p>

<b>
Description
</b><p>
filesize determines the size of a file in bytes. The filename must 
be an existing file that is not currently open. 
<p>

<b>
Return Value
</b><p>
The length of the file in bytes; otherwise a -1L is returned, errno is 
set, and _doserrno is set to the OS return code. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="sys-stat.html#_stat">_stat</a><br>
<a href="sys-stat.html#_fstat">_fstat</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for filesize */ 

#include &lt;io.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main ()
{   
   long size; 

   size = filesize ("c:\\sc\\include\\io.h");
   if (size == -1) 
   {
	perror ("Couldn't get size of IO. H"); 
	exit (EXIT_FAILURE);
   } 
   printf ("IO. H filesize = %ld\n", size);
} 
</pre>
<p>

<b>
Output
</b><p>
<pre class="console">IO.H filesize = 2759
</pre>

<hr><!-- =========================================== -->

<a name="getDS"><h2>getDS</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
unsigned short getDS(void); 
<p>

<b>
Description
</b><p>
The getDS function returns the value of the data segment register. 
In 32-bit memory models, getDS returns the actual value in the DS 
register which is the protected mode segment selector and not the 
base address of DGROUP. Use __X386_get_abs_address to find 
DGROUP. 
<p>

<b>
Return Value
</b><p>
The current value in the data segment register DS. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_segread">_segread</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for getDS */ 

#include &lt;io.h&gt; 
#include &lt;stdio.h&gt;

void main() 
{   
    printf("The data segment is %04X\n", getDS()); 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">The data segment is 1FE7
</pre>


<hr><!-- =========================================== -->

<a name="getftime"><h2>getftime</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
int getftime(int handle, struct ftime *ftimep); 
<p>

<b>
Description
</b><p>
The getftime function gets date and time information for the file 
associated with the handle argument. The information is copied 
into the structure pointed to by the ftimep argument. This 
structure, which is of type ftime and is defined in io.h, is 
described in the setftime function. 
<p>

<b>
Return Value
</b><p>
When the function is successful, zero is returned. If an error occurs, 
-1 is returned and errno is set to EINVFNC (invalid function 
number) or EBADF (bad file number). 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#setftime">setftime</a>
<p>




<hr><!-- =========================================== -->

<a name="lock"><h2>lock</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
int lock(int handle, long offset, long length); 
<p>

<b>
Description
</b><p>
This function provides an interface to DOS file-sharing. Argument 
handle specifies a file handle, offset indicates the offset, and 
length indicates the file length. To use lock, share. exe must be 
loaded and DOS 3. x or higher must be running. 
<p>

<b>
Return Value
</b><p>
Returns 0. If unsuccessful, returns -1 and sets errno to EACCES. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#unlock">unlock</a><br>
<p>





<hr><!-- =========================================== -->

<a name="remove"><h2>remove</h2></a>

<font size=3><b>
Header
</b><p>
io.h<br>
stdio.h
<p>

<b>
Prototype
</b><p>
int remove(const char *filename); 
<p>

<b>
Description
</b><p>
remove deletes the file specified by the string filename. 
<p>

<b>
Return Value
</b><p>
Returns 0 if the file was successfully deleted or -1 if an error 
occurred and errno is set. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#_unlink">_unlink</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for remove */ 

#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;stdlib.h&gt;

void main ()
{   
   int value;
   char buffer[13]; 
   char *result; 

   printf ("Enter file to remove: ");
   result = gets (buffer); 
   value = remove (result);
   if (value == 0) 
      printf ("Erased \"%s\" from disk\n",
		result); 
   else
   {   
       perror("Unable to erase file");
       exit (EXIT_FAILURE); 
   }
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Enter file to remove: delete.me
Erased "delete.me" from disk
</pre>


<hr><!-- =========================================== -->

<a name="rename"><h2>rename</h2></a>

<font size=3><b>
Header
</b><p>
stdio.h<br>
io.h
<p>

<b>
Prototype
</b><p>
int rename (const char *oldname, const char *newname); 
<p>

<b>
Description
</b><p>
Changes the name of a file from oldname to newname. Both 
oldname and newname may contain drive and path names but both 
names must refer to the same drive. 
<p>

<b>
Return Value
</b><p>
0 if the file name was successfully changed. If unsuccessful, returns 
non-zero and sets errno to EACCESS or ENOENT. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for rename */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main ()
{   
   char oldn[_MAX_PATH], newn[_MAX_PATH];
   int result; 

   printf ("Enter the old filename: ");
   gets (oldn); 

   printf ("Enter the new filename: ");
   gets (newn); 

   result = rename (oldn, newn); 

   if (result == 0)
      printf ("File successfully renamed.\n"); 
   else
      perror("Unable to rename file"); 
} 
</pre>

<b>
Output
</b><p>
<pre class="console">Enter the old filename: filename.old
Enter the new filename: filename.new
File successfully renamed.
</pre>


<hr><!-- =========================================== -->

<a name="setftime"><h2>setftime</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
int setftime(int handle, struct ftime *ftime); 
<p>

<b>
Description
</b><p>
The setftime function sets a file's date and time. The handle 
argument specifies the file for which to set the data and time; the 
ftime argument specifies the date and time. 


The ftime structure, which is defined in io.h, is shown below:<p>

<pre class="ccode">struct ftime
{ 
unsigned ft_tsec: 5; 	/* seconds */ 
unsigned ft_min: 6; /* minutes */ 
unsigned ft_hour: 5; /* hours */ 
unsigned ft_day: 5; /* days */ 
unsigned ft_month: 4; /* months */ 
unsigned ft_year: 7; /* year -1980 */ 
}; 
</pre>

<b>
Return Value
</b><p>
If successful, zero is returned. If unsuccessful, -1 is returned and 
errno is set to EINVFNC (invalid function number) or EBADF (bad 
file number). 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#getftime">getftime</a>
<p>

<b>
Example
</b><p>
<pre class="ccode">/* 	Example for setftime */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;io.h&gt;
#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt; 

void evenftime (struct ftime *time)
{   
   time-&gt; ft_tsec = 0;
   time-&gt; ft_min = 0; 
   time-&gt; ft_hour = 0;
   time-&gt; ft_day = 1; 
} 
int dofile (char *fname)
{   
   int fh; 
   struct ftime time; 
   char buffer[128]; 

   if ((fh = _open (fname, _O_RDONLY)) &lt; 0)
   {   
      sprintf (buffer, "Unable to open file: %s", fname); 

      perror (buffer); 
   } 
   printf ("setftime: %s\n", fname); 

   getftime (fh, &time);
   evenftime (&amp; time); 
   setftime (fh, &time); 

   _close (fh);
} 

void main (int argc, char * argv[])
{   
   int args;
   struct FIND *find; 

   if (argc &lt; 2)
   {   
      printf ("Usage: SETFTIME filespec 
		[filespec [filespec [...]]]\n"); 
      exit (EXIT_FAILURE);
   } 

   for (args = 1; args &lt; argc; args++)
   {   
      find = findfirst (argv[args], 0); 

      while (find)
      {   
	  dofile (find-&gt; name);
	  find = findnext (); 
      }
   } 
} 
</pre>

<b>
Output
</b><p>

<pre class="console">C:\SC\EXAMPLES&gt; dir setftime.c

Volume in drive C is DIGIMARS
Volume Serial Number is 1CD4-5ECB
Directory of C:\SC\EXAMPLES
 
SETFTIME C 1,043 06-28-94 9:25a
1 file(s) 1,043 bytes
100,184,064 bytes free
 
C:\SC\EXAMPLES&gt; setftime setftime.c
setftime: SETFTIME.C

C:\SC\EXAMPLES&gt; dir setftime.c

Volume in drive C is DIGIMARS
Volume Serial Number is 1CD4-5ECB
Directory of C:\SC\EXAMPLES
 
SETFTIME C 1,043 06-01-94 12:00a
1 file(s) 1,043 bytes
100,184,064 bytes free
</pre>

<hr><!-- =========================================== -->

<a name="unlock"><h2>unlock</h2></a>

<font size=3><b>
Header
</b><p>
io.h
<p>

<b>
Prototype
</b><p>
int unlock(int handle, long offset, long length); 
<p>

<b>
Description
</b><p>
The unlock function releases the file-sharing locks for the file 
associated with the handle argument. You should unlock all file-sharing 
locks before closing a file. 
<p>

<b>
Return Value
</b><p>
Returns zero. If unsuccessful, returns -1 and sets errno and 
_doserrno. 
<p>

<b>
Compatibility
</b><p>
DOS Windows 3.x Phar Lap DOSX Win32 
<p>

<b>
See Also
</b><p>
<a href="#lock">lock</a>
<p>

<b>
Example
</b><p>
See lock



<br><br><br><br>

</td></table>





<div id="copyright">
Copyright &copy; 1997-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

