
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - Lesson 2: Generate an Application Framework
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:30:17 2006
</div>
</div>

<!-- Generated by Ddoc from chapter11.d -->





<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc">
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="IDDE Search" onFocus='if(this.value == "IDDE Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ugr">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="ugr.html"><b>IDDE<br>Reference</b></a><br><br>
</center>

<b>Part 1: Welcome to Digital Mars C++</b><br>
    1. <a href="chapter1.html">Introducing Digital Mars C++</a></br>
    2. <a href="chapter2.html">Introducing the IDDE</a></br>
<hr>
<b>Part 2: Creating an Application with Digital Mars C++</b><br>
    3. <a href="chapter3.html">Starting a Project and Defining Workspaces</a></br>
    4. <a href="chapter4.html">Generating an Application Framework</a></br>
    5. <a href="chapter5.html">Defining Classes and Their Hierarchies</a></br>
    6. <a href="chapter6.html">Editing Program Code</a></br>
    7. <a href="chapter7.html">Adding Look and Feel with Resources</a></br>
    8. <a href="chapter8.html">Testing an Application</a></br>
<hr>
<b>Part 3: Learning Digital Mars C++ by Example</b><br>
    9. <a href="chapter9.html">Introduction to the Tutorial</a></br>
    10. <a href="chapter10.html">Lesson 1: Create the DOS Application</a></br>
    11. <a href="chapter11.html">Lesson 2: Generate an Application Framework</a></br>
    12. <a href="chapter12.html">Lesson 3: Customize the Interface</a></br>
    13. <a href="chapter13.html">Lesson 4: Add Messages with ClassExpress</a></br>
    14. <a href="chapter14.html">Lesson 5: Add a Dialog Box with ClassExpress</a></br>
<hr>
<b>Part 4: More about Creating Programs</b><br>
    15. <a href="chapter15.html">More about Projects and Workspaces</a></br>
    16. <a href="chapter16.html">More about Project Build Settings</a></br>
    17. <a href="chapter17.html">More about AppExpress</a></br>
    18. <a href="chapter18.html">More about ClassExpress</a></br>
    19. <a href="chapter19.html">Class Editor Reference</a></br>
    20. <a href="chapter20.html">Hierarchy Editor Reference</a></br>
    21. <a href="chapter21.html">Text Editor Reference</a></br>
    22. <a href="chapter22.html">Using Version Control</a></br>
<hr>
<b>Part 5: More about Testing Programs</b><br>
    23. <a href="chapter23.html">Controlling and Configuring the Debugger</a></br>
    24. <a href="chapter24.html">Commands Available in Debugging Mode</a></br>
<hr>
<b>Part 6: About Managing Resources</b><br>
    25. <a href="chapter25.html">ResourceStudio Resource Editor</a></br>
    26. <a href="chapter26.html">Dialog Editor</a></br>
    27. <a href="chapter27.html">Menu, Accelerator and String Table Editors</a></br>
    28. <a href="chapter28.html">Bitmap, Cursor, Icon, and Font Editors</a></br>
    29. <a href="chapter29.html">Version Information and Custom Resource Editors</a></br>
<hr>
<b>Part 7: Appendixes</b><br>
    A. <a href="appendixa.html">Expression Evaluation</a></br>
    B. <a href="appendixb.html">IDDE Settings and Command-Line Options</a></br>
    C. <a href="appendixc.html">Using NetBuild</a></br>

</small>

<hr>


</td>
<td valign="top">


<h1>11. Lesson 2: Generate an Application Framework</h1>


In this chapter you begin the process of building a Windows version 
of the TML Reader. This version is built around a Microsoft 
Foundation Class (MFC) version 2.5 Single Document Interface (SDI) 
framework. In this lesson you: 


<ul>
	<li> Use AppExpress to generate a new project containing the 
	SDI framework 

	<li> Build and run the bare application framework, a 
	standardized skeleton composed of C++ classes derived 
	from MFC library base classes. 

	<li> Use precompiled headers to speed build time 

	<li> Add calls to the TRACE macro with Class Editor 

	<li> Follow TRACE output in the Trace Messages window 
</ul>

At the end of the lesson you will have a working application 
framework with menus, a toolbar, and a status bar. The framework 
itself will respond to certain commands, but the functionality needed 
to read and display TML files is not yet included. In subsequent 
chapters you modify the user interface for the TML Reader and add 
the necessary file input and display routines. 
<p>

There are many ways to create an application framework. This 
lesson provides the most straightforward way. 


<h2>Generating the Framework</h2>

In this lesson you use AppExpress to generate a new project 
containing an application framework. To start AppExpress: 

<ol>
	<li> Start the IDDE and close any open project by choosing 
	<b>Close</b> from the <b>Project</b> menu. 

	<li> Start AppExpress by choosing <b>AppExpress</b> from the 
	<b>Tools</b> menu. 
</ol>

The AppExpress window opens (shown in Figure 11-1). 

	<p>
	<img align="middle" src="figure11_1.gif">
	<p>
	[Figure 11-1 Setting up an SDI application with AppExpress]
<p>

AppExpress contains six pages of options that together define the 
project to be generated. You define these options in six steps, listed 
in the upper-left portion of the window. For this project, you need to 
change options on only four of the six pages. Set up the project 
options as follows: 

<ol>
	<li> On the Application Type page (shown when AppExpress 
	is started), select SDI. 

	<li> Deselect Include Help to suppress generation of 
	Windows Help support. 

	<li> Click on Next to switch to the Select Directory page. 
	Change to the <tt>samples\tutorial\lesson2</tt>
	directory under the directory in which you installed 
	Digital Mars C++, then click on Create New Directory. 

	<li> Type <tt>start</tt> in the textbox and click Create. 
	<p>

	<b>Note:</b> 
	To avoid filename conflicts, it is a good idea to keep 
	each project you create in a separate directory. 
	<p>

	<li> Click on Next to switch to the Miscellaneous page. Type 
	your company name and suffix (or your own name) in 
	the appropriate textboxes. This information is displayed 
	in the automatically generated <b>About</b> dialog box, and in 
	comments at the beginning of each source file. 

	<li> In the Project Name textbox, type <tt>TMLRead</tt>. 

	<li> Click on Next to switch to the Names page. You can 
	customize the names of automatically generated classes 
	here. From the Name drop-down list, select 
	CTMLReadApp. In the Edit textbox, type <tt>CTMLReadApp</tt>. 

	<li> Click Finish. 
</ol>

AppExpress generates a new project in the directory you created. 
The directory contains: 

<ul>
	<li> Source and header files for the MFC-derived classes 
	<li> Resource script and binary files 
	<li> Project options and other support files 
</ul>


After generating the project, AppExpress closes and control returns 
to the IDDE. The new project is loaded automatically. The IDDE 
parses the new project's source files for browsing with the Class and 
Hierarchy Editors; parsing progress is displayed in the Output 
window. 


<h2>Building and Running the New Project</h2>

Next you build the project and learn what the default application 
framework can do. 

<ol>
	<li> From the IDDE's <b>Project</b> menu, choose <b>Rebuild All</b>. 

	<li> From the <b>Project</b> menu, choose <b>Execute Program</b>. 
</ol>

The IDDE minimizes itself and the TMLRead application opens 
(shown in Figure 11-2). 

	<p>
	<img align="middle" src="figure11_2.gif">
	<p>
	[Figure 11-2 New application framework generated by AppExpress]
	<p>

At present, default functionality for several menu commands is 
provided by the MFC base classes. For example, if you choose <b>Open</b> 
from the <b>File</b> menu, a standard Windows <b>File Open</b> dialog box 
opens. You can select a file in this dialog box, but the code needed 
to read data from the file is not yet installed. 
<p>

To close TMLRead and return to the IDDE, choose <b>Exit</b> from the 
<b>File</b> menu. 
<p>

The project can take a considerable amount of time to compile. Next 
you learn how to decrease compilation time by using precompiled 
headers. 


<h2>Using Precompiled Headers</h2>

In the last section, over 70,000 lines of code were read during 
compilation. Many of these lines are in Windows and MFC header 
files that are changed infrequently (if ever), but still must be included 
by almost every source file. To speed compilation, you can 
precompile header files; thereafter, the symbols generated by the 
compiler can be loaded directly. 
<p>

To precompile the Windows and MFC header files: 

<ol>
	<li> Choose <b>Settings</b> from the <b>Project</b> menu. The <b>Project 
	Settings</b> dialog box opens. 

	<li> Click on the Build tab. 

	<li> In the left listbox, click on Header Files. 

	<li> In the Precompile section of the right pane, select 
	Specific Header. 

	<li> In the textbox below the Specific Header selection, type 
	<tt>stdafx.h</tt>. 
	<p>

	<b>Note:</b> 
	You can specify multiple specific headers to 
	precompile by entering in this textbox a list of their 
	names separated by semicolons or spaces. 

	<p>
	<img align="middle" src="figure11_3.gif">
	<p>
	[Figure 11-3 Using precompiled headers]
	<p>

	<li> Click OK. 

	<li> An Editor/Browser message box is opens, noting that 
	project settings have changed and asking if you want to 
	reparse all files. Click No, because you are about to build 
	in the next step, which will stop any parse in progress. 

	<li> From the IDDE <b>Project</b> menu, choose <b>Rebuild All</b>. 
</ol>

During the rebuild, the header file <tt>stdafx.h</tt> is precompiled, then 
the source files are compiled using the precompiled symbol table. 
You should notice a significant reduction in the number of lines 
compiled, as well as a corresponding increase in compile speed. 
<p>

Now that you have created, compiled, and executed the application 
framework, the rest of the chapter helps you to understand the 
framework's structure. The following three sections are optional. 


<h2>Adding TRACE Calls with Class Editor</h2>

In the remainder of this chapter, you investigate calls to member 
functions of the MFC-derived classes created by AppExpress to 
understand the structure of the application framework and the 
relationships between the classes. To do this, you use the Class 
Editor to insert calls to the MFC global TRACE macro into the 
member functions, then watch the output in the Trace Messages 
window. 
<p>


To add a TRACE call to the application class's constructor: 

<ol>

	<li> Choose <b>Class Editor</b> from the <b>Goto View</b> submenu of 
	the IDDE <b>Window</b> menu. The Class Editor window 
	opens (see Figure 11-4). 

	<li> Under Classes, click on CTMLReadApp. The application 
	class's members appear in the Members list. 

	<li> Under Members, double-click on CTMLReadApp. The 
	application class constructor's source code is shown in 
	the source pane. 

	<li> Add the following line to the constructor: 

	<pre>
	TRACE("CTMLReadApp::CTMLReadApp()\n"); 
	</pre>

	The constructor should now appear as follows: 

	<pre>
	//////////////////////////////////////////////////////////////////
	// CTMLReadApp construction 

	CTMLReadApp:: CTMLReadApp()
	{   
	    TRACE("CTMLReadApp::CTMLReadApp()\n");
	    // TODO: add construction code here, 
	    // Place all significant initialization in InitInstance
	} 
	</pre>

	<li> Press Ctrl+S to save the modified constructor. 
</ol>
	<p>
	<img align="middle" src="figure11_4.gif">
	<p>
	[Figure 11-4 Adding TRACE calls with Class Editor]
	<p>

You can add similar TRACE calls to these other member functions: 

<ul>
	<li> CTMLReadApp::InitInstance() 
	<li> CMainFrame::CMainFrame() 
	<li> CMainFrame::~CMainFrame() 
	<li> CMainFrame::OnCreate() 
	<li> CTMLReadDoc::CTMLReadDoc() 
	<li> CTMLReadDoc::~CTMLReadDoc() 
	<li> CTMLReadDoc::OnNewDocument() 
	<li> CTMLReadDoc::Serialize() 
	<li> CTMLReadView::CTMLReadView() 
	<li> CTMLReadView::~CTMLReadView() 
	<li> CTMLReadView::OnDraw() 
</ul>


When you have finished, choose <b>Build</b> from the IDDE <b>Project</b> 
menu to recompile the source files you have changed. 
<p>

In the next section you execute the application and watch the 
TRACE output in the Trace Messages window. 


<h2>Watching TRACE Output in the Trace Messages Window</h2>

To watch TRACE output, first you must set up the Trace Messages 
window to receive and display TRACE messages. 

<ol>
	<li> Choose <b>Trace Messages</b> from the <b>Goto View</b> submenu 
	of the IDDE's <b>Window</b> menu. The Trace Messages 
	window opens. 

	<li> Choose <b>Output to Window</b> from the <b>Options</b> menu of 
	the Trace Messages window. 

	<li> Choose <b>MFC Debug Messages</b> from the <b>Options</b> menu. 
	The <b>MFC Trace Debug Options</b> dialog box opens. 

	<li> Check Enable Tracing and uncheck any other options 
	that are checked. Click OK. 
</ol>

You are now prepared to run the application and view the output of 
the TRACE macro calls. 

<ol>
	<li> Choose <b>Execute Program</b> from the IDDE's <b>Project</b> 
	menu. 

	<li> The IDDE is minimized and the application window 
	opens. Double-click on the IDDE icon to reopen the 
	IDDE windows. Position the windows so you can watch 
	the Trace Messages window while the program executes. 
</ol>

The Trace Messages window has already received several messages 
from the application's class constructors and initialization code 
(Figure 11-5). You see more messages if you choose <b>Open</b> or <b>New</b> 
from TMLRead's <b>File</b> menu, or when the window needs to be 
repainted. 
<p>

When you close TMLRead, the Trace Messages window receives 
messages from the application's class destructors. 

	<p>
	<img align="middle" src="figure11_5.gif">
	<p>
	[Figure 11-5 TRACE output in the Trace Messages window]
	<p>

The next section gives an overview of the classes in the application 
framework and explains the messages you see in the Trace Messages 
window. 


<h2>The Application Framework and MFC Classes</h2>

In this chapter, you have used AppExpress to build an application 
framework, a skeleton on which you can build a Windows 
application, consisting of C++ classes contained in and derived from 
classes in the Microsoft Foundation Class (MFC) library. 
<p>


The MFC library is a C++ class library that supports programming for 
Windows. It encapsulates most of the Windows Application 
Programming Interface (API), and provides additional C++ 
programming support such as container and string classes. The MFC 
library makes it easy to work with Windows elements in an object-oriented 
manner. For example, MFC library classes exist to represent 
objects such as windows, dialog boxes, controls, device contexts, 
Graphic Device Interface (GDI) objects, and so on. Windows API 
functions are implemented as member functions of the classes with 
which they are logically associated. 
<p>


TMLRead is built on a Single Document Interface (SDI) framework. 
The SDI framework contains five fundamental objects: 


<dl>
	<dt><b>Document:</b> <dd>The document contains data, reads the data 
	from disk, and provides access to the data. In TMLRead, 
	the document is an object of type CTMLReadDoc, 
	derived from the MFC library class CDocument. 

	<dt><b>View:</b> <dd>The view displays the data contained by the 
	document. In TMLRead, the view is an object of type 
	CTMLReadView, derived from the MFC library class 
	CView (which is, in turn, derived from CWnd, the base 
	class for all types of windows). 

	<dt><b>Document Template:</b> <dd>The document template defines the 
	association between document and view classes. In an 
	SDI application, this is an object of type 
	CSingleDocTemplate. 

	<dt><b>Frame Window:</b> <dd>The frame window object is the 
	application's main window. In TMLRead it contains a 
	toolbar, a status bar, and the view. The frame window is 
	an object of type CMainFrame, derived from the MFC 
	library class CFrameWnd. 

	<dt><b>Application:</b> <dd>The application object creates and controls 
	the other objects, and takes care of general program 
	initialization and cleanup. In TMLRead the application is 
	an object of type CTMLReadApp, derived from the MFC 
	library class CApplication. 
</dl>


The framework itself provides standard user-interface 
implementations for some commands (for example, file open and 
save); you must add support for certain framework functions (such 
as file input and output), as well as add other command and 
message-handling capability specific to your application. 
<p>


The TRACE output from the previous section lets you see the 
creation, use, and destruction of objects in the application. For 
example, when you start the application, you see the following 
messages: 


<pre>
	[00001] NOTIFY(StartTask)
	[00002] CTMLReadApp::CTMLReadApp() 
	[00003] CTMLReadApp::InitInstance()
	[00004] CTMLReadDoc::CTMLReadDoc() 
	[00005] CMainFrame::CMainFrame()
	[00006] CMainFrame::OnCreate() 
	[00007] CTMLReadView::CTMLReadView()
	[00008] CTMLReadDoc::OnNewDocument() 
	[00009] CTMLReadView::OnDraw() 
</pre>


The application object is created first. Using a document template, 
the application object creates the document, frame window, and 
view objects. It then calls the document object to set up a new 
document. Finally, when the window is shown, the framework calls 
the view's OnDraw() function to repaint the window. 
<p>


If you choose <b>New</b> from TMLRead's <b>File</b> menu, you see the 
following messages: 

<pre>
	[00010] CTMLReadDoc::OnNewDocument()
	[00011] CTMLReadView::OnDraw() 
</pre>


Or, if you choose <b>Open</b> from the <b>File</b> menu, then select a file, you 
see: 


<pre>
	[00012] CTMLReadDoc::Serialize()
	[00013] CTMLReadView::OnDraw() 
</pre>


The document object is called either to create a new document or to 
read a document from a file, depending on the menu item that was 
chosen. Note that neither the document object nor the view object is 
destroyed; in an SDI application, they are reused continually. 
<p>


When you choose <b>Exit</b> from TMLRead's <b>File</b> menu, the application's 
objects are destroyed in reverse order in which they were created. 
You see these messages in the Trace Messages window: 


<pre>
	[00014] CTMLReadView::~CTMLReadView()
	[00015] CMainFrame::~CMainFrame() 
	[00016] CTMLReadDoc::~CTMLReadDoc()
	[00017] NOTIFY(ExitTask) 
	[00018] NOTIFY(DelModule) 
</pre>

There is no message from the application object's destructor, 
because it is not defined explicitly in the framework. 
<p>

You may find it useful to continue to add TRACE calls to the 
application as it is built. It is often difficult to follow the workings of 
a message-driven system; the Trace Messages window, however, acts 
as a kind of passive debugger that keeps you informed of the 
internal workings of your application. 
<p>

In the next chapter, you begin to shape the application framework to 
the specific needs of the application. The first step in this process is 
to customize the user interface with the Resource Editor. 


<br><br><br><br>

</td></table>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

