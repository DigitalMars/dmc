
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - Testing an Application
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:30:17 2006
</div>
</div>

<!-- Generated by Ddoc from chapter8.d -->





<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc">
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="IDDE Search" onFocus='if(this.value == "IDDE Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ugr">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="ugr.html"><b>IDDE<br>Reference</b></a><br><br>
</center>

<b>Part 1: Welcome to Digital Mars C++</b><br>
    1. <a href="chapter1.html">Introducing Digital Mars C++</a></br>
    2. <a href="chapter2.html">Introducing the IDDE</a></br>
<hr>
<b>Part 2: Creating an Application with Digital Mars C++</b><br>
    3. <a href="chapter3.html">Starting a Project and Defining Workspaces</a></br>
    4. <a href="chapter4.html">Generating an Application Framework</a></br>
    5. <a href="chapter5.html">Defining Classes and Their Hierarchies</a></br>
    6. <a href="chapter6.html">Editing Program Code</a></br>
    7. <a href="chapter7.html">Adding Look and Feel with Resources</a></br>
    8. <a href="chapter8.html">Testing an Application</a></br>
<hr>
<b>Part 3: Learning Digital Mars C++ by Example</b><br>
    9. <a href="chapter9.html">Introduction to the Tutorial</a></br>
    10. <a href="chapter10.html">Lesson 1: Create the DOS Application</a></br>
    11. <a href="chapter11.html">Lesson 2: Generate an Application Framework</a></br>
    12. <a href="chapter12.html">Lesson 3: Customize the Interface</a></br>
    13. <a href="chapter13.html">Lesson 4: Add Messages with ClassExpress</a></br>
    14. <a href="chapter14.html">Lesson 5: Add a Dialog Box with ClassExpress</a></br>
<hr>
<b>Part 4: More about Creating Programs</b><br>
    15. <a href="chapter15.html">More about Projects and Workspaces</a></br>
    16. <a href="chapter16.html">More about Project Build Settings</a></br>
    17. <a href="chapter17.html">More about AppExpress</a></br>
    18. <a href="chapter18.html">More about ClassExpress</a></br>
    19. <a href="chapter19.html">Class Editor Reference</a></br>
    20. <a href="chapter20.html">Hierarchy Editor Reference</a></br>
    21. <a href="chapter21.html">Text Editor Reference</a></br>
    22. <a href="chapter22.html">Using Version Control</a></br>
<hr>
<b>Part 5: More about Testing Programs</b><br>
    23. <a href="chapter23.html">Controlling and Configuring the Debugger</a></br>
    24. <a href="chapter24.html">Commands Available in Debugging Mode</a></br>
<hr>
<b>Part 6: About Managing Resources</b><br>
    25. <a href="chapter25.html">ResourceStudio Resource Editor</a></br>
    26. <a href="chapter26.html">Dialog Editor</a></br>
    27. <a href="chapter27.html">Menu, Accelerator and String Table Editors</a></br>
    28. <a href="chapter28.html">Bitmap, Cursor, Icon, and Font Editors</a></br>
    29. <a href="chapter29.html">Version Information and Custom Resource Editors</a></br>
<hr>
<b>Part 7: Appendixes</b><br>
    A. <a href="appendixa.html">Expression Evaluation</a></br>
    B. <a href="appendixb.html">IDDE Settings and Command-Line Options</a></br>
    C. <a href="appendixc.html">Using NetBuild</a></br>

</small>

<hr>


</td>
<td valign="top">


<h1>8. Testing an Application</h1>

This chapter provides an overview of building, running, and 
debugging an application in Digital Mars C++. Whenever you finish 
making any significant addition or change to the source files of an 
application, it is wise to test the result and verify that you have 
achieved your goals. To do so, you must first build (or rebuild) the 
executable so that it incorporates your modifications. Then you must 
observe its behavior— either by tracing through modified sections, or 
at least by running the application under the control of the 
debugger. 
<p>

This entire phase of the development cycle can be carried out in the 
IDDE. Because all debugging in Digital Mars C++ takes place within 
the IDDE, you do not have to leave the IDDE and run a separate 
debugger. The IDDE itself provides a wealth of tools for examining 
all facets of your application's structure and behavior. 
<p>


Two other chapters present detailed information about the 
debugging capabilities of Digital Mars C++. 
<a href="chapter23.html" title="Chapter 23">Controlling 
and Configuring the Debugger</a>
describes the commands you use 
when debugging, and the options available in the IDDE for 
configuring the debugging environment.
<a href="chapter24.html" title="Chapter 24">Commands 
Available in Debugging Mode</a>, describes the commands available in 
each of the debugging windows. 


<h2>Debugger Highlights</h2>

The integrated debugger:

<ul>
	<li> Provides a Windows graphical user interface 

	<li> Debugs Windows applications under Windows on the 
	same screen 

	<li> Debugs DOS applications running in a DOS box under 
	Windows 3.1 

	<li> Takes advantage of virtual memory, letting you debug 
	large DOS applications under Windows 3.1 

	<li> Debugs Win32s applications (in the Win32s IDDE, 
	<tt>scw32s.exe</tt>) under Windows 3.1 

	<li> Debugs 32-bit Windows and character-mode console 
	applications (in the Win32 or 32-bit IDDE, <tt>scw32.exe</tt>) 

	<li> Provides a graphical representation of data structures 

	<li> Supports high-speed, hardware watchpoints, and 
	breakpoints 

	<li> Lets you drag and drop to execute commands 
</ul>


<h2>Choosing an Environment for Debugging</h2>

There are three versions of the IDDE included with Digital Mars C++. 
An icon for each version you install is available in your Digital Mars 
C++ program group. These different versions of the IDDE are 
essentially identical, except that they allow you to debug different 
kinds of executables: 


<ul>
	<li> To debug a Win32 executable under Windows 95 or 
	Windows NT, use the Win32 IDDE (<tt>scw32.exe</tt>). 

	<li> To debug a 16-bit executable, use the 16-bit IDDE 
	(<tt>scw.exe</tt>). 

	<li> To debug Win32s executables under Win32s, use the 
	Win32s IDDE (<tt>scw32s.exe</tt>). 
</ul>


<h2>Building a Project</h2>

To test an application, you must first build the executable file, which 
is the file you test. Your project specifies the source and library files 
needed to build the executable, as well as options that control the 
build process. Windows executables also incorporate such resources 
as menus, dialog boxes, icons, and bitmaps; these are defined in 
resource files. The building process begins by compiling the source 
files into object files. Object files are then linked with library files to 
create the executable file. 

<h3>Selecting the project type</h3>

You must specify the type of executable you plan to build. You do 
so by choosing <b>Settings</b> from the <b>Project</b> menu and clicking on the 
Target tab to select the Target page, as shown in Figure 8-1. 

<p>
	<img align="middle" src="figure8_1.gif">
<p>
	[Figure 8-1 Target page of the Project Settings dialog box]
<p>

On this page, choose the operating system your target executable 
will run on, and the target type. Not all target types are available 
with all operating system types. 
<p>


The Target page also presents the option of building a Debug or 
Release version of the executable. If you want to debug your 
executable, select the Debug option. 
<p>


For more information on the Target page of the Project Settings 
dialog box refer to
<a href="chapter15.html" title="Chapter 15">More about Projects and 
Workspaces</a>. 


<h3>Setting compiler and linker options for debugging</h3>

When you indicate that a debugging version should be built, the 
IDDE sets the appropriate compiler and linker options, and also 
prevents debugging information already in object files from being 
discarded. 
<p>


To verify that the these settings are appropriate, choose <b>Settings</b> 
from the <b>Project</b> menu, and then click on the Build tab to select the 
Build page of the <b>Project Settings</b> dialog box. Select the Debug 
Information subpage by clicking on that label in the left listbox. The 
Debug Information subpage is shown in Figure 8-2. 

<p>
	<img align="middle" src="figure8_2.gif">
<p>
	[Figure 8-2 Debug Information options]
<p>

For more information about project, compiler, and linker options, 
see
<a href="chapter15.html" title="Chapter 15">More about Projects and 
Workspaces</a>. 


<h3>Building executable files</h3>

The IDDE provides three ways to build executable files from your 
project: by performing a standard build, by rebuilding the entire 
project, or by linking the existing object files. 


<h4>Performing a standard build</h4> 

This is the most common of the three build options. To begin, 
choose <b>Build</b> from the <b>Project</b> menu. The IDDE recompiles only 
those files that changed since you last compiled them, then links the 
project. The IDDE displays any errors in the Output window. 
<p>


The IDDE Make facility is used by default to determine the steps 
needed to build your project. It is functionally identical to the DOS 
command-line Make utility SMAKE, included with Digital Mars C++. If 
you need to use a different, DOS command-line Make utility, such as 
NMAKE or PolyMake, you can do so; see
<a href="chapter16.html" title="Chapter 16">More about 
Project Build Settings</a>, for details on how to use an external Make 
program. 


<h4>Rebuilding the project</h4>

If you want to recompile every file in your project— even those files 
that are up-to-date— choose <b>Rebuild All</b> from the <b>Project</b> menu. 
The IDDE recompiles all files in your project, whether they've been 
edited recently or not, then links the project. 
<p>


Typical situations in which you use the <b>Rebuild All</b> command 
include: 

<ul>
	<li> When you have changed some of the project options 

	<li> When you suspect corrupted object <tt>.obj</tt> files 

	<li> When you want to create a final build 
</ul>


<h4>Linking the project</h4>

If you want to build a program with the existing object files but 
without recompiling your source files, choose <b>Link</b> from the <b>Project</b> 
menu. The IDDE links the object files. 
<p>


Typical situations in which you use the <b>Link</b> command include: 

<ul>
	<li> When you have added a new library <tt>.lib</tt> file 

	<li> When you wish to build from object <tt>.obj</tt> files only 

	<li> When you have changed linker options 
</ul>


<h3>Other project options</h3>

The Build page of the <b>Project Settings</b> dialog box offers additional 
settings that you may find useful for precompiling headers and 
generating an assembly listing. 


<h4>Precompiling headers</h4>

The Header Files subpage lets you precompile one or all of the 
header files that are included by source files in your project. 
Precompiling a header is useful when the header file changes 
infrequently or not at all between builds, or when a header file is 
included by most of the source files in a project. Precompiled 
headers speed up the build process, especially with large header 
files. For example, windows. h can be beneficially precompiled 
because it is large and is not likely to change. 


<h4>Generating an assembly listing</h4>

The Assembly Listing (.COD) check box on the Output subpage lets 
you create a <tt>.cod</tt> file that contains the assembly language code into 
which the compiler converts your source code. In this file, C++ 
source statements are preserved as assembly language comments. 
Each commented statement precedes the assembly language code to 
which it corresponds. 


<h2>Running a Project</h2>

You can run the application that your project produces without 
leaving the IDDE. Commands that run your application ask you to 
build it if required. 
<p>


If your program requires no command-line arguments, choose 
<b>Execute Program</b> from the <b>Project</b> menu. The IDDE launches your 
application. 
<p>


If your program requires arguments, first choose <b>Arguments</b> from 
the <b>Project</b> menu. The IDDE displays the dialog box in Figure 8-3. 

<p>
	<img align="middle" src="figure8_3.gif">
<p>
	[Figure 8-3 Run Arguments dialog box]
<p>

Enter your arguments -- not the program name -- in the dialog box. 
For example, entering: 

	<pre>
	*.* /s 
	</pre>

launches your program with the arguments *.* and /s. 
<p>


After specifying the arguments, click OK. Then run your application 
as described above. 


<h2>Quick Start: Debugging an Application</h2>

This section provides a brief description of how to perform common 
debugging tasks. You can find a complete presentation of the 
debugging capabilities of Digital Mars C++ in
<a href="chapter23.html" title="Chapter 23">Controlling 
and Configuring the Debugger</a>, and in
<a href="chapter24.html" title="Chapter 24">Commands 
Available in Debugging Mode</a>. In Chapter 23, see especially the 
sections "Commands on the Debug Menu" and "Debug Toolbox 
Icons." 
<p>


After building your project, you can enter debugging mode by 
choosing <b>Start/Restart Debugging</b> (F4) from the <b>Debug</b> menu. 
(That is, you may either choose this command from the menu, or 
type its keyboard shortcut given in parentheses.) Alternatively, you 
can click on the Restart Debugging icon in the Debug toolbox. Any 
open Source windows change to debugging mode. Your application 
executes to the breakpoint set automatically on WinMain (for 
Windows applications) or main (for DOS applications and 32-bit 
console applications). 
<p>


Other debugging windows, such as the Function window and Data/ 
Object window, can be opened as needed from the Views toolbox 
or from the <b>Goto View</b> submenu of the IDDE's <b>Window</b> menu. 
<p>


In debugging mode, the <b>Start/Restart Debugging</b> command on the 
<b>Debug</b> menu remains available. This command restarts the program. 
The <b>Stop Debugging</b> command on the <b>Debug</b> menu exits 
debugging mode, and returns the IDDE to editing mode. 


<h3>Stepping through code</h3>

To step to the next source code statement, choose <b>Step Into</b> (F8) 
from the <b>Debug</b> menu. Alternatively, you may click on the Step Into 
icon in the Debug toolbox. If the current line is a function call, and 
debugging information is available for that function, you will trace 
into that function. To step over a function call, choose <b>Step Over</b> 
(F10) from the <b>Debug</b> menu, or click on the Step Over icon in the 
Debug toolbox. 
<p>


<b>Note:</b> 
If you accidentally step into a function call when 
you meant to step over it, you can move to where 
you intended to be— the statement following the 
call— by choosing <b>Return from Call</b> from the 
<b>Debug</b> menu. This command executes to the 
current function's return address (unless a 
breakpoint or watchpoint is encountered before 
control reaches that point). 


<h3>Setting and clearing breakpoints</h3>

Setting a breakpoint on a source code statement causes your 
program to stop when execution reaches that statement. The 
debugger regains control, and you may again perform any 
debugging mode actions. 
<p>


To set a breakpoint on a statement, first click on that statement in the 
Source window to make it the selected line. Then choose <b>Set/Clear 
Breakpoint</b> (F9) from the Source window pop-up menu (which 
appears when you click the right mouse button in the Source 
window), or click on the Toggle Breakpoint icon in the Debug 
toolbox. These commands act as toggles; repeating them clears the 
breakpoint. 
<p>


The Source window pop-up menu, as it appears in debugging mode, 
is shown in Figure 8-4. 

<p>
	<img align="middle" src="figure8_4.gif">
<p>
	[Figure 8-4 Source window pop-up menu in debugging mode]
<p>

A breakpoint symbol in the left margin of the Source window 
indicates a breakpoint on the adjacent line. You can also clear a 
breakpoint by dragging the symbol out of the Source window. 


<h3>Executing up to a statement</h3>

To execute up to the currently selected line, choose <b>Go Until Line</b> 
from the Source window pop-up menu. Double-clicking on any line 
in the Source window causes your program to run until execution 
reaches that line. 


<h3>Viewing a list of functions</h3>

The Function window lists the functions in the current module or in 
all modules. Toggle the display by choosing <b>Current Module</b> or <b>All 
Modules</b> from the <b>View</b> menu. Double-click on any function to 
view that function in a Source window. 
<p>

You can easily set a breakpoint at the beginning of a function from 
within the Function window by choosing the <b>Set/Clear Breakpoint</b> 
(F9) command from the <b>Bpt</b> menu. 


<h3>Examining the values of variables</h3>

The Data/Object window lets you view either global data or the 
variables local to a function. The <b>Show</b> menu of the Function 
window has commands <b>Global Data</b> and <b>Local Data</b> that select the 
type of data displayed in the Data/Object window. If you choose 
<b>Local Data</b>, the Data/Object window shows the local variables for 
the function currently selected in the Function window, provided 
that function is in the call chain. (If a function is not in the call chain, 
it has no local data.) The display can also be toggled by choosing 
<b>Local/Global Data</b> from the <b>View</b> menu of the Data/Object 
window. 


<h3>Examining the call chain</h3>

The Call window displays the stack of function calls in your code 
that have not yet returned. The list is presented in reverse 
chronological order from most to least recent; thus, WinMain (or 
main) is at the bottom of the list. 
<p>

The Call window's <b>Show</b> menu contains commands that let you 
zoom in on a particular function in the chain. For example: 

<ul>
	<li> The <b>Source</b> command updates the Source window and 
	displays the statement that is executing within the 
	selected function. 

	<li> The <b>Data</b> command updates the Data/Object window 
	and displays local data for the selected function. 
</ul>


<h3>Setting watchpoints</h3>

A watchpoint specifies that execution of your program should stop 
when a particular variable or memory location is written to or read 
from. This capability is essential for detecting problems arising from 
wild pointers, for example, which can manifest themselves in 
extremely elusive and seemingly random behavior. 
<p>


Digital Mars C++ debuggers are designed to take advantage of 
hardware watchpoints provided by 386 and higher microprocessors. 
The Digital Mars C++ installation program may install the file 
SCWDEBUG. 386 in the [386Enh] section of system. ini if your 
system needs it to allow the use of hardware watchpoints. Because 
watchpoints are implemented with hardware assistance, using this 
powerful tool imposes no speed penalty on program execution. 


<h4>Setting a watchpoint on a variable</h4>

Using the methods described in the sections above, make sure that 
the desired variable is displayed in the Data/Object window. Click 
on the line referencing the variable to select it; the line should be 
highlighted. Choose <b>Set Watchpoint</b> (Ctrl+ W) from the <b>Watch</b> 
menu of the Data/Object window. This opens the <b>Set Watchpoint</b> 
dialog box, shown in Figure 8-5. 

<p>
	<img align="middle" src="figure8_5.gif">
<p>
	[Figure 8-5 Set Watchpoint dialog box]
<p>

The debugger maintains information about the type of variables and 
their location in memory. The selected variable's type determines the 
size of the watchpoint. The <b>Set Watchpoint</b> dialog box displays the 
address and size of the watchpoint as noneditable fields, and 
provides options for breaking on a Read access, Write access, or 
both. To clear the watchpoint, choose <b>Clear Watchpoint</b> from the 
<b>Watch</b> menu of the Data/Object window. 
<p>


Warning Exercise caution when setting a watchpoint on an 
automatic variable (that is, a local, nonstatic 
variable). If you attempt to set such a watchpoint, 
the debugger warns you by displaying a message 
on the status line. You should clear the watchpoint 
by the time the function whose local variable you 
are watching returns. If you don't, Windows itself 
can use the stack location subsequently, thus 
triggering the watchpoint and causing Windows to 
crash. 
<p>


In addition to setting watchpoints on variables, watchpoints can also 
be set on locations in memory using the Memory window, whose 
Watch menu is identical to that of the Data/Object window. 


<h3>Letting your program run until the next breakpoint</h3>

You can make your program run until execution reaches a 
breakpoint by choosing <b>Go until Breakpoint</b> (F5) from the IDDE's 
<b>Debug</b> menu, or by clicking on the Go until Breakpoint icon in the 
Debug toolbox. You can use the Breakpoint window to see at a 
glance where breakpoints have been set. 


<h3>Letting your program run until it terminates</h3>

You can make your program run until it terminates -- ignoring any 
breakpoints -- by choosing <b>Go until End</b> from the <b>Debug</b> menu. 


<h3>Interrupting execution of the debugged application</h3>

Use the Ctrl+Alt+SysRq key combination to break execution of the 
application being debugged and return control to the debugger. It 
may be necessary to press this key combination a few times before 
the debugger regains control. (If you use this key combination to 
break execution when control is within Windows itself, it may be 
difficult for the debugger to step out of Windows code.) 
<p>

The technique is most useful when you suspect that your own code 
is hung. Returning to the debugger lets you examine your program's 
state, which may be one that you thought impossible. Inspecting the 
values of variables and the call chain can suggest how to identify 
and eliminate the source of the error. 
<p>


<b>Note:</b> 
Use Ctrl+Alt+F11 to break execution of Win32s 
applications. 


<br><br><br><br>

</td></table>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

