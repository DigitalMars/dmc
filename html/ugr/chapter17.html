
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - More about AppExpress
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:30:17 2006
</div>
</div>

<!-- Generated by Ddoc from chapter17.d -->




<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc">
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="IDDE Search" onFocus='if(this.value == "IDDE Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ugr">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="ugr.html"><b>IDDE<br>Reference</b></a><br><br>
</center>

<b>Part 1: Welcome to Digital Mars C++</b><br>
    1. <a href="chapter1.html">Introducing Digital Mars C++</a></br>
    2. <a href="chapter2.html">Introducing the IDDE</a></br>
<hr>
<b>Part 2: Creating an Application with Digital Mars C++</b><br>
    3. <a href="chapter3.html">Starting a Project and Defining Workspaces</a></br>
    4. <a href="chapter4.html">Generating an Application Framework</a></br>
    5. <a href="chapter5.html">Defining Classes and Their Hierarchies</a></br>
    6. <a href="chapter6.html">Editing Program Code</a></br>
    7. <a href="chapter7.html">Adding Look and Feel with Resources</a></br>
    8. <a href="chapter8.html">Testing an Application</a></br>
<hr>
<b>Part 3: Learning Digital Mars C++ by Example</b><br>
    9. <a href="chapter9.html">Introduction to the Tutorial</a></br>
    10. <a href="chapter10.html">Lesson 1: Create the DOS Application</a></br>
    11. <a href="chapter11.html">Lesson 2: Generate an Application Framework</a></br>
    12. <a href="chapter12.html">Lesson 3: Customize the Interface</a></br>
    13. <a href="chapter13.html">Lesson 4: Add Messages with ClassExpress</a></br>
    14. <a href="chapter14.html">Lesson 5: Add a Dialog Box with ClassExpress</a></br>
<hr>
<b>Part 4: More about Creating Programs</b><br>
    15. <a href="chapter15.html">More about Projects and Workspaces</a></br>
    16. <a href="chapter16.html">More about Project Build Settings</a></br>
    17. <a href="chapter17.html">More about AppExpress</a></br>
    18. <a href="chapter18.html">More about ClassExpress</a></br>
    19. <a href="chapter19.html">Class Editor Reference</a></br>
    20. <a href="chapter20.html">Hierarchy Editor Reference</a></br>
    21. <a href="chapter21.html">Text Editor Reference</a></br>
    22. <a href="chapter22.html">Using Version Control</a></br>
<hr>
<b>Part 5: More about Testing Programs</b><br>
    23. <a href="chapter23.html">Controlling and Configuring the Debugger</a></br>
    24. <a href="chapter24.html">Commands Available in Debugging Mode</a></br>
<hr>
<b>Part 6: About Managing Resources</b><br>
    25. <a href="chapter25.html">ResourceStudio Resource Editor</a></br>
    26. <a href="chapter26.html">Dialog Editor</a></br>
    27. <a href="chapter27.html">Menu, Accelerator and String Table Editors</a></br>
    28. <a href="chapter28.html">Bitmap, Cursor, Icon, and Font Editors</a></br>
    29. <a href="chapter29.html">Version Information and Custom Resource Editors</a></br>
<hr>
<b>Part 7: Appendixes</b><br>
    A. <a href="appendixa.html">Expression Evaluation</a></br>
    B. <a href="appendixb.html">IDDE Settings and Command-Line Options</a></br>
    C. <a href="appendixc.html">Using NetBuild</a></br>

</small>

<hr>


</td>
<td valign="top">


<h1>17. More about AppExpress</h1>

Chapter 4, "Generating an Application Framework," defines an 
application framework and outlines the steps for generating a 
skeleton application using AppExpress. This companion reference 
chapter provides further detail concerning application types, 
program detail, program architecture, message maps, as well as 
generating and examining source files. 


<h2>Selecting an Application Type</h2>

Select Application Type from the list of steps at the upper left of the 
AppExpress window. The options pane at the right contains three 
groups of controls, labeled Applications, OLE Options, and Project 
Options. 

	<p>
	<img align="middle" src="figure17_1.gif">
	<p>
	[Figure 17-1 AppExpress application type options 


<h3>Applications</h3>

The group of Applications radio buttons contains six categories of 
applications. Of these, only Quick Console does not use the MFC 
library. These categories are: 

<ul>
	<li> Quick Console: The kind of application generated is 
	determined by whether the 32-Bit Project box in the 
	Project Options group is checked. See the information on 
	the Project Option group later in this section. 


	<li> Dialog Box: This standard Windows dialog box can be 
	either modal or modeless and can include dialog box 
	controls such as push buttons, textboxes, and listboxes. 


	<li> Form or Database: This is a window with the 
	functionality of a dialog box enhanced with scroll bars. It 
	is appropriate for dialog boxes that have more than one 
	screen of controls. 


	<li> Single Document Interface (SDI): This application uses a 
	single window in which the application data is displayed. 
	The OLE Options group of controls is enabled if this 
	application type is selected. 


	<li> Multiple Document Interface (MDI): This application lets 
	you display more than one window of data within a 
	parent frame window. The OLE Options group of 
	controls is enabled if this application type is selected. 


	<li> OCX Control in MFC: This template is for a custom 
	control that is an OLE2 object. 
</ul>


The application types vary in the amount of functionality that 
AppExpress generates as part of the skeleton program. For example, 
SDI applications contain only one window, while MDI applications 
contain a main window and a variable number of child windows. 

<h3>OLE Options group</h3>

The OLE Options group is enabled only if you select the SDI or MDI 
application type. The group contains four radio buttons: 

<ul>
	<li> No Support: The application is not OLE-aware: it is 
	neither a server nor a container. This option is the 
	default. 

	<li> Server: The generated application acts as an OLE2 server. 
	An OLE2 server can create or edit data, which OLE2 
	containers can link to or embed. 

	<li> Container: A host application. The generated application 
	can contain OLE2 server data elements (OLE2 objects) 
	within this host application's data. 

	<li> Server &amp; Container: The generated application acts as 
	both an OLE2 server and as an OLE2 container. 
</ul>


<h3>Project options group</h3>

The Project Options group contains two check boxes, Include Help 
and 32-Bit Project. 
<p>

Checking Include Help tells AppExpress to generate the files 
necessary to build a Windows Help file for the specified application 
type. AppExpress creates a Help subdirectory named hlp beneath 
the project directory, which contains those files. It also creates the 
file <tt>makehelp.bat</tt>, which you run to compile a Windows Help file 
from the files AppExpress provides. 
<p>

For all application types other than Quick Console, checking the 32-
Bit Project box causes the MFC 3.0 to be used instead of the 16-bit 
MFC 2.5. 
<p>

For Quick Console, leaving the box unchecked results in a skeleton 
WINIO program being generated. WINIO is a library that allows you 
to write simple Windows programs that perform input/output using 
standard C library functions (in other words, those functions 
prototyped in <tt>stdio.h</tt>.). If the 32-Bit Project box is checked, a 
Win32 console application is generated. Win32 console applications 
can only be run under Windows NT and Windows 95 (and not under 
Win32s). 
<p>

If you check the 32-Bit Project box, your application can call the 
Win32 API. 


<h2>Providing Miscellaneous Information</h2>

Selecting Miscellaneous in the steps list opens the Miscellaneous 
options page. This page lets you provide copyright information as 
well as a name for the project. 

<ul>
	<li> In the first three fields, provide a company name, suffix, 
	and copyright year. 

	<li> In the Project Name field, type a name for the project. (This 
	name is also referred to as the Windows module name.) 
</ul>

<b>Note:</b>
The module name is recorded in the module 
definition file generated by AppExpress. It can be 
changed by using the <b>Project Settings</b> dialog box, 
opened from within the IDDE by choosing <b>Settings</b> 
from the <b>Project</b> menu. 


<h2>The Document/View Architecture</h2>

The MFC library provides a number of C++ classes that, when used 
together, create the object-oriented structure for your application. 
These are the document, view, frame window, and document 
template classes. The Form or Database, SDI, and MDI application 
types all use document/view architecture. This section introduces the 
MFC classes that implement this program structure. 


<h3>Frame window</h3>

The frame window contains views on the data used by the 
application. In an SDI application, there is only one frame window, 
which is derived from the MFC class CFrameWnd. In an MDI 
application, there is a main frame window derived from 
CMDIFrameWnd, as well as document frame windows derived from 
CMDIChildWnd. 
<p>


In addition to containing child view windows, the frame window 
handles all window management— for example, minimizing, 
maximizing, and closing the window. A standard toolbar and status 
bar also are displayed in this window. 

<h3>View</h3>

Each frame window can contain a view on the data used by the 
application. A view is a C++ class derived from the class CView. 
Your application interacts with the user through this view class. 
<p>


In the SDI frame window, AppExpress generates a child view 
window that takes up the client area of the frame window. (The 
client area refers to the part of the window in which the program's 
data is displayed. It excludes the window border, caption, and 
menu.) In an SDI application, this view window is given the default 
class name CSDIAPPView. All display and printing of the 
application's data is done using this view window and its class. The 
user's manipulation of the data is also done through the view. 


<h3>Document</h3>

A document is a C++ class, derived from CDocument, that represents 
the data in your application. For example, a standard Windows 
application has a <b>File</b> menu that is a variant of the one shown in 
Figure 17-2. 

	<p>
	<img align="middle" src="figure17_2.gif">
	<p>
	[Figure 17-2 Standard Windows file menu]

When you choose <b>Open</b> from this menu, you are telling the 
program to open a document. 
<p>


<b>Note:</b> 
The word document refers to whatever type of data 
is used by the application. It does not necessarily 
mean a text-based word processing document. 
<p>


As the developer of the application, you write code in a CDocument-derived 
class to handle the operations on the <b>File</b> menu. An 
example of a skeleton CDocument-derived class follows. 

<pre>
	class CSDIAPPDoc : public CDocument
	{   
	protected: // create from serialization only
	    CSDIAPPDoc(); 
	    DECLARE_DYNCREATE(CSDIAPPDoc)
	// Attributes 
	public:
	// Operations 
	public:
	// Implementation 
	public:
	    virtual ~CSDIAPPDoc(); 
	    virtual void Serialize(CArchive&amp; ar);
	#ifdef _DEBUG 
	    virtual void AssertValid() const;
	    virtual void Dump( CDumpContext&amp; dc) const; 
	#endif
	}; 
</pre>


Notice that no member variables are included with this class. It is up 
to you as the developer to add whatever data you need for your 
application. 
<p>


In the example above, a <tt>Serialize</tt> method is included in the 
Implementation section of the class definition. This method, 
inherited from the base class, CDocument, performs object storage 
and retrieval to and from a disk file. In fact, the framework generated 
by AppExpress already handles the <b>File Open</b>, <b>File Save</b>,
and <b>File 
Save As</b> operations by automatically calling the <tt>Serialize</tt> method 
in your CDocument-derived class. You can use the <tt>Serialize</tt> 
method to implement object persistence— the ability to preserve the 
complete state of objects across multiple executions of the program. 
<p>


When you add your own member variables to this class, you should 
also override the <tt>Serialize</tt> method to read and write the added 
variables. 


<h3>Pulling it all together: the document template</h3>

Creating and managing an application's frame window, views, and 
documents is the job of another C++ class, derived from the 
CDocTemplate class. In an SDI application, the CSingleDocTemplate 
class is used; in an MDI application, the CMultiDocTemplate class is 
used. 
<p>

For more information, refer to the <i>Microsoft Foundation Class 
Library Reference</i>. 


<h2>More about Message Maps</h2>

This section outlines the purpose of message maps and identifies the 
different parts of a message. 


<h3>The rationale for maps</h3>

Using message maps saves you development time. The reason for 
this productivity improvement lies in the event-driven nature of 
Windows applications. 
<p>


As a user of a Windows application clicks on buttons, selects menus, 
drags the mouse to highlight text, or performs any other mouse or 
keyboard action, the application is notified of this action through a 
Windows message. This message contains pertinent contextual 
information such as the screen coordinates at which the mouse was 
clicked, or an identifier indicating the button that was clicked. 
<p>


The application developer decides which messages the application 
should respond to and how. If the developer decides not to write 
code to handle a particular message, the message can still be passed 
back to Windows to perform default processing. 
<p>


If you write a Windows application using the Windows SDK, these 
decisions are most likely implemented as a switch statement in the 
main window procedure (usually referred to as a <tt>WndProc</tt>). For 
example, your window procedure might look like this: 

<pre>
	LRESULT CALLBACK WndProc(HWND hwnd,
		UINT message, WPARAM wParam, LPARAM lParam) 
	{
	    switch (message)
	    {
		case WM_PAINT:
		    PAINTSTRUCT ps; 
		    BeginPaint(hwnd, &ps);
		    MyPaintProc(hwnd, ps. hdc); 
		    EndPaint(hwnd, &ps);
		    return(0); 
		case WM_CREATE:
		    hmenu = GetSystemMenu(hwnd, FALSE); 
		    AppendMenu(hmenu, MF_SEPARATOR, 0, (LPSTR) NULL); 
		    AppendMenu(hmenu, MF_STRING, IDM_ABOUT, "About..."); 
		    break;
		case WM_DESTROY: 
		    PostQuitMessage(0);
		    return(0); 
	    }
	    return DefWindowProc(hwnd, message, wParam, lParam);
	} 
</pre>


If your application must respond to many types of messages, the 
window procedure can get quite large and become difficult to 
maintain. One of the advantages of the MFC library is the use of 
message maps, which drastically reduce the amount of code 
required to process messages. 


<h3>Components of the message map</h3>

A message map is composed of the three components described in 
this section. 

<h4>BEGIN_MESSAGE_MAP, END_MESSAGE_MAP macros</h4>

All message maps must begin and end with these macros. At run-time, 
the expanded macro sets up the message mapping between 
events and the code to handle the events. 


<h4>ClassExpress-specific comment sections</h4>

AppExpress and ClassExpress add special-purpose comments to the 
message map so that ClassExpress knows where to add or remove 
mapping macros. Because ClassExpress provides an easy-to-use 
interface to your C++ class mappings, you should not manually edit 
the comments or code in a message map. 

<h4>Message-mapping macros</h4>

If a C++ class has a method (that is, a class member function) to 
respond to a message, ClassExpress writes a message-mapping 
macro for that message in the class's message map. This macro 
begins with the prefix ON_, usually followed by the macro name for 
the Windows message. The mapping macro takes two parameters: 


<ul>
	<li> The message identifier. 

	<li> The method that is called when the message event 
	occurs at run-time. 
<p>

	For example: 

<pre>
		ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint) 
</pre>


	This macro sets up a linkage between the Windows 
	message WM_COMMAND and the method <tt>OnFilePrint</tt>. 
	This method is only called, however, if the WM_COMMAND 
	parameter (in this case, the <tt>wParam</tt>) is equal to 
	ID_FILE_PRINT. This mapping macro is equivalent to 
	the following case statement in a window procedure: 


<pre>
		case WM_COMMAND:
		    if (wParam == ID_FILE_FORMAT) 
			CView::OnFilePrint(); 
</pre>


	Having the Express tools generate message maps lets 
	you concentrate on the specific function of the 
	application without having to worry about syntactical 
	issues. 
</ul>


<h2>Generating and Examining the Source Files</h2>

Generating the source files of the application framework is as easy as 
clicking on a button. After the files are generated, you may want to 
examine the header and implementation files. AppExpress typically 
generates one header and one implementation file for each class. (An 
exception is the CAboutDlg class, which shares files with the 
application class.) Examining a few generated files in the IDDE, 
setting breakpoints on methods, and tracing through their code will 
help you understand the internal workings of the frameworks that 
AppExpress generates. At that point you will then be ready to edit 
the code in order to enhance it as needed. 
<p>

To generate and examine sample source files: 

<ol>
	<li> Launch AppExpress from the IDDE <b>Tools</b> menu, and 
	make all the selections necessary to create an SDI 
	application. When you click on Finish, AppExpress 
	generates all the source files for this skeleton program. 
	When it is done, AppExpress gives control to the IDDE 
	(with the new project open), and then closes. 

	<li> Open the Project window in the IDDE by clicking the 
	Project View icon and dragging it onto the desktop, or by 
	pressing Ctrl+ Shift+ P. 

	<li> Double-click on the filename <tt>mainfrm.h</tt>. A Source 
	window opens containing the header file <tt>mainfrm.h</tt>. 
	(For more information on Source windows, see 
	Chapter 2, "Introducing the IDDE.") 
</ol>

This file, which AppExpress generated, contains the definition of the 
class CMainFrame. It is reproduced in its entirety below. 


<pre>
	// mainfrm.h : interface of the CMainFrame class 
	// 
	// Copyright (c) XYZ Corporation, 1994. All Rights Reserved. 
	// 
	// 
	class CMainFrame : public CFrameWnd 
	{   
	protected: // create from serialization only 
	    CMainFrame(); 
	    DECLARE_DYNCREATE(CMainFrame) 
	// Attributes 
	public: 
	// Operations 
	public: 
	// Implementation 
	public: 
	    virtual ~CMainFrame(); 
	#ifdef _DEBUG 
	    virtual void AssertValid() const; 
	    virtual void Dump(CDumpContext&amp; dc) const; 
	#endif 
	protected: // control bar embedded members 
	    CStatusBar m_wndStatusBar; 
	    CToolBar m_wndToolBar; 
	// Generated message map functions 
	protected: 
	    //{{ AFX_MSG(CMainFrame) 
	    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct); 
		// ClassExpress will add and remove member functions here. 
		// DO NOT EDIT these blocks of generated code ! 
	    //}} AFX_MSG DECLARE_MESSAGE_MAP() 
	}; 
</pre>



The file contains: 

<ul>
	<li> A file header that uses the company name, suffix, and 
	copyright year that you specified in AppExpress 

	<li> The CMainFrame class declaration 
</ul>


In the class declaration, notice that the status bar and toolbar are 
represented by class member variables, each of which is an instance 
of yet another C++ class. When writing code to manipulate the 
toolbar and status bar, reference these member variables. 
<p>

In the protected section of the class declaration is a prototype for a 
function that is called as part of the class's message map. As 
indicated, do not edit the code in this section because it is 
reserved for ClassExpress. 
<p>

AppExpress also generates a <tt>.cpp</tt>, or implementation, file for the 
CMainFrame class. This file has the same base name, <tt>mainfrm</tt>, as 
the class header file, but has the <tt>.cpp</tt> extension. To examine 
<tt>mainfrm.cpp</tt>, open this file in an IDDE Source window. This 
implementation file contains the following components: 


<ul>
	<li> A file header. 

	<li> Preprocessor include statements for the required header 
	files. 

	<li> A declaration of the CMainFrame message map 
	containing a single entry (for the Windows WM_CREATE 
	message). 

	<li> Static array data for initialization of the toolbar and status 
	bar. 

	<li> The definitions of the CMainFrame constructor and 
	destructor functions. Notice the comment in the 
	constructor indicating where to add member initialization 
	code. Edit these functions to insert initialization 
	and shutdown code for object instantiation. 

	<li> The definition of the class's method, <tt>OnCreate</tt>, for 
	handling WM_CREATE messages. 

	<li> The definitions of two functions— <tt>AssertValid</tt> and 
	<tt>Dump</tt>— that may be used during debugging. 

	<li> A final comment indicating where ClassExpress will add 
	stub methods for new entries in the CMainFrame 
	message map. 
</ul>


The next chapter covers ClassExpress, one of the 
tools (along with the Resource Studio) used to enhance 
an application generated by AppExpress. 



<br><br><br><br>

</td></table>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

