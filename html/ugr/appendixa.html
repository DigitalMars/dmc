
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - Expression Evaluation
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:30:17 2006
</div>
</div>

<!-- Generated by Ddoc from appendixa.d -->





<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc">
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="IDDE Search" onFocus='if(this.value == "IDDE Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ugr">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="ugr.html"><b>IDDE<br>Reference</b></a><br><br>
</center>

<b>Part 1: Welcome to Digital Mars C++</b><br>
    1. <a href="chapter1.html">Introducing Digital Mars C++</a></br>
    2. <a href="chapter2.html">Introducing the IDDE</a></br>
<hr>
<b>Part 2: Creating an Application with Digital Mars C++</b><br>
    3. <a href="chapter3.html">Starting a Project and Defining Workspaces</a></br>
    4. <a href="chapter4.html">Generating an Application Framework</a></br>
    5. <a href="chapter5.html">Defining Classes and Their Hierarchies</a></br>
    6. <a href="chapter6.html">Editing Program Code</a></br>
    7. <a href="chapter7.html">Adding Look and Feel with Resources</a></br>
    8. <a href="chapter8.html">Testing an Application</a></br>
<hr>
<b>Part 3: Learning Digital Mars C++ by Example</b><br>
    9. <a href="chapter9.html">Introduction to the Tutorial</a></br>
    10. <a href="chapter10.html">Lesson 1: Create the DOS Application</a></br>
    11. <a href="chapter11.html">Lesson 2: Generate an Application Framework</a></br>
    12. <a href="chapter12.html">Lesson 3: Customize the Interface</a></br>
    13. <a href="chapter13.html">Lesson 4: Add Messages with ClassExpress</a></br>
    14. <a href="chapter14.html">Lesson 5: Add a Dialog Box with ClassExpress</a></br>
<hr>
<b>Part 4: More about Creating Programs</b><br>
    15. <a href="chapter15.html">More about Projects and Workspaces</a></br>
    16. <a href="chapter16.html">More about Project Build Settings</a></br>
    17. <a href="chapter17.html">More about AppExpress</a></br>
    18. <a href="chapter18.html">More about ClassExpress</a></br>
    19. <a href="chapter19.html">Class Editor Reference</a></br>
    20. <a href="chapter20.html">Hierarchy Editor Reference</a></br>
    21. <a href="chapter21.html">Text Editor Reference</a></br>
    22. <a href="chapter22.html">Using Version Control</a></br>
<hr>
<b>Part 5: More about Testing Programs</b><br>
    23. <a href="chapter23.html">Controlling and Configuring the Debugger</a></br>
    24. <a href="chapter24.html">Commands Available in Debugging Mode</a></br>
<hr>
<b>Part 6: About Managing Resources</b><br>
    25. <a href="chapter25.html">ResourceStudio Resource Editor</a></br>
    26. <a href="chapter26.html">Dialog Editor</a></br>
    27. <a href="chapter27.html">Menu, Accelerator and String Table Editors</a></br>
    28. <a href="chapter28.html">Bitmap, Cursor, Icon, and Font Editors</a></br>
    29. <a href="chapter29.html">Version Information and Custom Resource Editors</a></br>
<hr>
<b>Part 7: Appendixes</b><br>
    A. <a href="appendixa.html">Expression Evaluation</a></br>
    B. <a href="appendixb.html">IDDE Settings and Command-Line Options</a></br>
    C. <a href="appendixc.html">Using NetBuild</a></br>

</small>

<hr>


</td>
<td valign="top">


<h1>A. Expression Evaluation</h1>

An expression comprises operands and operators, such as constants, 
variables, and functions. You can specify variables and functions 
using their symbolic names defined in your program. Digital Mars C++ 
supports standard language operators. This manual does not provide 
a complete discussion of language expressions. 


<h2>Entering Expressions</h2>

The following IDDE operations prompt you to enter an expression: 

<ul>
	<li> Modifying a variable 
	<li> Modifying a memory location 
	<li> Modifying a CPU register 
	<li> Setting a conditional breakpoint 
	<li> Evaluating an expression 
	<li> Specifying an array index 
	<li> Specifying a memory address 
	<li> Specifying a live memory expression 
</ul>

When one of these operations is executed, the debugger displays the 
<b>Expression</b> dialog box, shown in Figure A-1. For example, to 
modify a variable in the Data/Object window, you can input a new 
value by entering an expression. The debugger evaluates this 
expression and assigns the result to the variable. 


	<p>
	<img align="middle" src="figurea_1.gif">
	<p>
	Figure A-1 Expression dialog box 

<h2>Symbols and Their Scope</h2>

A symbol is the name of a variable, procedure, module, or 
enumerated symbol in your program. You declare symbols in the 
scope of a procedure or module. When you use a symbol in an 
expression, the debugger determines its scope based on the module, 
procedure, and line where the current instruction is located. 
<p>

The IDDE expression evaluator tries to match an entered symbol 
against: 


<ul>
	<li> A symbol in the current procedure 
	<li> The current procedure's name 
	<li> A global symbol in the current module 
	<li> The current module's name 
	<li> Any other module's name 
</ul>


If you want the debugger to search for a symbol in other procedures 
or modules, you must qualify the symbol by using a scope override 
(described below). 


<h3>Scope override</h3>

You can override the current scope where the debugger looks for a 
symbol by qualifying the symbol with a module or a procedure 
name. To override the current scope, use the syntax: 

	<pre>
	[<i>ModuleName.</i>][<i>ProcName</i>.] <i>SymbolName</i> 
	</pre>

The debugger looks for the symbol <i>SymbolName</i> in the procedure 
<i>ProcName</i> declared in the module <i>ModuleName</i>. For example, if you 
enter: 

	<pre>
	InOut.WriteString.i
	</pre>
 
the debugger tries to find the symbol i in the scope of the 
procedure <tt>WriteString</tt> declared in the module <tt>InOut</tt>. 
<p>


If you do not include the module name, the debugger uses the 
current module (the module containing the current instruction). 
<p>


For example, if you enter: 

	<pre>
	WriteString.i 
	</pre>

the debugger tries to find the symbol <tt>i</tt> in the scope of the 
procedure <tt>WriteString</tt> declared in the module displayed in the 
Source window. 
<p>


If you specify a module name but not a procedure name, the 
debugger uses the global scope of the module specified. For 
example, if you enter: 

	<pre>
	InOut.i
	</pre>
 
the debugger tries to find the symbol <tt>i</tt> in the global scope of the 
module <tt>InOut</tt>. 


<h3>Register symbols</h3>

To evaluate processor register values, use the symbols listed in the 
following tables: 

	<pre>
	Table A-1 Processor registers, 16-bit 

	Symbol		Register 

	AX or ax	AX 
	BX or bx	BX 
	CX or cx	CX 
	DX or dx	DX 
	SI or si	SI 
	DI or di	DI 
	SS or ss	SS 
	DS or ds	DS 
	CS or cs	CS 
	ES or es	ES 
	SP or sp	SP 
	BP or bp	BP 
	IP or ip	IP 
	_F or _f	Flags 
	FS		FS available only when debugging in 32-bit mode 
	GS		GS available only when debugging in 32-bit mode 


	Table A-2 Processor registers, 32-bit (available only when debugging 
	in 32-bit mode) 


	Symbol		Register 

	EAX or eax	EAX 
	EBX or ebx	EBX 
	ECX or ecx	ECX 
	EDX or edx	EDX 
	ESI or esi	ESI 
	EDI or edi	EDI 
	ESP or esp	ESP 
	EBP or ebp	EBP 
	EIP or eip	EIP 


	Table A-3 Floating point stack registers 

	Symbol		Floating point stack 

	FP0 or fp0	ST(0) 
	FP1 or fp1	ST(1) 
	FP2 or fp2	ST(2) 
	FP3 or fp3	ST(3) 
	FP4 or fp4	ST(4) 
	FP5 or fp5	ST(5) 
	FP6 or fp6	ST(6) 
	FP7 or fp7	ST(7) 
	</pre>


<h2>Operators</h2>

The IDDE supports standard C and C++ operators in expressions. 
These operators, described in the following sections, have the same 
precedence within the debugger's expression evaluator as they do in 
C and C++. 
<p>


In addition to the standard operators in C and C++, the IDDE 
supports the colon operator (:). The colon operator joins a 
<i>segment:offset</i> pair of unsigned integers to specify an address value. 
This operator has the same priority as the unary operators. 
<p>


The IDDE supports the standard C and C++ operators listed below, 
in descending order of precedence: 


<h3>Primary</h3>

	<pre>
	() [] -&gt; . this :: 
	</pre>

<h3>Unary</h3>

	<pre>
	* &amp; -! ~ ++ --sizeof 
	</pre>


<h3>Binary</h3>

	<pre>
	.* -&gt;* 
	* / % + -
	&gt;&gt; &lt;&lt; &gt; &lt; &gt;= &lt;= 
	== != &amp; 
	^ | 
	&amp;&amp; || 
	</pre>

<h3>Assignment</h3>

	<pre>
	 = += -= *= /= %= &gt;&gt;= &lt;&lt;= 
	&amp;= ^= |= 
	</pre>


C expressions in the IDDE also may include typecasts of the form: 

	<pre>
	(<i>type-name</i>) <i>expression</i> 
	</pre>

For C++, the above typecast is valid only for built-in types. 
Because the debugging information does not associate line numbers 
with local scopes, the IDDE cannot distinguish variables declared in 
a local scope. For example, in line 7 of the following source code: 


	<pre>
	1 int i; 
	2 proc() 
	3 { 
	4     int i; 
	5     if (i){ 
	6         int i; 
	7         i= 5; 
	8     } 
	9 } 
	</pre>


The intent is for the variable <tt>i</tt> in <tt>i = 5</tt> to refer to
the <tt>i</tt> in line 6, but 
the IDDE will associate it with the <tt>i</tt> in line 4. 


<h2>Considerations When Using C++ Expressions</h2>

This section describes considerations for working with the IDDE 
expression evaluator and C++ expressions. 
<p>

The expression evaluator generally expects the same syntax as the 
compiler. 

<h3>Access to class members</h3>

All members of a class object are accessible, no matter which type of 
access control is imposed (public, protected, or private), or if the 
object is a member of a base class (embedded object). 
<p>


For example, if class <tt>Customer</tt> has a private member name, enter 
the following into the IDDE expression evaluator: 

	<pre>
	Customer::name 
	</pre>

The expression evaluator provides the value of name in an output 
dialog box. You also can access members of an object using a 
pointer to the object. 
<p>


For example, if the <tt>Salesperson</tt> class defines a virtual function 
named <tt>totalSales</tt>, redefined in the class inherited from 
<tt>Salesperson</tt>, <tt>totalSales</tt> can be called using a pointer to 
<tt>Salesperson</tt>: 


	<pre>
	salePtr-&gt;totalSales() 
	</pre>


<h3>Ambiguous references</h3>

When an expression makes an ambiguous reference to a member 
name, qualify it with the class name. For example, the 
class <tt>Resistor</tt> is defined as follows: 


	<pre>
	1 class Parts 
	2 { 
	3   unsigned int specs; 
	4 } resistorParts; 
	5 
	6 class Components 
	7 { 
	8   unsigned int specs; 
	9 } resistorComponents; 
	10 
	11 class Resistor: 
	12 public Parts, public Components; 
	13 { 
	14   int name; 
	15 } resistor; 
	16 ... 
	</pre>


Assume that class <tt>Resistor</tt> inherits from the <tt>Parts</tt> and 
<tt>Components</tt> classes. Both <tt>Parts</tt> and <tt>Components</tt> define a 
member item called <tt>specs</tt>. If <tt>largeResistor</tt> is an instance of 
class <tt>Resistor</tt>, the following expression is ambiguous: 

	<pre>
	largeResistor.specs 
	</pre>

To resolve this problem, use either of the following expressions: 

<ul>
	<li> <tt>largeResistor.Parts::specs</tt>
	<li> <tt>largeResistor.Components::specs</tt>
</ul>


<h3>Constructors and destructors</h3>

The IDDE expression evaluator calls constructor or destructor 
functions just as it calls normal functions. Functions that declare or 
return local objects are valid expressions, and they return the 
address of the resulting object. 
<p>


<b>Note:</b> 
The IDDE expression evaluator does not let you call 
the new and delete operators. 


<h3>Overloaded functions</h3>

The IDDE expression evaluator supports calling overloaded 
functions only if an exact match exists or if the match does not need 
a conversion involving the construction of an object. For example, 
the overloaded function <tt>Print</tt> is defined as below: 


	<pre>
	1 Print( int x) 
	2 { 
	3   ... 
	4 } 
	5 
	6 Print( float y) 
	7 { 
	8   ... 
	9 }
	</pre>

In this case, both of the following expressions for the IDDE 
expression evaluator are valid: 

<ul>
	<li> <tt>Print(5.5);</tt>
	<li> <tt>Print(5);</tt>
</ul>


<h3>Overloaded operators</h3>

IDDE's expression evaluator lets you call an overloaded operator for 
user-defined types. For example, suppose you define a class that 
represents arrays as follows: 
	
	<pre>
	class Array array1, array2, array3, array4 
	</pre>

If this class has a member function that overloads the + operator, 
then you can evaluate the following: 

	<pre>
	array1 = array2 + array3 + array4 
	</pre>

Make sure that no variables overflow during evaluation. The 
expression evaluator automatically creates temporary objects as 
needed to store the intermediate values and discards them after it 
performs the evaluation. 


<h2>Function and Procedure Calls</h2>

The IDDE lets you execute function and procedure calls defined in 
your program when evaluating an expression. Use this feature to: 

<ul>
	<li> Insert a call in your program. 

	<li> Call a procedure that you define to display your 
	program's data in a customized format, such as a graph, 
	a table, or a statistical chart. 

	<li> Use a function call as a condition for a breakpoint. When 
	the breakpoint is reached, the function is called. 
	Depending on the return value, the debugger stops your 
	program's execution. 
</ul>


To include a function call in an expression, use the syntax: 

	<pre>
	procedureName([param1[, param2]...]) 
	</pre>

You can specify the procedure parameters as expressions. The IDDE 
passes all parameters by value. 


<h3>Evaluating expressions with function calls</h3>

The IDDE evaluates expressions, except for function and procedure 
calls, by interpretation. When the interpreter encounters a function 
call, it saves the application's registers and pushes its own evaluation 
stack onto the application program's stack. Next, the debugger 
orders the application to begin executing at the function's entry 
point. If the <b>Flip Screen</b> command is on, the application's screen 
comes to the foreground. When the application's procedure returns, 
the debugger takes control and restores the application's register 
state. During the evaluation of a procedure or a function, the 
debugger ignores breakpoints and watchpoints. It takes the return 
value and continues evaluating the expression, if necessary. 


<h3>Side effects of expression evaluation</h3>

When including function or procedure calls in the IDDE expressions, 
beware of possible side effects caused when you evaluate a function 
that results in changes to your program's data. Such changes could 
alter the behavior of your program after it resumes execution. 


<h2>Expression Evaluation Errors</h2>

The IDDE normally evaluates an expression and displays the 
result after you press Enter. However, with the <b>Set Conditional 
Breakpoint</b> command, the IDDE does not evaluate an expression 
until it reaches the breakpoint. If a run-time error occurs during the 
evaluation of a conditional breakpoint expression, the IDDE assumes 
that the expression is false and does not display an error message. 
<p>


When the IDDE finds a syntax or semantic error in an expression, it 
displays the error message in the title bar of the debugger's main 
window. 



<br><br><br><br>

</td></table>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

