
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->

<head>
<META http-equiv="content-type" content="text/html; charset=utf-8" >
<title>Digital Mars - More about ClassExpress
</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<div id="heading">
<a href="http://www.digitalmars.com/"><IMG SRC="dmlogo.gif" BORDER=0 WIDTH=270 HEIGHT=53 ALT="www.digitalmars.com"></a>

<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
| <a href="../advancedsearch.html" title="Search Digital Mars web site">Search</a>
| <a href="../ctg/ctg.html" title="Compiler & Tools Guide">CTG</a>
| <a href="../rtl/rtl.html" title="Runtime Library Reference">RTL</a>
| <a href="../ugr/ugr.html" title="IDDE Reference">IDDE</a>
| <a href="../stl/index.html" title="Standard Template Library">STL</a>

	<div id="lastupdate">Last update Fri Apr 28 16:30:17 2006
</div>
</div>

<!-- Generated by Ddoc from chapter18.d -->





<table border=1 cellpadding=8 cellspacing=0 frame="void" summary="this table is for layout only">
<tr>
<td valign="top" class="toc">
<small>
<center>
<form method="get" action="http://www.google.com/search">
<input id="q" name="q" size="10" value="IDDE Search" onFocus='if(this.value == "IDDE Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/ugr">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</form>

    <a href="ugr.html"><b>IDDE<br>Reference</b></a><br><br>
</center>

<b>Part 1: Welcome to Digital Mars C++</b><br>
    1. <a href="chapter1.html">Introducing Digital Mars C++</a></br>
    2. <a href="chapter2.html">Introducing the IDDE</a></br>
<hr>
<b>Part 2: Creating an Application with Digital Mars C++</b><br>
    3. <a href="chapter3.html">Starting a Project and Defining Workspaces</a></br>
    4. <a href="chapter4.html">Generating an Application Framework</a></br>
    5. <a href="chapter5.html">Defining Classes and Their Hierarchies</a></br>
    6. <a href="chapter6.html">Editing Program Code</a></br>
    7. <a href="chapter7.html">Adding Look and Feel with Resources</a></br>
    8. <a href="chapter8.html">Testing an Application</a></br>
<hr>
<b>Part 3: Learning Digital Mars C++ by Example</b><br>
    9. <a href="chapter9.html">Introduction to the Tutorial</a></br>
    10. <a href="chapter10.html">Lesson 1: Create the DOS Application</a></br>
    11. <a href="chapter11.html">Lesson 2: Generate an Application Framework</a></br>
    12. <a href="chapter12.html">Lesson 3: Customize the Interface</a></br>
    13. <a href="chapter13.html">Lesson 4: Add Messages with ClassExpress</a></br>
    14. <a href="chapter14.html">Lesson 5: Add a Dialog Box with ClassExpress</a></br>
<hr>
<b>Part 4: More about Creating Programs</b><br>
    15. <a href="chapter15.html">More about Projects and Workspaces</a></br>
    16. <a href="chapter16.html">More about Project Build Settings</a></br>
    17. <a href="chapter17.html">More about AppExpress</a></br>
    18. <a href="chapter18.html">More about ClassExpress</a></br>
    19. <a href="chapter19.html">Class Editor Reference</a></br>
    20. <a href="chapter20.html">Hierarchy Editor Reference</a></br>
    21. <a href="chapter21.html">Text Editor Reference</a></br>
    22. <a href="chapter22.html">Using Version Control</a></br>
<hr>
<b>Part 5: More about Testing Programs</b><br>
    23. <a href="chapter23.html">Controlling and Configuring the Debugger</a></br>
    24. <a href="chapter24.html">Commands Available in Debugging Mode</a></br>
<hr>
<b>Part 6: About Managing Resources</b><br>
    25. <a href="chapter25.html">ResourceStudio Resource Editor</a></br>
    26. <a href="chapter26.html">Dialog Editor</a></br>
    27. <a href="chapter27.html">Menu, Accelerator and String Table Editors</a></br>
    28. <a href="chapter28.html">Bitmap, Cursor, Icon, and Font Editors</a></br>
    29. <a href="chapter29.html">Version Information and Custom Resource Editors</a></br>
<hr>
<b>Part 7: Appendixes</b><br>
    A. <a href="appendixa.html">Expression Evaluation</a></br>
    B. <a href="appendixb.html">IDDE Settings and Command-Line Options</a></br>
    C. <a href="appendixc.html">Using NetBuild</a></br>

</small>

<hr>


</td>
<td valign="top">


<h1>18. More about ClassExpress</h1>

Chapter 4 defined the concept of an application framework and 
outlined the steps for building on your skeleton application using 
ClassExpress. This companion reference chapter provides more 
detail about using ClassExpress, including: 


<ul>
	<li> Deriving a class to handle user interface events in your 
	program 

	<li> Working with Dialog Data Exchange (DDX) and Dialog 
	Data Validation (DDV) 

	<li> Enabling a C++ class as an OLE2 automation server or 
	client 

	<li> Deriving a C++ class from an existing Visual Basic 
	custom control (VBX) 
</ul>


<h2>Deriving a Class to Handle User Interface Events</h2>

With ClassExpress, you can derive a new class designed to handle 
user interface events such as menu selections and button clicks 
directly from a Microsoft Foundation Class (MFC) library class. 
Suppose, for example, that you want to add a new dialog box to 
your application. To derive a class from the CDialog class using 
ClassExpress, follow these steps: 

<ol>
	<li> Create an application framework for a standard SDI 
	program using AppExpress (for details, see Chapter 4, 
	"Generating an Application Framework"). 

	<li> Use ResourceStudio to create a new dialog box resource 
	(see Chapter 7, "Adding Look and Feel with Resources"). 

	<li> Launch ClassExpress from ResourceStudio or from the 
	IDDE's <b>Tools</b> menu. 

	<li> Add a new class to your program by clicking on the Add 
	Class button. (Follow the instructions in Chapter 4, 
	"Generating an Application Framework.") Be sure to 
	derive the new class from the Dialog class type. 
	<p>

	In ClassExpress, all of the base classes from which you 
	derive new classes are themselves derived from the MFC 
	class CCmdTarget. The MFC Library Reference defines 
	CCmdTarget as the base class for the message map 
	architecture. Any class derived from CCmdTarget inherits 
	the ability to respond to user interface events such as 
	menu and toolbar selections and dialog box actions. 
	<p>

	<li> In the ClassExpress main window, verify that your class 
	has been created by browsing through the Class drop-down 
	list. 

	<li> Select the new class name from the Class list. Note that 
	the list of Control IDs and Windows messages for your 
	derived dialog box class is different from the list for non-dialog 
	classes. 
</ol>


<b>Note:</b> 
ClassExpress filters out the Control IDs and 
Windows messages that do not apply for the 
selected class name. For example, dialog box 
classes can handle the WM_INITDIALOG message, 
but this message is not handled by any class derived 
from CFrameWnd. 
<p>

The ability to add new classes that derive specialized message-handling 
functionality from the base MFC classes is one of the 
benefits of using ClassExpress. The following material summarizes 
the type of functionality that a new class inherits if it is derived from 
CCmdTarget. For more information on any of these base classes, 
refer to the <i>Microsoft Foundation Class Library Reference</i>. 

<dl>
<dt><b>CmdTarget:</b> <dd>The base class for all MFC classes that offer 
support for Windows message handling. You probably 
will not derive a new class directly from CmdTarget; 
instead, use the other base classes in this list. 

<dt><b>Dialog:</b> <dd>This class implements dialog boxes, either modal 
or modeless. It usually is associated with a dialog box 
resource template created in ResourceStudio. Member 
variables of this class typically are mapped to fields or 
controls in the dialog box. For details on how this 
mapping is established, see the next section, "Working 
with Data Transfer: DDX and DDV." 

<dt><b>Document:</b> <dd>The application's data is represented by the 
document class. The data can be anything the 
programmer chooses. All file input and output should be 
handled within the document class. 

<dt><b>FormView:</b> <dd>A class of views that has built-in support for 
scrolling and for child controls. FormViews typically are 
combined with a dialog box resource template. One way 
in which the FormView class differs from the Dialog class 
is its added support for scrolling. 

<dt><b>FrameWnd:</b> <dd>The main window class for single document 
interface (SDI) applications. 

<dt><b>MDIChildWnd:</b> <dd>The child document window class for 
multiple document interface (MDI) applications. 

<dt><b>ScrollView:</b> <dd>A class of view window that supports 
scrolling. 

<dt><b>View:</b> <dd>The base class that provides the connection 
between the document class representing the program 
data and the user interface to that data. 

<dt><b>Wnd:</b> <dd>The base class for any window, including dialog 
boxes, frame windows, views, and dialog box controls. 
Because this class is used to derive many of the other 
classes listed here, choose Wnd as a base for a new class 
if other choices do not satisfy your programming 
requirements. 

<dt><b>Splitter:</b> <dd>This special type of window can contain 
multiple panes. A pane is usually a window that is 
associated with a View-derived class in the application. 
</dl>

<h2>Working with Data Transfer: DDX and DDV</h2>

The previous section discussed the architecture classes that you use 
to build an object-oriented Windows program with the MFC library. 
The application, document, view, template, and frame window 
objects are the key components of a standard Windows, MFC-based 
application. 
<p>


This section describes MFC library support for data transfer between 
dialog boxes or other windows and your C++ objects that store that 
data. This is referred to as Dialog Data Exchange (DDX) and Dialog 
Data Validation (DDV). You use the Data Transfer options of 
ClassExpress to bind class member variables to dialog box or 
window controls. 
<p>


<b>Note:</b> 
Data transfer using DDX/DDV can be applied to 
any window that is derived from the MFC base 
class, CWnd. It is not restricted to dialog boxes 
derived from CDialog. 
<p>

Dialog Data Exchange with Windows 95 Common 
Controls is also supported. 


<h3>Implementing Dialog Data Exchange (DDX) using ClassExpress</h3>

To implement DDX using ClassExpress, use the following steps. 
Before performing these steps, generate a dialog box application 
with AppExpress, then: 

<ol>
	<li> Add a few edit controls to your skeleton dialog box 
	using ResourceStudio. 

	<li> Launch ClassExpress from ResourceStudio or from the 
	IDDE's <b>Tools</b> menu. ClassExpress loads the project and 
	displays the Message Maps options. 

	<li> In the upper-left listbox, click on Data Transfer. From the 
	Class drop-down list, select the CMainDialog class. 
	<p>

	The ClassExpress window should look similar to that 
	shown in Figure 18-1. 

	<p>
	<img align="middle" src="figure18_1.gif">
	<p>
	[Figure 18-1 Data Transfer page in ClassExpress 
	<p>

	<li> Click on the Add Variable button. The <b>Add Member 
	Variable</b> dialog box shown in Figure 18-2 opens. 

	<p>
	<img align="middle" src="figure18_2.gif">
	<p>
	[Figure 18-2 Add Member Variable dialog box 
	<p>

	<li> From the Control ID drop-down list, select a dialog box 
	control that you want to map to a class member variable. 

	<li> Edit the Member Variable Name to specify the name of a 
	variable to be mapped to the selected Control ID. The 
	variable does not have to exist in the class. (ClassExpress 
	adds it automatically to the class for you.) 
	<p>

	<b>Note:</b> 
	Nonstatic class member variable names are usually 
	prefixed with m_for easy identification; however, 
	you are not required to follow this convention. 
	<p>

	<li> For DDX Type, select Control to map the control ID and 
	variable name to a control class (such as CButton or 
	CEdit). Select Value to map to a CString or to a numeric 
	type. 

	<li> Select a Variable Type for this member variable from the 
	Variable Type drop-down box. The available types 
	depend on the type of control being mapped and the 
	DDX Type option. 

	<li> If you selected Value from the Type radio buttons, one 
	or two additional fields are displayed along the bottom 
	of the dialog box. If the added member variable is of a 
	numerical variable type, two fields are displayed, which 
	allow you to set the minimum and maximum ranges for 
	the variable's value. If the variable type is CString, then 
	only one field is displayed, in which you specify the 
	maximum number of characters that the CString can 
	contain. (You cannot specify a minimum number of 
	characters.) 
	<p>

	Figure 18-3 shows an example using a CString 
	variable type. 


	<p>
	<img align="middle" src="figure18_3.gif">
	<p>
	[Figure 18-3 Adding a CString member variable 
	<p>

	<li> Click OK. You are now back in the ClassExpress 
	window, and the member variable you just added is 
	displayed in the spreadsheet. If you added minimum or 
	maximum values for your member variable, a dialog data 
	validation function name is displayed in the DDV type 
	field. 
</ol>


<h3>Understanding data transfer at the source code level</h3>

The procedure in the preceding section instructs ClassExpress to 
establish a link between your CMainDialog class and a control within 
a dialog box. In the implementation file <tt>maindlg.cpp</tt> are calls to 
virtual functions that CMainDialog inherits from other MFC classes. 
These functions perform the dialog data exchange and validation 
(DDX/DDV) for your program. 
<p>


This section explores the source code generated by ClassExpress and 
explains the implementation of data transfer— the first step in how 
DDX functions bind member variables to dialog box objects to 
transfer data between the variables and the controls. Next, the 
validation of values entered into dialog box controls is explained. 
The third section describes how data transfer functions are invoked 
by the UpdateData function. 


<h4>Dialog Data Exchange (DDX)</h4>

To implement DDX, follow these steps: 

<ol>
	<li> Select <b>Open</b> from the IDDE's <b>Project</b> menu to open the 
	dialog box project you created earlier. 

	<li> Open the <tt>maindlg.cpp</tt> file in a Source window. Either 
	double-click on <tt>maindlg.cpp</tt> in the Project window or 
	open an empty Source window, then open the source 
	file using the <b>Open</b> command in the <b>File</b> menu. 

	<li> From the <b>Edit</b> menu, choose <b>Find</b> and search for 
	<tt>DoDataExchange</tt>. Look at the definition for the 
	method <tt>CMainDialog::DoDataExchange</tt>. 
	ClassExpress has overridden the CWnd method 
	<tt>DoDataExchange</tt> in your CMainDialog class. A sample 
	implementation of DoDataExchange follows. 
</ol>

<pre>
	void CMainDialog::DoDataExchange(CDataExchange* pDX) 
	{   
	    CDialog::DoDataExchange(pDX); 
	    //{{ AFX_DATA_MAP(CMainDialog) 
	    DDX_Control(pDX, IDABOUT, m_About); 
	    DDX_Control(pDX, IDOK, m_OKButn); 
	    DDX_Control(pDX, IDCANCEL, m_CancelButn); 
	    DDX_Control(pDX, IDHELP, m_Help); 
	    //}} AFX_DATA_MAP 
	} 
</pre>

DDX lets you copy data easily from class member variables to dialog 
box controls, then from the controls back to the member variables. 
This is accomplished by implementing an override for the 
<tt>CWnd::DoDataExchange</tt> method in your dialog box class. For 
each control that is mapped to a member variable, ClassExpress 
generates a call to a DDX function. There are four DDX function 
calls in the code sample shown above. 
<p>

DDX functions take the form: 

<pre>
	DDX_<i>xxx</i>(pDX, nIDC, Data); 
</pre>

where: 

<ul>
	<li> <tt>pDX</tt> is a pointer to a <tt>CDataExchange</tt> object. This 
	object contains context information such as the dialog 
	box instance and whether the data exchange is from the 
	member variable to the control or vice versa. 

	<li> <tt>nIDC</tt> is the dialog box control ID. 

	<li> <tt>Data</tt> is the member variable in your dialog class. 
</ul>


<b>Note:</b> 
DDX functions that exchange data with Visual Basic 
custom controls (VBXs) take an additional 
parameter, nPropIndex— the property index being 
exchanged. This parameter is shown before the 
Data parameter. 
<p>

The preceding sections cover how ClassExpress prompts you for 
new member variables, then generates code that performs automatic 
data exchange between those variables and their respective dialog 
box or window controls. The next section describes how to enhance 
data exchange by using data validation. 


<h4>Dialog Data Validation (DDV)</h4>

When adding a new variable using the Data Transfer options in 
ClassExpress, you can define minimum and maximum values for 
numeric variables and maximum lengths for CString variables. This is 
illustrated in Figure 18-4 below. 

	<p>
	<img align="middle" src="figure18_4.gif">
	<p>
	[Figure 18-4 Adding a numeric member variable 
	<p>

In this example, the member variable <tt>m_PayTo</tt> is defined as an 
integer and is limited to values between 100 and 5000. This variable 
is bound to a dialog box edit control identified by IDC_PAYTO. The 
user of the application is not allowed to enter a value in that control 
that is outside the minimum and maximum bounds. 
<p>


You do not have to write a single line of code to enforce this rule. 
The DDV functions in the MFC library do this for you. After adding 
the variable <tt>m_PayTo</tt>, as shown earlier, and clicking Close in 
ClassExpress's main window, ClassExpress writes the following lines 
to the DoDataExchange method of your dialog box class: 

<pre>
	DDX_Text(pDX, IDC_PAYTO, m_PayTo);
	DDV_MinMaxLong(pDX, m_PayTo, 100, 5000); 
</pre>


The first line binds the edit control to your <tt>m_PayTo</tt> member 
variable. This uses a DDX function, as discussed earlier in this 
chapter. The second line is the DDV function that limits values in the 
textbox control to between 100 and 5000. 
<p>


<b>Note:</b> 
For each member variable, the DDV function call 
should immediately follow the DDX function call in 
your <tt>DoDataExchange</tt> function. This is a 
requirement of the application framework and is 
enforced when ClassExpress writes new DDX/DDV 
function calls to the source code file. 
<p>


DDV functions take the following form: 

<pre>
	DDV_<i>xxx</i>(pDX, Data, ...); 
</pre>

where: 

<ul>
	<li> <tt>pDX</tt> is a pointer to a <tt>CDataExchange</tt> object. This 
	object contains context information such as the dialog 
	box instance and whether the data exchange is from the 
	member variable to the control or vice versa. 

	<li> <tt>Data</tt> is the member variable in your dialog class. 

	<li> ... indicates the remaining arguments: minimum and 
	maximum values for numerical variables, and maximum 
	number of characters for strings. 
</ul>


<h4>Calling UpdateData</h4>

Your dialog class's <tt>DoDataExchange</tt> method is called by another 
CWnd method, <tt>UpdateData</tt>, whose prototype follows: 

<pre>
	BOOL UpdateData(BOOL fSaveOrValidate); 
</pre>

If the parameter to <tt>UpdateData</tt> is <tt>FALSE</tt>, then the function 
updates the dialog box controls with data from class member 
variables that have been mapped to the controls. If the parameter is 
<tt>TRUE</tt>, then the member variables are updated with data from the 
controls and validated. 
<p>


You call <tt>UpdateData</tt> from the places in your program at which 
you want to exchange data with the dialog box. <tt>UpdateData</tt> is 
called for you automatically in only one place in the dialog 
initialization. 
<p>


In response to the WM_INITDIALOG message, the 
<tt>CDialog::OnInitDialog</tt> method calls <tt>UpdateData</tt> with a 
parameter equal to <tt>FALSE</tt>, indicating that the controls are being set. 
Initialize the values of a dialog class's member variables in your 
<tt>OnInitDialog</tt> method. For example: 


<pre>
	BOOL CMainDialog::OnInitDialog() 
	{   
	    m_ColorIsRedCheckBox = TRUE; 
	    m_Filter = FILTER_NONE; 
	    CDialog::OnInitDialog(); 
	} 
</pre>


Here two member variables, <tt>m_Color</tt> and <tt>m_Filter</tt>, are set to 
initial values. When the <tt>CDialog::OnInitDialog</tt> method is 
called, it uses those values to set the state of the dialog box controls 
mapped to these member variables. 


<h2>Making Your Application an OLE Automation Server</h2>


This section covers the following topics: 

<ul>
	<li> The definition of an OLE automation server 

	<li> The difference between creating an automation server in 
	ClassExpress and a standard OLE server in AppExpress 

	<li> The mechanics of creating an OLE automation server 
	using ClassExpress 

	<li> The source code that ClassExpress generates to 
	implement OLE automation 
</ul>


<b>Note:</b> 
Use of the acronym OLE (object linking and 
embedding) in this section refers to version 2 of 
OLE, which includes automation support. 


<h3>What is an OLE automation server?</h3>

OLE automation is an architecture that allows programs to 
manipulate objects within other applications. The application that 
defines the objects is called the automation server. Any application 
that uses OLE to manipulate another application's objects is called an 
automation client. For example, Microsoft Excel is an automation 
server, and Microsoft Visual Basic is an automation client. From 
within Visual Basic, you can write a program that loads an Excel 
spreadsheet, runs Excel macros, and saves the spreadsheet. 


<h3>OLE automation server vs. OLE server</h3>

OLE automation is an extension of the original object linking and 
embedding technology that originated in version 1 of OLE. The 
linking and embedding features determine how data from one 
application is used in another. For example, you can embed a 
spreadsheet document within a word processing document, or link a 
word processing document to a spreadsheet document that exists in 
a file. 
<p>


<b>Note:</b> 
An embedded object's data is saved as part of the 
client application's data. A linked object's data is 
saved independently of the client's data; the client's 
data contains a reference to the filename of the 
linked data. 
<p>


In these examples, the application that is the container for the 
spreadsheet is called an OLE client or a container application. The 
application that originally created the spreadsheet and that is used to 
edit the spreadsheet is called the OLE server application. The server 
application is responsible for creating and maintaining data objects 
embedded in or linked to another application. 
<p>


When you create an OLE server application with AppExpress, you 
are making it possible for your application's data to be embedded in 
or linked to another application's data. 
<p>


OLE automation was introduced in the second version of the OLE 
technology. Automation has nothing to do with embedding or 
linking to data objects. It is used to manipulate objects that an OLE 
automation server has created. 
<p>


Using OLE automation to manipulate an object allows you to do 
some or all of the following: 


<ul>
	<li> Query and change the properties of an object 
	<li> Call functions that are defined in the object 
	<li> Be notified when an object triggers a specific event 
</ul>


Although an OLE server might provide embedding, linking, and 
automation support, all three options do not have to be provided. 
For example, you could create an automation server that only 
performs mathematical calculations, has no user interface, and is 
accessible only by function calls through the OLE automation 
interface. In this case, you only need an OLE automation server. 
Linking and embedding technology, which is packaged in a standard 
OLE server, is not required. 


<h3>Enabling your application to be an OLE automation server</h3>

This section assumes that you have generated a sample MFC-based 
application framework with AppExpress. You use that framework in 
this section. 
<p>


To enable your application to be an OLE automation server: 

<ol>
	<li> With the project containing your sample application 
	framework loaded in the IDDE, launch ClassExpress by 
	choosing it from the <b>Tools</b> menu in the IDDE's main 
	window. 

	<li> To act as an OLE automation server, your application 
	needs a C++ class that defines an automation object. In 
	ClassExpress, you take care of this by adding a class. 
	Click on the Add Class button. 

	<li> Select a Class Type. This specifies the MFC class from 
	which your new class is derived. 

	<li> Type the name of the class in the New Class Name 
	textbox. 

	<li> Check the OLE automation box. If your class is derived 
	from CCmd Target or CWnd, the Creatable check box 
	and the External Name textbox become visible. 

	<li> For CCmdTarget-and CWnd-derived classes, if you want 
	OLE client applications to be able to create instances of 
	your OLE automation object, check the Creatable box as 
	well. 

	<li> For CCmdTarget-and CWnd-derived classes, enter an 
	External Name that will be used by OLE automation 
	client applications to identify your automation object. 

	<li> Click OK. At this point, ClassExpress generates the new 
	class in your project's source code and reports that the 
	classes were generated correctly. You are returned to the 
	main ClassExpress window. 
</ol>

Completing these steps creates the basic source code structure for 
your OLE automation class. However, you may also want to take 
advantage of ClassExpress's ability to add functions and properties to 
your class that will be exposed by OLE automation. 


<h3>Adding exposed functions to an automation server class</h3>

First, select the class from the Class Name drop-down list. To add a 
function, follow these steps: 

<ol>
	<li> Click the Add Function button on the Automation Server 
	page of ClassExpress. The <b>Add Function</b> dialog box 
	opens. 

	<li> In the External Name textbox of <b>Add Function</b>, type the 
	name by which automation clients will refer to the new 
	function. As you type, the Internal Name textbox mirrors 
	the name you are entering. 

	<li> If you want your new function to have an Internal Name 
	different from its External Name, type the desired 
	Internal Name in that textbox. The Internal Name is the 
	name the function will have in your source code. 

	<li> Select the function's Return Type from the drop-down list 
	with that label. In addition to the standard types <tt>void</tt>, 
	<tt>short</tt>, <tt>long</tt>, <tt>float</tt>, and <tt>double</tt>, this list contains the 
	OLE types <tt>CY</tt>, <tt>DATE</tt>, <tt>LPDISPATCH</tt>, <tt>SCODE</tt>, <tt>BOOL</tt>, 
	<tt>VARIANT</tt>, and <tt>LPUNKNOWN</tt>. If you are unfamiliar with 
	these latter types, consult the <i>OLE2 Programmer's 
	Reference</i> for their definitions. 

	<li> If your function takes arguments, add them one at a time 
	by clicking on the Add button at the bottom of the 
	Parameters List listbox. The <b>Add Parameter</b> dialog box 
	that is displayed lets you specify the Name and Type of a 
	parameter. Enter the parameter's name in the Name 
	textbox. Select its type from the Type drop-down list. 
	(The Type list contains more OLE types. See the OLE2 
	Programmer's Reference for details.) Click OK. You are 
	returned to the <b>Add Function</b> dialog box, in which the 
	parameter you just specified is displayed in the 
	Parameters List listbox. 
	<p>

	Follow the procedure just described to add any other 
	parameters the function requires. 
	<p>

	<li> Click OK in the <b>Add Function</b> dialog box. You are 
	returned to the Automation Server page of ClassExpress. 
	The function you just created is added to the Name 
	listbox, and is referred to using its external name. When 
	this function is selected in the Name listbox, the 
	Implementation listbox displays the prototype of the 
	function that ClassExpress generates to implement it. 
</ol>


<h3>Adding properties to an automation server class</h3>

First, select the class from the Class Name drop-down list. To add a 
property, follow these steps: 

<ol>
	<li> Click the Add Property button on the Automation Server 
	page of ClassExpress. The <b>Add Property</b> dialog box 
	opens. 

	<li> Select one of the radio buttons to the right of the 
	Implementation label. If you want to grant automation 
	clients read-only access to the property you are adding, 
	select Variable. If you want to grant read/write access to 
	the property, select Get/Set Function. 

	<li> In the External textbox, type the name by which 
	automation clients will refer to this property. 
	<p>

	As you type, the values of the Get Function and Set 
	Function fields are automatically filled in using the 
	external name <i>extname</i> you specify. If you are creating a 
	read-only property, it will be implemented as a member 
	variable in your automation class. The Get Function 
	textbox will contain the proposed name of that variable, 
	<tt>m_<i>extname</i></tt>. If you are creating a read/write property, it 
	will be implemented by a pair of member functions— a 
	Get and a Set function— in your automation class. The 
	Get Function and Set Function textboxes will contain the 
	proposed names of those functions, <tt>Get<i>extname</i></tt> and 
	<tt>Set<i>extname</i></tt>. 
	<p>

	<li> Select the Type of the property from the drop-down list 
	with that label. In addition to the standard types <tt>short</tt>, 
	<tt>long</tt>, <tt>float</tt>, and <tt>double</tt>, this list contains the OLE 
	types <tt>CY, DATE, LPDISPATCH, SCODE, BOOL, 
	VARIANT</tt>, and <tt>LPUNKNOWN</tt>. If you are unfamiliar with 
	these latter types, consult the <i>OLE2 Programmer's 
	Reference</i> for their definitions. 

	<li> If you want, change the names of the Get and Set 
	Function. 

	<li> Click OK in the <b>Add Property</b> dialog box. You are 
	returned to the Automation Server page of ClassExpress. 
	The property you just created is added to the Name 
	listbox and is referred to using its external name. When 
	this item is selected in the Name listbox, the 
	Implementation listbox displays the member variable or 
	the pair of functions that ClassExpress generates to 
	implement the property. 
</ol>


<h3>OLE automation server source code</h3>

This section examines some of the source code generated by 
ClassExpress that enables an application to be an OLE automation 
server. 
<p>

As explained in the previous section, you create a new class using 
ClassExpress and indicate that the class should support OLE 
automation. When the source code is generated, the constructor for 
your new class contains the following code: 


<pre>
	EnableAutomation(); 
	// To keep the application running as long as 
	// an OLE automation 
	// object is active, the constructor calls 
	// AfxOleLockApp. 
	AfxOleLockApp(); 
</pre>


OLE automation is first enabled for this object using the MFC 
function <tt>EnableAutomation</tt>. This function should only be called 
if there is a dispatch map declared for the class (discussed in more 
detail below). If your new class objects are creatable by other 
applications, then the MFC function <tt>AfxOleLockApp</tt> is called in 
your constructor. 
<p>

This function increments a global count of the number of times this 
object has been activated by OLE clients. It is the MFC library's way 
of ensuring that an object is not destroyed by one OLE client, if it is 
in use by another client. In the destructor for your class, 
ClassExpress has written a call to the function <tt>AfxOleUnlockApp</tt>, 
which decrements the global count for this object. 
<p>

ClassExpress also creates a new macro structure called a dispatch 
map, as shown in the following example: 


<pre>
	BEGIN_DISPATCH_MAP(COLEAutoObject, CCmdTarget) 
	    //{{ AFX_DISPATCH_MAP(COLEAutoObject) 
		// NOTE -the ClassExpress will add and 
		// remove mapping macros here. 
	    //}} AFX_DISPATCH_MAP 
	END_DISPATCH_MAP() 
</pre>


As you can see, a dispatch map is similar to a message map, the MFC 
library macro for routing Windows messages to your class methods. 
Like message maps, you do not edit the dispatch map directly; 
AppExpress and ClassExpress do that for you. The dispatch map is a 
macro that generates dispatch table information used by the MFC 
library's OLE classes to route automation requests. 
<p>

In addition to the OLE initialization code in the constructor and the 
dispatch map, ClassExpress optionally writes the following macro to 
your class implementation file (<tt>.cpp</tt>): 


<pre>
	IMPLEMENT_OLECREATE(COLEAutoObject,"MYOBJ",
		0xd73cfd60, 0x3cea, 0x101b, 0x80, 0x60, 
		0x4, 0x2, 0x1c, 0x0, 0x94, 0x2) 
</pre>


This macro is written if you selected the Creatable check box when 
you added the new class in ClassExpress. The macro allows your 
OLE automation object, as defined by your new C++ class, to be 
created dynamically by an OLE client application. If you do not have 
this macro, your automation object would have to be created by 
your application before any OLE client could manipulate it using the 
automation interface. 
<p>

The IMPLEMENT_OLECREATE macro takes these arguments: 

<ul>
	<li> The new class name 
	<li> The external name of the object 
	<li> The components of the class's OLE class ID 
</ul>


The last parameters, the components of the OLE class ID, together 
represent a 128-bit value that uniquely defines the OLE object within 
Windows. 
<p>

Another source code file created by ClassExpress has a filename 
consisting of the project name with the extension <tt>.odl</tt>. This file 
contains the Object Description Language implementation for your 
automation object class. You run the utility program 
<tt>mktyplib.exe</tt>, passing the <tt>.odl</tt> file as an argument. The result is 
a type library file with an extension of <tt>.tlb</tt>. 
<p>

The type library file is used by OLE automation clients to query the 
objects, properties, and functions exposed by your application. 
<p>

This section has given you a view of the source code generated for 
an OLE automation server. OLE automation has many more facets 
that you should explore. Refer to the <i>Microsoft Foundation Class 
Library Reference</i> and the <i>OLE2 Programmer's Reference</i> for 
additional details. 

<h2>Making Your Application an OLE2 Automation Client</h2>

The Automation Client selection of ClassExpress lets you make an 
application an OLE2 automation client for type libraries that export 
an OLE2 automation interface. ClassExpress creates a C++ class in 
your program that acts as an interface to the type library class. 
<p>

This section uses the OLE2 sample type library <tt>hello.tlb</tt>, found 
in <tt>samples\ole16\hello</tt> below your Digital Mars C++ installation 
directory. If you do not have this sample file installed, you can select 
any other type library file that exports an OLE2 automation interface. 
Otherwise, you should install the OLE2 samples. 
<p>

To make your application an OLE2 automation client: 

<ol>
	<li> Launch ClassExpress and, if necessary, open a project. 
	For this example, the application type of the project does 
	not matter. 

	<li> Select Automation Client from the list at the upper left of 
	the ClassExpress window. 

	<li> Click the "..." button to the right of the Type Library File 
	field. The <b>Open</b> dialog box is displayed. 
	<p>

	<b>Note:</b> 
	This dialog box has filtered out all filenames that do 
	not end with <tt>.tlb</tt> or <tt>.olb</tt>. These extensions are 
	used for OLE type library files. 
	<p>

	<li> Browse to the type library file 
	<tt>samples\ole16\hello\hello.tlb</tt> within the 
	Digital Mars C++ installation directory. 

	<li> Click OK in the <b>Open</b> dialog box. The type library file 
	should now be displayed in the Type Library File field in 
	the ClassExpress window. 
	<p>

	<b>Note:</b> 
	Class names representing exported OLE2 
	automation interfaces in the type library are 
	displayed in the Class list. 
	<p>

	<li> Select <tt>_DHello</tt> from the Class list. 

	<li> ClassExpress fills in the New Header File and New 
	Implementation File fields with the suggested file names 
	for the new C++ class that will be generated in your 
	framework. 

	<li> Click on the Generate button. ClassExpress creates the 
	header and implementation file for your new class. 
</ol>


The C++ class <tt>_DHello</tt> that was generated by ClassExpress 
represents the client OLE automation interface to the <tt>_DHello</tt> type 
defined in <tt>hello.tlb</tt>. This class provides a number of methods 
that simplify the processes of attaching to and detaching from an 
OLE automation dispatch connection. ClassExpress generates 
additional methods that simplify the interface to 
<tt>IDispatch::Invoke</tt>. If you are not familiar with the OLE 
automation architecture, refer to the <i>OLE2 Programmer's Reference</i>. 


<h2>Creating a C++ Wrapper Class for an Existing VBX</h2>


The VBXExpress section of ClassExpress lets you incorporate VBX 
controls into an MFC application. ClassExpress makes it easy to use a 
VBX by generating a C++ wrapper class through which you can 
directly program the VBX. The wrapper class makes use of the MFC 
base class CVBControl, which provides access to VBX properties and 
events. 
<p>

You can use VBXExpress with any 16-bit MFC application. (The 
restriction arises because VBXs themselves are inherently 16-bit.) 
Follow these steps to create a wrapper class for a VBX and add it to 
the class hierarchy of a project: 


<ol>
	<li> Launch ClassExpress— either from the IDDE or 
	standalone. If you launch ClassExpress standalone, 
	specify your project in the <b>Open</b> dialog box. 

	<li> Select VBXExpress from the list at the upper left of the 
	ClassExpress window. 

	<li> The control labeled VBX File displays the name of the 
	currently selected VBX file. Click the button labeled "...", 
	to the right of the control. An <b>Open</b> dialog box is 
	displayed. Select a VBX file and click OK. 
	<p>

	VBX File displays the name of the file selected. 
	<p>

	ClassExpress examines the VBX file to determine the 
	name and capabilities (events and properties supported) 
	of every VBX control contained in the file. (There can be 
	more than one.) The drop-down list labeled VBX 
	contains the names of all VBXs in the file. The 
	capabilities of the control selected from this list are 
	displayed in the Property and Event list. 
	<p>

	<li> In the textbox labeled ClassName, specify the name of 
	the C++ wrapper class that will be generated for the 
	currently selected VBX control. In the textboxes labeled 
	Header File, specify the names of the C++ files that will 
	contain the definition and implementation of the class. 
	Default names are provided in all three fields; you don't 
	have to change them. 

	<li> Repeat the above step for each VBX control in the VBX 
	file. 

	<li> Click on the Generate button. ClassExpress creates the 
	C++ wrapper classes. 
</ol>


Examine the interface to the VBX control(s) generated by 
ClassExpress by opening the header file in an IDDE source window. 
You will see that the methods of the C++ class correspond in a 
natural way to the properties and events of the VBX. 


<h2>Summary</h2>

This chapter covers ClassExpress in detail discussing these main 
points: 

<ul>
	<li> Deriving a new class in an application from one of the 
	many MFC library base classes 

	<li> Establishing links between class member variables and 
	dialog box or window controls, and validating user entry 
	without having to write a single line of code 

	<li> Manipulating objects within an application from any OLE 
	client application 

	<li> Conversely, enabling an application to manipulate OLE 
	automation objects in other applications 

	<li> Extending the power of an application with Visual Basic 
	custom controls, without having to write the control 
	yourself 
</ul>


With this information, you are able to add significant new 
functionality in a short period of time to the skeleton application 
framework that AppExpress generates. 



<br><br><br><br>

</td></table>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

